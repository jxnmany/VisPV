<!-- #############################################################
# Interactive visual analytics of text corpus and neural embedding
# Author: Xiaonan Ji (ji.62@osu.edu)
# Original: 2017.5.23
# Last Update: 2018.09
# ################################################################-->

<html>
<head>
	<meta charset="utf-8">
    <title>Visual Analytics of Neural Embedding</title>
    <link rel="stylesheet" href="./support/style.css" charset="utf-8">
</head>
<body>
	<h1>A Visual Analytic System on Neural Document Embeddings</h1>
	<h2>to interpret and exploit neural dimensions (semantic features) in information retrieval</h2>
	<div id="overview">
		<!--<input type="button" id="showEdge" name="showEdge" value="Show Edges" style="width: 100px;">-->
		<input type="button" id="showHighlight" class="checkButton" name="showHighlight" value="Show Benchmark" style="width: 100px;">
		<input type="button" id="showReference" class="checkButton" name="showReference" value="Show Reference" style="width: 100px;">
		<input type="button" id="ResetColor" class="checkButton" name="ResetColor" value="Reset Color" class="Reset">
		<input type="button" id="ResetMap" class="checkButton" name="ResetMap" value="Reset Map" class="Reset">
		<!--<input type="button" id="showTest" name="showTest" value="Test" style="width: 55px;">-->
		<div id="search">
			<!--<input type="text" id="searchDOI" placeholder="Please provide an ID" class="inputText">
			<button id="searchByDOI" class="searchButton">Search ID</button>-->
			<input type="text" id="searchIndex" style="width: 100px;" placeholder="Document IDs" class="inputText">
			<button id="searchByIndex" class="searchButton">Search IDs</button>
			<input type="text" id="searchText"  style="width: 100px;" placeholder="Keywords" class="inputText">
			<button id="searchByText" class="searchButton">Search Keyword</button>
		</div>	
	</div>	
	<div id="scatter" style="height: 500px; width: 800px;">
	</div>
	<div id="clusterComponents">
	</div>
	<div id="dimensionSelectionComponents">
	</div>
	<div id="overallInfoDiv">
		<p id="overallInfo" style="font-size: 12px; padding: 2px 2px 2px 2px; display: block; color: #808B96">Overall Information</p>
	</div>
	<div id="clusterInfoDiv">
		<h4 style="padding: 0px 0px 0px 3px;">Topic/Keyword Synthesis</h4>
		<p id="clusterInfo" style="font-size: 12px; padding: 2px 2px 2px 2px; display: block; background-color: white; direction: ltr;"></p>
	</div>
	<!--
	<div id="toolbar">
		<div id="year">
			<h4 style="padding-left:400px;">-Year of Publications-</h4>
			<p>1990</p><p>1991</p><p>1992</p><p>1993</p><p>1994</p><p>1995</p><p>1996</p><p>1997</p><p>1998</p><p>1999</p>
			<p>2000</p><p>2001</p><p>2002</p><p>2003</p><p>2004</p><p>2005</p><p>2006</p><p>2007</p><p>2008</p><p>2009</p>
			<p>2010</p><p>2011</p><p>2012</p><p>2013</p><p>2014</p><p>2015</p><p>2016</p><p>2017</p><br>
			<hr/>
			<input type="checkbox" class="myCheckbox" value="1990" checked>
			<input type="checkbox" class="myCheckbox" value="1991" checked>
			<input type="checkbox" class="myCheckbox" value="1992" checked>
			<input type="checkbox" class="myCheckbox" value="1993" checked>
			<input type="checkbox" class="myCheckbox" value="1994" checked>
			<input type="checkbox" class="myCheckbox" value="1995" checked>
			<input type="checkbox" class="myCheckbox" value="1996" checked>
			<input type="checkbox" class="myCheckbox" value="1997" checked>
			<input type="checkbox" class="myCheckbox" value="1998" checked>
			<input type="checkbox" class="myCheckbox" value="1999" checked>
			<input type="checkbox" class="myCheckbox" value="2000" checked>
			<input type="checkbox" class="myCheckbox" value="2001" checked>
			<input type="checkbox" class="myCheckbox" value="2002" checked>
			<input type="checkbox" class="myCheckbox" value="2003" checked>
			<input type="checkbox" class="myCheckbox" value="2004" checked>
			<input type="checkbox" class="myCheckbox" value="2005" checked>
			<input type="checkbox" class="myCheckbox" value="2006" checked>
			<input type="checkbox" class="myCheckbox" value="2007" checked>
			<input type="checkbox" class="myCheckbox" value="2008" checked>
			<input type="checkbox" class="myCheckbox" value="2009" checked>
			<input type="checkbox" class="myCheckbox" value="2010" checked>
			<input type="checkbox" class="myCheckbox" value="2011" checked>
			<input type="checkbox" class="myCheckbox" value="2012" checked>
			<input type="checkbox" class="myCheckbox" value="2013" checked>
			<input type="checkbox" class="myCheckbox" value="2014" checked>
			<input type="checkbox" class="myCheckbox" value="2015" checked>
			<input type="checkbox" class="myCheckbox" value="2016" checked>
			<input type="checkbox" class="myCheckbox" value="2017" checked>
			<br>
			<input type="button" id="SelectNext" name="SelectNext" value="Select Next Year" class="SelectNext">
			<input type="button" id="SelectAll" name="SelectAll" value="Select All Years" class="SelectAll">
			<input type="button" id="Clear" name="Clear" value="Clear" class="Clear">
		</div>
	</div>
	-->
	<!--<div id="selectData">
		<h4 style="padding: 0px 0px 0px 3px;">Select Dataset</h4>
	</div>-->
	<!--<div id="selectMode">
		<h4 style="padding: 0px 0px 0px 3px;">2D Layout</h4>
		<p style="color: #2394b9">Force-directed Graph Drawing</p><br>
		<input type="radio" name="mode" class="mode" id="layout_fa" value="layout_fa">
			<p style="font-size:80%; background-color:#028cb9; color:white; border-radius: 4px;">&nbsp;1&nbsp;</p><p>Force Atlas</p><br>
		<input type="radio" name="mode" class="mode" id="layout_fr" value="layout_fr">
			<p style="font-size:80%; background-color:#028cb9; color:white; border-radius: 4px;">&nbsp;2&nbsp;</p><p>Fruchterman Reingold</p><br>
		<p style="color: #2394b9; padding-top: 2px;">Dimensionality Reduction</p><br>
		<input type="radio" name="mode" class="mode" id="layout_tsne_text" value="layout_tsne_text" checked>
			<p style="font-size:80%; background-color:#028cb9; color:white; border-radius: 4px;">&nbsp;2&nbsp;</p><p>PV + t-SNE</p><br>
		<input type="radio" name="mode" class="mode" id="layout_tsnePA_text" value="layout_tsnePA_text">
			<p style="font-size:80%; background-color:#028cb9; color:white; border-radius: 4px;">&nbsp;5&nbsp;</p><p>PA + t-SNE</p><br>
	</div>-->
	
	<!--<div id="selectLevel">
		<h4 style="padding: 0px 0px 5px 5px;">Clustering Level</h4>
		<input type="radio" name="level" class="level" id="level2" value="2" checked><p>High (Optimal)</p><br>
		<input type="radio" name="level" class="level" id="level1" value="1"><p>Medium</p><br>
		<input type="radio" name="level" class="level" id="level0" value="0"><p>Low</p>
	</div>-->
	<!--<div id="rightTools" style="position: relative;">-->
	<div id="selectHC">
		<h4 style="padding: 0px 0px 0px 3px;">Hierarchical Clustering (default)</h4>
		<p>Data:</p>
		<input type="radio" name="clusterMode_hc" class="clusterMode_hc" id="clusterMode_hc_original" value="original" checked><p>Neural Embedding</p>
		<input type="radio" name="clusterMode_hc" class="clusterMode_hc" id="clusterMode_hc_2d" value="2d"><p>t-SNE</p><br>
		<p>Linkage:</p>
		<input type="radio" name="linkage_hc" class="linkage_hc" id="linkage_hc_ward" value="WARD" checked><p>Ward</p>
		<input type="radio" name="linkage_hc" class="linkage_hc" id="linkage_hc_complete" value="COMPLETE"><p>Complete</p>
		<input type="radio" name="linkage_hc" class="linkage_hc" id="linkage_hc_single" value="SINGLE"><p>Single</p>
		<input type="radio" name="linkage_hc" class="linkage_hc" id="linkage_hc_average" value="AVERAGE"><p>Average</p><br>
		<p>Level:</p>
		<!--<input type="text" style="width:100" name="hc_level" id="hc_level" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="Deafult level=5"></input>-->
		 	<div class="value-button" id="decrease" onclick="decreaseValue()" value="Decrease Value">-</div>
  			<input type="number" name="hc_level" id="hc_level" value="4" />
  			<div class="value-button" id="increase" onclick="increaseValue()" value="Increase Value">+</div>
		<button id="runHC">Run</button>
	</div>
	<div id="selectKmeans">
		<h4 style="padding: 0px 0px 0px 3px;">Kmeans Clustering</h4>
		<p>Data:</p>
		<input type="radio" name="clusterMode" class="clusterMode" id="clusterMode_original" value="original" checked><p>Neural Embedding</p>
		<input type="radio" name="clusterMode" class="clusterMode" id="clusterMode_2d" value="2d"><p>t-SNE</p><br>
		<p>K:</p><input type="text" style="width:50" name="kmeans_k" id="kmeans_k" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="5"></input>
		<!--<button id="setKmeans_k">Update</button><br>-->
		<p>Step:</p><input type="text" style="width:50" name="kmeans_step" id="kmeans_step" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="500"></input>
		<button id="runKmeans">Run</button>
	</div>
	<div id="selectHighlight">
		<h4 style="padding: 0px 0px 0px 3px; display: inline;">Cluster Aggregation</h4>
		<p>magnitude:</p><input type="text" style="width:50" name="highlight_mag" id="highlight_mag" placeholder="e.g. 0"></input>
		<button id="clusterHighlight">Apply</button>
		<!--<input type="radio" name="highlight" class="highlight" id="separate_normal" value="normal" checked><p>Low</p>
		<input type="radio" name="highlight" class="highlight" id="separate_adjust" value="adjust"><p>Medium</p>
		<input type="radio" name="highlight" class="highlight" id="separate_adjust2" value="adjust2"><p>High</p>-->
	</div>

	<div id="selectDimensions">
		<h4 style="padding: 0px 0px 0px 3px;">Feature (Dimension) Selection</h4>
		<textarea id="dimensions" rows="4" cols="65">
		</textarea><br>
	</div>
	<div id="vectorExplore4">
		<h4 style="padding: 0px 0px 0px 3px;">Adapt Map Coloring - Responsive Documents</h4>
		<!--<p>Dimension IDs:</p><input type="text" style="width:300" name="exploreDimensions_dim" id="exploreDimensions_dim" placeholder="Please input one or multiple dimensions e.g. 0,1,2,3"></input>
		<br>-->
		<!--<p>Responsive Articles By:</p>-->
		<input type="radio" name="exploreDimensions_mode" class="exploreDimensions_mode" id="exploreDimensions_mode_value" value="value" checked><p>Average Value >=</p>
		<input type="text" style="width:50" name="exploreDimensions_at" id="exploreDimensions_at" placeholder=""></input>
		<p>and <=</p>
		<input type="text" style="width:50" name="exploreDimensions_at2" id="exploreDimensions_at2" placeholder=""></input><br>
		<input type="radio" name="exploreDimensions_mode" class="exploreDimensions_mode" id="exploreDimensions_mode_distance" value="distance"><p>Distance <=</p>
		<input type="text" style="width:50" name="exploreDimensions_dist" id="exploreDimensions_dist" placeholder="e.g. 0.4"></input>
		<p>to Reference Documents</p><input type="text" style="width:110" name="exploreDimensions_ref" id="exploreDimensions_ref" placeholder="e.g. 0,1,2,3"></input>
		<br>
		<p>Keyword#:</p><input type="text" style="width:50" name="exploreDimensions_kt" id="exploreDimensions_kt" placeholder="e.g. 20"></input>
		<input type="radio" name="exploreDimensions_kr" class="exploreDimensions_kr" id="exploreDimensions_kr_tf" value="termFrequency" checked><p>Term Frequency (TF)</p>
		<input type="radio" name="exploreDimensions_kr" class="exploreDimensions_kr" id="exploreDimensions_kr_df" value="documentFrequency"><p>Doc Frequency (DF)</p><br>
		<button id="exploreDimensions" class="searchButton">Apply Dimensions</button></br>
	</div>
	<div id="documentMap">
		<h4 style="padding: 0px 0px 0px 3px;">Regenerate Map (t-SNE)</h4>
		<p>Perplexity:</p><input type="text" style="width:100" name="tsne_perplexity" id="tsne_perplexity" onkeypress='return event.charCode >= 48 && event.charCode <= 57' placeholder="Deafult P=30">
		<p>Learning Rate:</p><input type="text" style="width:100" name="tsne_rate" id="tsne_rate" onkeypress='return event.charCode >= 48 && event.charCode <= 57' placeholder="Deafult Rate=10"><br>
		<button id="setDimensions">Apply Dimensions</button>
		<!--<button id="setDimensionsAll">All Dimensions</button>-->
	</div>
	<!--</div>-->
	
	<!--
	<div id="citationSize">
		<h4 style="padding: 0px 0px 0px 3px;">Point Size (#Citation)</h4>
		<p>Multiplier:</p><input type="text" style="width:50" name="citation_size" id="citation_size" placeholder="0"></input>
		<button id="setCitationSize">Run</button>
	</div>-->
	
	<!--<div id="relatedNode">
		<h4 style="padding: 0px 0px 5px 5px;">Related Publications</h4>
		<input type="checkbox" class="relatedType" value="References" checked><p>(Reference) Being-Cited</p><br>
		<input type="checkbox" class="relatedType" value="Citations" checked><p>(Citation) Citing</p>
	</div>-->
	
	<!--<div id="selectCluster">
		<h4 style="padding: 0px 0px 5px 5px;">Cluster Filter</h4>
		<dl class="dropdown"> 
			<dt>
			<a href="#">
			  <span class="hida">Please click to select</span>    
			  <p class="multiSel"></p>  
			</a>
			</dt>
			<dd>
				<div class="mutliSelect">
					<ul id="clusterOptions">
					</ul>
				</div>
			</dd>
		  <button id="clusterFilter">Filter</button>
		  <button id="clusterAll">Select All</button>
		  <button id="clusterClear">Clear</button>
		</dl>
	</div>-->
	<!--
	<div id="nodeInfoDiv">
		<h4 style="padding: 0px 0px 5px 5px;">Keywords</h4>
		<p style="padding: 0px 0px 5px 0px; color: #008CBA; display: block">Please <b>mouseover</b> a publication for keywords.</p>
		<p id="nodeInfo" style="font-size: 12px; padding: 2px 2px 2px 2px; display: block; background-color: lightblue"></p>
	</div>
	-->
	<!--
	<div id="zoom_buttons">
		<button id="zoom_out" class="zoomButton">-</button>
		<button id="zoom_in" class="zoomButton">+</button>
	</div>
	-->
	<div id="articleProfile" style="height: 0px;">
	</div>
	<div class="tab">
  		<button class="tablinks" onclick="openTab(event, 'vectorExplore6')">Cluster-Level Dimension Behavior</button>
  		<button class="tablinks" onclick="openTab(event, 'vectorExplore7')">Document-Level Dimension Behavior</button>
  		<button class="tablinks" onclick="openTab(event, 'vectorExplore8')">Dimension Correlation</button>
  		<button class="tablinks" onclick="openTab(event, 'vectorExplore5')" style="float: right;">Keywords Explorer</button>
  		<button class="tablinks" onclick="openTab(event, 'vectorExplore0')" style="float: right;">Dimension Overview</button>
	</div>
	<div id="toolbox" style="margin-top: 10px;">
	<!--<p style="margin: 5 0 0 40; color: #ABB2B9;">Non-Scroll</p>
		<input type="radio" name="selectScroll" class="selectScroll" id="scroll_no" value="no" checked>
	<p style="margin: 5 0 0 5; color: #ABB2B9;" >Scroll</p>	
		<input type="radio" name="selectScroll" class="selectScroll" id="scroll_yes" value="yes">-->
	<div id="vectorExplore0" class="tabcontent" style="height: 45px; width: 1250px; position: relative;">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Behavior - Overview</h4>
		<p>Dimension IDs:</p><input type="text" style="width:200" name="checkDimensions_dim" id="checkDimensions_dim" placeholder="e.g. all OR 1,2,3"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Rank by:</p>
		<input type="radio" name="checkDimensions_rank" class="checkDimensions_rank" id="checkDimensions_rank_index" value="index" checked><p>Index</p>
		<input type="radio" name="checkDimensions_rank" class="checkDimensions_rank" id="checkDimensions_rank_variance" value="variance"><p>Global Document Discrimination</p>
		<input type="radio" name="checkDimensions_rank" class="checkDimensions_rank" id="checkDimensions_rank_variance_cluster" value="variance_cluster"><p>Global Cluster Discrimination</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="checkDimensions_variance" class="searchButton">Check Dimensions</button>
		<!--<button id="checkDimensions_reset" class="searchButton">Reset</button>--?
		<!--<p>Range of Deviation: </p><input type="text" style="width:50" name="checkDimensions_varianceBottom" id="checkDimensions_varianceBottom" placeholder="e.g. 0"></input>
		<p><= Variance <=</p><input type="text" style="width:50" name="checkDimensions_varianceTop" id="checkDimensions_varianceTop" placeholder="e.g. 2"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Range of Mean: </p><input type="text" style="width:50" name="checkDimensions_meanBottom" id="checkDimensions_meanBottom" placeholder="e.g. -1"></input>
		<p><= Mean <=</p><input type="text" style="width:50" name="checkDimensions_meanTop" id="checkDimensions_meanTop" placeholder="e.g. 1"></input>
		<button id="checkDimensions_variancHighlight" class="searchButton">Highlight Dimensions</button></br>-->
	</div>
	<div id="vectorExplore6" class="tabcontent" style="height: 95px; width: 1200px; position: relative;" class="parcoords">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Behavior - Group Level</h4>
		<p><b><i>PC Items</i></b></p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Type: </p>
		<!--<input type="radio" name="compareMode_pc2" class="compareMode_pc2" id="compareMode_pc2_article" value="article"><p>Article</p>-->
		<input type="radio" name="compareMode_pc2" class="compareMode_pc2" id="compareMode_pc2_cluster" value="cluster" checked><p>Cluster of Documents</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<!--
		<p>Item1 ID:</p><input type="text" style="width:120" name="compareItem1_pc" id="compareItem1_pc" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="1"></input>
		<p>Item2 ID:</p><input type="text" style="width:100" name="compareItem2_pc" id="compareItem2_pc" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="2"></input>
		-->
		<p>Cluster IDs:</p><input type="text" style="width:200" name="compareItems_pc2" id="compareItems_pc2" placeholder="e.g. 0,1,2,3"></input>
		<br>
		<p><b><i>PC Axes - Dimensions</i></b></p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Global Rank  </p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_index" value="index"><p>Index</p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance" value="variance"><p>Variability across Docs (SD) </p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_pca" value="variance_pca"><p>Variability across Docs (PCA)</p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_cluster" value="variance_cluster"><p>Variability across Clusters (SD)</p><br>
		<!--<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_cluster_pca" value="variance_cluster_pca"><p>Cluster PCA</p><br>-->
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Cluster-based Rank  </p>
		<p>Cx:</p>
		<input type="text" style="width:100" name="rankmode_pc2_clusterid" id="rankmode_pc2_clusterid" placeholder="Cluster ID"></input>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_clusterDis" value="variance_clusterDis" checked><p>Cx vs. Others</p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_clusterSimi" value="variance_clusterSimi"><p>Coherence in Cx (~SD)</p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_clusterSimi_pca" value="variance_clusterSimi_pca"><p>Coherence in Cx (~PCA)</p>
		<input type="radio" name="rankmode_pc2" class="rankmode_pc2" id="rankmode_pc2_variance_clusterAvg" value="variance_clusterAvg"><p>AverageValue in Cx</p><br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Dimension Display Range:</p><input type="text" style="width:130" name="compareDims_pc2" id="compareDims_pc2" placeholder="e.g. 0-29 OR 0-199"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Value Mode:</p>
		<input type="radio" name="compareValue_pc2" class="compareValue_pc2" id="compareValue_pc2_original" value="original" checked><p>Original</p>
		<input type="radio" name="compareValue_pc2" class="compareValue_pc2" id="compareValue_pc2_normArticle" value="normArticle"><p>normDocument</p>
		<input type="radio" name="compareValue_pc2" class="compareValue_pc2" id="compareValue_pc2_normDim" value="normDim"><p>normDimension</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="comparePair_pc2" class="searchButton" width = "100px">Check Document Cluster</button></br>
	</div>
	<!--
	<div id="vectorExplore2" style="height: 45px; width: 1200px;">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Behavior - Item Level (Pairwise Bar Charts)</h4>
		<p>Item Type:</p>
		<input type="radio" name="compareMode" class="compareMode" id="compareMode_article" value="article" checked><p>Article</p>
		<input type="radio" name="compareMode" class="compareMode" id="compareMode_cluster" value="cluster"><p>Cluster</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Item1 ID:</p><input type="text" style="width:40" name="compareItem1" id="compareItem1" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="0"></input>
		<p>Item2 ID:</p><input type="text" style="width:40" name="compareItem2" id="compareItem2" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="1"></input>
		<p>Rank by:</p>
		<input type="radio" name="ifRank" class="ifRank" id="ifRank_index" value="index" checked><p>Index</p>
		<input type="radio" name="ifRank" class="ifRank" id="ifRank_value" value="value"><p>Value</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Chart Mode:</p>
		<input type="radio" name="compareChart" class="compareChart" id="compareChart_align" value="align" checked><p>Alignment (Symmetry)</p>
		<input type="radio" name="compareChart" class="compareChart" id="compareChart_space" value="space"><p>Space (Difference)</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="comparePair" class="searchButton">Compare</button>
	</div>
	-->
	<div id="vectorExplore7" class="tabcontent" style="height: 105px; width: 1200px; position: relative;">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Behavior - Document Level</h4>
		<p>Type:</p>
		<input type="radio" name="compareMode_hm" class="compareMode_hm" id="compareMode_hm_article" value="article" checked><p>Individual Documents</p>
		<!--<input type="radio" name="compareMode_hm" class="compareMode_hm" id="compareMode_hm_cluster" value="cluster"><p>Cluster</p>-->
		<br>
		<p>A List of Document IDs: </p><input type="text" style="width:300" name="compareItems_hm" id="compareItems_hm" placeholder="e.g. 0,1,2,3"></input>
		<button id="compareMultiple_reference" class="searchButton_plain">Use References</button>&nbsp;
		<button id="compareMultiple_representative" class="searchButton_plain">Use Cluster-Samples</button>
		&nbsp;&nbsp;&nbsp;
		<p>Contrast Document IDs: </p><input type="text" style="width:150" name="compareItems_hm_ref" id="compareItems_hm_ref" placeholder="e.g. 4,5,6"></input>
		&nbsp;&nbsp;&nbsp;
		<button id="compareMultiple" class="searchButton">Check Document List</button>
		<br>
		<p style="color: #909497;">Or, A Pair of Document IDs: </p>
		<p style="color: #909497;">ID1</p><input type="text" style="width:50; color: #909497;" name="compareItem1" id="compareItem1" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="e.g. 0"></input>
		<p style="color: #909497;">ID2</p><input type="text" style="width:50; color: #909497;" name="compareItem2" id="compareItem2" onkeypress='return event.charCode >= 48 && event.charCode <= 57'
		placeholder="e.g. 1"></input>
		&nbsp;&nbsp;
		<p style="color: #909497;">Chart Mode:</p>
		<input type="radio" name="compareChart" class="compareChart" id="compareChart_align" value="align" checked><p style="color: #909497;">Alignment (Symmetry)</p>
		<input type="radio" name="compareChart" class="compareChart" id="compareChart_space" value="space"><p style="color: #909497;">Space (Difference)</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="comparePair_new" class="searchButton" style="background-color: #5DADE2;">Check Document Pair</button>
		<br>
		<p>Dimension Rank by:</p>
		<input type="radio" name="ifRank_hm" class="ifRank_hm" id="ifRank_hm_index" value="index" checked><p>Index</p>
		<input type="radio" name="ifRank_hm" class="ifRank_hm" id="ifRank_hm_dis" value="dis"><p>Variability (SD)</p>
		<input type="radio" name="ifRank_hm" class="ifRank_hm" id="ifRank_hm_simi" value="simi"><p>Coherence (~SD)</p>
		<input type="radio" name="ifRank_hm" class="ifRank_hm" id="ifRank_hm_avg" value="avg"><p>AverageValue</p>
		<input type="radio" name="ifRank_hm" class="ifRank_hm" id="ifRank_hm_value" value="value"><p>DocumentValue </p>
		<input type="text" style="width:80" name="ifRank_hm_id" id="ifRank_hm_id" placeholder="Document ID"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Dimension Display Range:</p><input type="text" style="width:130" name="compareDims_hm" id="compareDims_hm" placeholder="e.g. 0-29 OR 0-199"></input>
	</div>
	<!--
	<div id="vectorExplore3" style="height: 45px; width: 1200px;" class="parcoords">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Behavior - Item-level (Parallel Coordinates)</h4>
		<p>Item Type:</p>
		<input type="radio" name="compareMode_pc" class="compareMode_pc" id="compareMode_pc_article" value="article" checked><p>Article</p>
		<input type="radio" name="compareMode_pc" class="compareMode_pc" id="compareMode_pc_cluster" value="cluster"><p>Cluster</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Item IDs:</p><input type="text" style="width:200" name="compareItems_pc" id="compareItems_pc" placeholder="input a list of IDs e.g. 1,2,3"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Value Mode:</p>
		<input type="radio" name="compareValue_pc" class="compareValue_pc" id="compareValue_pc_original" value="original" checked><p>Original</p>
		<input type="radio" name="compareValue_pc" class="compareValue_pc" id="compareValue_pc_normArticle" value="normArticle"><p>normArticle</p>
		<input type="radio" name="compareValue_pc" class="compareValue_pc" id="compareValue_pc_normDim" value="normDim"><p>normDimension</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="comparePair_pc">Compare</button></br>
	</div>
	-->
	<div id="vectorExplore5" class="tabcontent" style="height: 70px; width: 1200px; position: relative;">
		<h4 style="padding: 0px 0px 0px 3px;">Keyword Explorer</h4>
		<p>Cutoff Between Common/Specific Keywords: </p><input type="text" style="width:50" name="exploreKeywords_cutoff" id="exploreKeywords_cutoff" placeholder="e.g. 50"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Number of Keywords:</p><input type="text" style="width:50" name="exploreKeywords_kt" id="exploreKeywords_kt" placeholder="e.g. 20"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Keywords Rank by:</p>
		<input type="radio" name="exploreKeywords_kr" class="exploreKeywords_kr" id="exploreKeywords_kr_tf" value="termFrequency" checked><p>Term Frequency</p>
		<input type="radio" name="exploreKeywords_kr" class="exploreKeywords_kr" id="exploreKeywords_kr_df" value="documentFrequency"><p>Document Frequency</p>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="generateKeywords" class="searchButton">Check Keywords</button></br>
		<div id="exploreKeywords"></div>
		<p id="selectedKeyword" style="color:green; font-weight:bold"></p><br>
		<p><b>Associated Dimensions of Selected Keywords (and Documents)</b></p>
		<p>Threshold of Dimension Value:</p><input type="text" style="width:50" name="exploreKeywords_dv" id="exploreKeywords_dv" placeholder="e.g. 0.4"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<p>Threshold of Document Frequency:</p><input type="text" style="width:50" name="exploreKeywords_af" id="exploreKeywords_af" placeholder="e.g. 3"></input>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		<button id="getDimensions" class="searchButton">Check Dimensions</button></br>
	</div>
	<div id="vectorExplore8" class="tabcontent" style="width: 1200px; position: relative;">
		<h4 style="padding: 0px 0px 0px 3px;">Dimension Correlation</h4>
		<p>Dimension ID:</p><input type="text" style="width:100" name="checkCorrelation_dimID" id="checkCorrelation_dimID" placeholder="e.g. 0"></input>
		&nbsp;&nbsp;
		<p>Dimension Display Range:</p><input type="text" style="width:130" name="checkCorrelation_range" id="checkCorrelation_range" placeholder="e.g. 0-29 OR 0-199"></input>
		&nbsp;&nbsp;
		<button id="checkCorrelation_dim" class="searchButton">Check Individual Dimension</button><br>
		<p>Rank By:</p>
		<input type="radio" name="checkCorrelation_rank" class="checkCorrelation_rank" id="checkCorrelation_rank_index" value="index"><p>Index</p><p>&nbsp;&nbsp;<b>&#9474;</b>&nbsp;&nbsp;</p>
		<input type="radio" name="checkCorrelation_rank" class="checkCorrelation_rank" id="checkCorrelation_rank_cluster" value="cluster"><p>Hierarchical Cluster - Level</p>
		<div class="value-button" id="dim_decrease" onclick="dim_decreaseValue()" value="Decrease Value">-</div>
  		<input type="number" name="dim_hc_level" id="dim_hc_level" value="4" style="width: 30px;"/>
  		<div class="value-button" id="dim_increase" onclick="dim_increaseValue()" value="Increase Value">+</div>
		&nbsp;&nbsp;
		<input type="radio" name="checkCorrelation_rank" class="checkCorrelation_rank" id="checkCorrelation_rank_kmeans" value="kmeans" checked><p>K-means Cluster - K</p>
		<div class="value-button" id="dim_decrease_kmeans" onclick="dim_decreaseValue_kmeans()" value="Decrease Value">-</div>
  		<input type="number" name="dim_kmeans" id="dim_kmeans" value="6" style="width: 30px;"/>
  		<div class="value-button" id="dim_increase_kmeans" onclick="dim_increaseValue_kmeans()" value="Increase Value">+</div>
		<p>, with Value Mode of</p>
		<input type="radio" name="checkCorrelation_mode" class="checkCorrelation_mode" id="checkCorrelation_mode_value" value="value"><p>Dim Value</p>
		<input type="radio" name="checkCorrelation_mode" class="checkCorrelation_mode" id="checkCorrelation_mode_correlation" value="correlation" checked><p>Dim Correlation</p>
		<button id="checkCorrelation" class="searchButton">Check Correlation Matrix</button>
	</div>
	<!--<div id="vectorExplore1" style="height: 0px;">
	</div>-->
	<div id="clusterSummary" style="height: 0px;">
	</div>
	<div id="clusterCompare" style="height: 0px;">
	</div>
	<div id="heatmap">
	</div>
	</div>
	<div id="main_content">
		<div id="overview">
		<h3>Overview</h3>
		<p>This visual analytic system aims to facilitate (systematic) literature reviews on large-scale text document (article) collections with information visual analytics and user interaction. 
		We hope this system would assist human reviews in exploring article collections and approaching relevant knowledge with both efficiency and effectiveness. 
		More specifically: (1) Obtain a rapid overview of an article collection based on the visible distribution of articles and identified clusters,
		(2) Locate potential articles of interests by narrowing down to specific subsets or clusters,
		(3) Identify highly relevant articles to a precise information need.
		In addition, with this system, we hope to enable further knowledge synthesization & discovery, as well as provide a basic understanding of a research topic or research community behind.
		<p><i>Brief descriptions about some technical highlights of this visual analytic system.</i>
		Visualizations of text document collections via text analytics that generates structured article features, representations, and similarities. 
		Two-dimensional (2D) drawings of a document collection by positioning article (document) points in a 2D space, using both article maps via dimensionality reduction algorithms, and sparsified article networks via force-directed layouts. 
		Reveal important hidden patterns especially the clustering patterns of similar articles.
		A series of interactive features that enable human reviewers to conduct multiple visual analytic tasks (in their entire analytic session) at different scales. 
		The corresponding realizations of these features can be summarized as: Multilevel structure with hierarchical clustering & adjustable resolution; Reinforcement of clustering patterns and reveal of cluster topics for enhanced human interpretation; 
		Hierarchical navigation with stable and continuous transitions (Pan and Zoom) among multiple views; Identification of focal nodes and/or clusters of interests (semantic contextual sub-datasets); 
		Exploration of clusters with details on demand. Besides outcomes from text analysis, some bibliometric information i.e. citations and publication years are also considered.<p>
		<h3> A Quick Tutorial on Main System Features</h3>
		<ul>
		<li><p>A visible article distribution displayed in the <b>Main View</b>, where articles are represented as visual article points and their similarities are encoded with geometric (spatial) distances. </p></li>
		<li><p>Four different types of layouts for the 2D placement of article points, and all of them attempted to draw similar articles closer to each other while push dissimilar article farther apart. (<b>2D Layout</b> on the right panel)</p></li>
		<li><p>Explicit clustering patterns which are reflected by the color and luminance of article points, and can be reinforced by more aggressive spatial aggregation/seperation (<b>Cluster Aggregation</b> on the right panel). </p></li>
		<li><p>With hierarchical clustering approaches, three clustering levels are maintained and can be switched based on a desired resolution. Specifically, there are a smaller number of larger clusters on an upper level, but a larger number of smaller clusters on a lower level. The top level is the default. (<b>Clustering Level</b> on the right panel)</p></li>
		<li><p>Reveal of cluster region (boundary) and cluster topic (sets of salient keywords in the left window), when <b>mouse-over</b> any article point belonging to a specific cluster.</p></li>
		<li><p>Filter and select clusters of interests via a dropdown list of checkboxes (<b>Cluster Filter</b> on the right panel).</p></li>
		<li><p>Pan and zoom (as transitions between focus and context) with <b>mouse-drag & mouse-wheel</b> to explore an article collection at different portions and at different scales. Specifically, zoom-out for an overview and zoom-in for a closer examination. </p></li>
		<li><p>Search specific articles with an article ID or certain keywords (<b>Search Bars</b> on the top panel). </p></li>
		<li><p>An article profile, with the link to PubMed (for detailed article information), ID, title, author keywords, and extracted keywords, are displayed when <b>mouse-click</b> and select an article. </p></li>
		<li><p>Related articles that have a citing or being-cited relationships are highlighted when <b>mouse-click</b> and select an article. The type of related articles is customizable (<b>Related Publications</b> on the right panel). </p></li>
		<li><p>Enable the display of preserved edges representing strong article similarities to approach some topological structures and properties, e.g. article importance reflected by centrality. (<b>Show/Hide Edges</b> on the top panel) </p></li>
		<li><p>Filter and select articles based on the publication years, and investigate the development of a research area through the past dozens of years by gradually including more articles based on the publication years in an ascending order. (<b>Year of Publications</b> on the bottom panel) </p></li>
		<li><p>Unselect or unmark nodes (<b>Reset</b> on the top panel, or, click blank space). </p></li>
		<li><p>If available, highlight gold-standard relevant articles that were included in a review by experts (<b>Show Included</b> on the top panel).</p></li>
		</ul>
		<h3> Basic Workflow of our Implementation (both backend and frontend)</h3>
		<img src="./img/workflow.png" alt="Workflow Picture" style="width:1000px; margin-left: 50px; margin-top:10px;">
		</div>
	</div>
	<canvas id="canv1" width="400" height="250"></canvas>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<!--<script src="http://riccardoscalco.github.io/textures/textures.min.js"></script>-->
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<script src="./support/stemmer.js" charset="utf-8"></script>
	<script src="./support/tsne.js" charset="utf-8"></script>
	<script src="http://rawgithub.com/jbeuckm/K-Means/master/build/kmeans.min.js"></script>
	<script src="https://www.lactame.com/lib/ml/3.3.0/ml.min.js"></script>
	
	<script src="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.js"></script>
	<link rel="stylesheet" type="text/css" href="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.css">
	<!--<script src="./support/d3.parcoords.js" charset="utf-8"></script>-->
	<!--<script src="./support/d3.parcoords.css" charset="utf-8"></script>-->
	<script src="./support/sylvester.js" charset="utf-8"></script>
	<script src="./support/underscore.js" charset="utf-8"></script>
	<script src="./support/underscore.math.js" charset="utf-8"></script>
	<script src="./support/jHC.js" charset="utf-8"></script>
	<script src="./support/spearson.js" charset="utf-8"></script>
	<!--<script src='https://rawgit.com/karpathy/tsnejs/master/tsne.js'></script>-->
	<!--<script src="./support/hull.js" charset="utf-8"></script>-->
    <script>
	
	var margin = { top: 0, right: 0, bottom: 0, left: 30 },
    outerWidth = 800,
    outerHeight = 500,
    width = outerWidth - margin.left - margin.right,
    height = outerHeight - margin.top - margin.bottom;
	
	var x = d3.scale.linear().range([0, width]).nice();
	var y = d3.scale.linear().range([height, 0]).nice();

	/*var type = "layout_fa";
	var type_x = "layout_fa_x";
	var type_y = "layout_fa_y";
	var previous_type = "layout_fa";*/
	
	var type = "layout_tsne_text";
	var type_x = "layout_tsne_text_x";
	var type_y = "layout_tsne_text_y";
	var previous_type = "layout_tsne_text";
	
	var cluster_level = 2; // the deault level - the top clustering level
	var previous_cluster_level = 2;
	var cluster_highlight = "normal"; // whether clustering patterns should be highlighted by aggregation
	var cluster_mode = "original" // implement clustering based on the original high-dimensional data or 2D data produced by t-SNE
	
	var relatedType = ["References", "Citations"];
	
	/*var mycolor = [
		{"color": "#0059b3", "border": "#003366", "text": "InfoVis"},
		{"color": "#cc33ff", "border": "#cc33ff", "text": "VAST"},
		{"color": "#00b300", "border": "#00b300", "text": "SciVis/Vis"}
		];*/
	var mycolor = [
		{"color": "#3366cc", "border": "#1f3d7a", "text": "General"},
		{"color": "#33cc33", "border": "#1f7a1f", "text": "Highlight"}
		];
	// red, orange, yellow, green, auqa, blue, purple, pink, choclate, light-blue, grass-green, black, grey
	// red, orange, yellow, green, blue, purple, pink, choclate, light-blue, aqua, grass-green, black, grey
	var mycolor_category13 = ["hsl(12,100%,50%)", "hsl(24,100%,50%)", "hsl(60,100%,50%)", "hsl(120,60%,50%)", "hsl(240,100%,50%)", 
	"hsl(288,100%,50%)", "hsl(336,100%,50%)", "hsl(30,50%,50%)", "hsl(180,100%,50%)", "hsl(204,100%,50%)", "hsl(105,100%,50%)", "hsl(60,20%,50%)"
	];	
	var d3_category10_copy = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
	//var d3_category10_copy = ["rgb(31, 119, 180)", "rgb(255, 127, 14)", "rgb(44, 160, 44)", "rgb(214, 39, 40)", "rgb(148, 103, 189)", "rgb(140, 86, 75)", "rgb(227, 119, 194)", "rgb(127, 127, 127)", "rgb(188, 189, 34)", "rgb(23, 190, 207)"];
	var d3_category10_transparent = ["rgba(31, 119, 180, 0.3)", "rgba(255, 127, 14, 0.3)", "rgba(44, 160, 44, 0.3)", "rgba(214, 39, 40, 0.3)", "rgba(148, 103, 189, 0.3)", "rgba(140, 86, 75, 0.3)", "rgba(227, 119, 194, 0.3)", "rgba(127, 127, 127, 0.3)", "rgba(188, 189, 34, 0.3)", "rgba(23, 190, 207, 0.3)"];
	var cluster_color = d3_category10_copy;
	var cluster_color_transparent = d3_category10_transparent;
	
	var top_cluster_count = 10; // corresponding to the number of cluster colors on the top level
	var sub_cluster_count = 5; // corresponding to the number of luminance on the sub levels
	
	var showEdge = 0; // show edges or not, by default not
	var showHighlight = 0; // higlight the relevant article nodes or not
	var showReference = 0; // higlight the reference article (by user selection) nodes or not
	var citationSizePara = 0; // circle size is affected by the number of citations, e.g. #citation * citationSizePara
	
	var data; // global variable to record the current dataset
	var newData; // global variable to record the displayed data points, entire objects
	var currentData = []; // global variable to record the displayed data points, only ids
	var current_dot = -1; // currently selected article (index)
	var info; // global variable to record the clustering infomation of the current dataset
	
	var currentYears = []; // selected years (year flitering)
	var currentClusters = []; // selected clusters (cluster filtering)
	var checkedClusters = []; // for display - checked clusters (cluster filtering)
	
	// The basic size of document dots
	var circle_size_s = 4;
	var circle_size_m = 6;
	var circle_size_l = 8;
	
	// The aggregation rate of clusters
	var aggregate_rate_s = 0;
	var aggregate_rate_m = 0.5;
	var aggregate_rate_l = 1;
	
	var dataDirectory = "ADHD"; // the default dataset
	// load the default dataset
	loadData(dataDirectory);
	
	// Create the dropdown list for selecting a dataset
	var selectDataset = d3.select('#selectData')
	.append('select')
	.attr('class', 'selectDataset')
	.on('change', updateDataset);
	
	// for feature/dimension selection
	var currentDimension; // currently selected dimension
    var selectedDimensions = []; // the feature pool
	
	// Dataset options
	/*var datasets = ["ADHD", "ACEInhibitors", "Antihistamines", "AtypicalAntipsychotics", "BetaBlockers", "CalciumChannelBlockers", 
					"Estrogens", "NSAIDS", "Opioids", 
					"OralHypoglycemics", "ProtonPumpInhibitors", "SkeletalMuscleRelaxants", "Triptans", "UrinaryIncontinence"];*/
	var datasets = ["ADHD", "VisPubData", "VisPubData/win3", "VisPubData/win5", "VisPubData/win8", "VisPubData/win12", 
					"ACEInhibitors", "ACEInhibitors/win3", "ACEInhibitors/win5", "ACEInhibitors/win8",
					"Antihistamines", "AtypicalAntipsychotics", "BetaBlockers", "CalciumChannelBlockers", 
					"Estrogens", "NSAIDS", "Opioids", "OralHypoglycemics", "ProtonPumpInhibitors", "SkeletalMuscleRelaxants",
					"Statins", "Triptans", "UrinaryIncontinence"];				
	var datasetOptions = selectDataset
		.selectAll('option')
		.data(datasets).enter()
		.append('option')
		.text(function (d) { return d; });
	
	// Upon changing the dataset
	function updateDataset() {
		var value = d3.select('.selectDataset').property('value');
		dataDirectory = value;
		resetElements();
		loadData();
	}
	
	// Reset all elements when changing the dataset
	function resetElements(){
		// reset the drawing canvas
		d3.select("svg").remove();
		// reset the dropdown list of cluster selection
		d3.selectAll("li").remove();
		
		// reset the 2D layout
		//document.getElementById("layout_tsne_text").checked = true;
		type = "layout_tsne_text";
		type_x = "layout_tsne_text_x";
		type_y = "layout_tsne_text_y";
		previous_type = "layout_tsne_text";
		
		// reset the clustering level
		//document.getElementById("level2").checked = true;
		//cluster_level = 2; // the deault level - the top clustering level
		//previous_cluster_level = 2;
		
		// reset the cluster separation
		//document.getElementById("separate_normal").checked = true;
		//cluster_highlight = "normal";
		
		// reset edge showing
		//document.getElementById("showEdge").value = "Show Edges";
		//showEdge = 0; // show edges or not, by default not
		
		// reset show highlights of relevant article nodes
		document.getElementById("showHighlight").value = "Show Benchmark";
		showHighlight = 0; // higlight the relevant article nodes or not
		// reset to check all years
		d3.selectAll('.myCheckbox').property('checked', true);
		// reset to check all related publication types
		d3.selectAll(".relatedType").property('checked', true);
		// reset other global variables
		currentData = [];
		currentYears = []; // selected years (year flitering)
		currentClusters = []; // user explicitly selected clusters (cluster filtering)
		checkedClusters = []; // for display - checked clusters (cluster filtering)
	}
	
	// Load pre-calculated tSNE 2D positions
	// The array recorded in the file is obtained via the command copy(JSON.stringify(tsne_2D)) in the browser console - make the array a global variable first by right-click it in the browser console
	// https://remotexpert.net/2013/08/chrome-console-copy-json-array-or-object-as-string-to-clipboard/
	var tsne_2D_fix = [];
	d3.json("./DERP/" + dataDirectory + "/tsne2D.json", function(error, tsneArray) {
		tsneArray.forEach(function(d){
			var item = [];
			item.push(d[0]);
			item.push(d[1]);
			tsne_2D_fix.push(item);
		});
	});
	//console.log(tsne_2D_fix);
	
	// Load the selected dataset and initialize corresponding operations
	function loadData(){
	console.log(dataDirectory);
	d3.json("./DERP/" + dataDirectory + "/features.json", function(error, graph) {
		if(error) return console.error(error);
		data = graph.nodes;
		newData = data; // by default display all data dots
		//info = graph.clusters;
		
		data.forEach(function(d) {
			//d.year = +d.year;
			//d.index = +d.index;
			d.number_of_citations = +d.number_of_citations;
			/*d.title_x = +d.title_x;
			d.title_y = +d.title_y;
			d.abstract_x = +d.abstract_x;
			d.abstract_y = +d.abstract_y;
			d.keyword_x = +d.keyword_x;
			d.keyword_y = +d.keyword_y;
			d.term_x = +d.term_x;
			d.term_y = +d.term_y;
			d.author_x = +d.author_x;
			d.author_y = +d.author_y;
			d.pubtype_x = +d.pubtype_x;
			d.pubtype_y = +d.pubtype_y;
			d.combine_x = +d.combine_x;
			d.combine_y = +d.combine_y;
			d.layout_fr_x = +d.layout_fr_x;
			d.layout_fr_y = +d.layout_fr_y;
			d.layout_kk_x = +d.layout_kk_x;
			d.layout_kk_y = +d.layout_kk_y;
			d.layout_fa_x = +d.layout_fa_x;
			d.layout_fa_y = +d.layout_fa_y;*/
			d.layout_tsne_x = +d.layout_tsne_x;
			d.layout_tsne_y = +d.layout_tsne_y;
			/*d.layout_tsne_text_x = +d.layout_tsne_text_x;
			d.layout_tsne_text_y = +d.layout_tsne_text_y;
			d.layout_tsnePA_text_x = +d.layout_tsnePA_text_x;
			d.layout_tsnePA_text_y = +d.layout_tsnePA_text_y;
			d.layout_adjust_x = +d.layout_adjust_x;
			d.layout_adjust_y = +d.layout_adjust_y;
			d.layout_adjust2_x = +d.layout_adjust2_x;
			d.layout_adjust2_y = +d.layout_adjust2_y;
			d.layout_lgl_x = +d.layout_lgl_x;
			d.layout_lgl_y = +d.layout_lgl_y;
			d.cluster = +d.cluster;
			//d.cluster = +d.clusters[0];*/
			//d["dynamic_tsne_x"] = d.layout_tsne_x;
			//d["dynamic_tsne_y"] = d.layout_tsne_y;
			currentData.push(d.id);
		});
		
		// Set the default value of currentYears and currentClusters (select all)
		for(i = 1990; i <= 2017; i++){
			currentYears.push(i.toString());
		}
		//currentClusters = info["community_map_level" + cluster_level];
		//checkedClusters = info["community_map_level" + cluster_level];

		var xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });

		x.domain([xMin, xMax]);
		y.domain([yMin, yMax]);

		var xAxis = d3.svg.axis()
			.scale(x)
			.orient("bottom")
			.tickSize(-height);

		var yAxis = d3.svg.axis()
			.scale(y)
			.orient("left")
			.tickSize(-width);
		
		// dynamic text box to show the article profile
		var tip = d3.tip()
			.attr("class", "d3-tip")
			.offset([-10, 0])
			.html(function(d) {
				//return "<a href='https://www.ncbi.nlm.nih.gov/pubmed/" + d.id + "' target='_blank'><b>Link to PubMed</b></a><br>"
				return  "<b>Document ID: " + d.index + "</b><br>"
					+ "<b>PMID:</b> " + d.id + " (" + d.year + ")" + "<br>" 
					+ "<b>Title</b>: " + d.title_raw + "<br>" 
					+ "<b>Author Provided Keywords</b>: " + d.keyword_display.substring(0, d.keyword_display.length-2) + "<br>" 
					+ "<b>Machine Extracted Keywords</b>: " + d.keyword_rake.substring(0, d.keyword_rake.length-2) + "<br>"
					+ "<b>Topic Modeling (NMF)</b>: " + d.topic_nmf;
			});
		
		// dynamic text box to show the topic of a mouse-overe article's cluster
		// update 2018/02/19, dynamic keywords calculated for dynamic kmeans clusters
		var tip_cluster = d3.tip()
			.attr("class", "d3-tip")
			.offset([-10, 0])
			.html(function(d) {
				/*
				//return "LDA Topic: " + d.topic_lda + "<br>" + "NMF Topic: " + d.topic_nmf;
				mark = "";
				if(type == "layout_tsne") mark = "2";
				if(type == "layout_tsne_text") mark = "3";
				if(type == "layout_tsnePA_text") mark = "4";
				//return "RAKE Key Phrases for the cluster: <br>" + info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				//return info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				return info["cluster_abstract_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				*/
				if(assignments.length == 0) return;
				return cluster_keywords[assignments[d.index]];
			});
		
		// Update 2018/09
		// Click and select dimension (PC)
		var tip_dim = d3.tip()
  			.attr('class', 'd3-tip2')
  			.offset([0, 0])
  			.html(function(d) {
   				//return "<b>" + d + "</b><br>"
   				//return "<button class='searchButton_plain' onclick='checkDimension_pc();'>Check</button></br>"
   				//console.log("select " + d);
   				if(!selectedDimensions.includes(d)) return "<button class='searchButton_plain' onclick='selectDimension_pc();'>Select</button>";
   				else return "<button class='searchButton_plain' onclick='unselectDimension_pc();'>Unselect</button>";
  			});		
  		// Click and select dimension (heatmap)
		var tip_dim2 = d3.tip()
  			.attr('class', 'd3-tip3')
  			.offset([0, 0])
  			.html(function(d) {
   				//return "<b>" + d + "</b><br>"
   				//return "<button class='searchButton_plain' onclick='checkDimension_pc();'>Check</button></br>"
   				//console.log("select " + d);
   				if(!selectedDimensions.includes(d)) return "<button class='searchButton_plain' onclick='selectDimension_pc();'>Select</button>";
   				else return "<button class='searchButton_plain' onclick='unselectDimension_pc();'>Unselect</button>";
  			});			
		
		var zoomBeh = d3.behavior.zoom()
			.x(x)
			.y(y)
			.scaleExtent([0, 1500]) 
			.on("zoom", zoom);

		var svg = d3.select("#scatter")
			.append("svg")
			.attr("width", outerWidth)
			.attr("height", outerHeight)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
			.call(zoomBeh);
			
		var zoomBehavior = d3.behavior.zoom().on("zoom", function () {
               svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
			   hideHull();
			   tip_cluster.hide();
			   tip.hide();
            });	
		//svg.call(zoomBehavior);	

		svg.call(tip);
		svg.call(tip_cluster);
		svg.append("rect")
			.attr("class", "rect_main")
			.attr("width", width)
			.attr("height", height);

		/*svg.append("g")
			.classed("x axis", true)
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis)
			.append("text")
			.classed("label", true)
			.attr("x", width)
			.attr("y", margin.bottom - 10)
			.style("text-anchor", "end");
			//.text("X");

		svg.append("g")
			.classed("y axis", true)
			.call(yAxis)
			.append("text")
			.classed("label", true)
			.attr("transform", "rotate(-90)")
			.attr("y", -margin.left)
			.attr("dy", ".71em")
			.style("text-anchor", "end");
			//.text("Y");*/

		var objects = svg.append("svg")
			.classed("objects", true)
			.attr("width", width)
			.attr("height", height);

		objects.append("svg:line")
			.classed("axisLine hAxisLine", true)
			.attr("x1", 0)
			.attr("y1", 0)
			.attr("x2", width)
			.attr("y2", 0)
			.attr("transform", "translate(0," + height + ")");
		
		objects.append("svg:line")
			.classed("axisLine hAxisLine", true)
			.attr("x1", 0)
			.attr("y1", -height)
			.attr("x2", width)
			.attr("y2", -height)
			.attr("transform", "translate(0," + height + ")");	

		objects.append("svg:line")
			.classed("axisLine vAxisLine", true)
			.attr("x1", 0)
			.attr("y1", 0)
			.attr("x2", 0)
			.attr("y2", height);
			
		objects.append("svg:line")
			.classed("axisLine vAxisLine", true)
			.attr("x1", width)
			.attr("y1", 0)
			.attr("x2", width)
			.attr("y2", height);	
		
		// Set the group of elements upon click
		var mouseG = svg.append("g")
		
		// Record the selected (clicked) dot
		current_dot = -1;
		
		// Create the dots!
		objects.selectAll(".dot")
			.data(data)
			.enter()
			.append("circle")
			.classed("dot", true)
			.attr("r", function (d) { 
				basic_size = circle_size_s;
				if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
				return d.number_of_citations * citationSizePara + basic_size; 
			})
			.style("fill", function(d){
				/*if(false){
					return colorTextureScale(d.clusters[cluster_level]%top_cluster_count)("Y").url();
				}
				else return ColorLuminance(cluster_color[d.clusters[cluster_level]%top_cluster_count], 0);*/
				return cluster_color[0];
			})
			.style("fill-opacity", 0.9)
			//.attr("stroke-width", 1)
			.attr("stroke-width", function(d){
				if(showHighlight == 1 && d.if_highlight == "1") return 3;
				return 1; 
				})
			//.attr("stroke", "grey")
			.attr("stroke", function (d){ 
				//if(d.if_highlight == "1") return mycolor[1].border;
				//else return mycolor[0].border;
				return "black";
			})
			.attr("transform", transform)
			.on("mouseover", function(d) {
				if(assignments.length == 0) return 0;
				showHull(d);
				/*
				updateKeywords(d.keywords);
				
				current_community = 0;
				if(type == "layout_tsne"){
					current_community = d.clusters2[cluster_level];
				}
				else if(type == "layout_tsne_text"){
					current_community = d.clusters3[cluster_level];
				}
				else if(type == "layout_tsnePA_text"){
					current_community = d.clusters4[cluster_level];
				}
				else{
					current_community = d.clusters[cluster_level];
				}
				mark = "";
				if(type == "layout_tsne") mark = "2";
				if(type == "layout_tsne_text") mark = "3";
				if(type == "layout_tsnePA_text") mark = "4";
				top_community = info["community_map" + mark + "_level" + cluster_level][current_community];
				color = cluster_color_transparent[top_community%top_cluster_count];
				//cluster_keywords = "RAKE Key Phrases for the cluster: <br>" + info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				//cluster_keywords = info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				cluster_keywords = info["cluster_abstract_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				*/
				var keyword = "<b>Cluster " + assignments[d.index] + "</b>" 
						+ " (size: " + cluster_size[assignments[d.index]] + ")<br>"
						+ "Topics: " + cluster_keywords_highlight[assignments[d.index]];
				//consolelog(keyword);
				var color = cluster_color_transparent[assignments[d.index] % 10];
				updateClusterKeywords(keyword, color);
				//console.log(d.clusters[2]);
			})
			.on("mouseout", function(d) {
				//tip.hide(d);
				resetKeywords();
				//resetClusterKeywords();
			})
			.on("click", function(d){
				objects.selectAll(".dot")
					//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
					.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
					})
					.style("fill-opacity", 0.5) // was 0.15
					.attr("stroke-width", 0)
					.attr("stroke", function (d){ 
						//if(d.if_highlight == "1") return mycolor[1].border;
						//else return mycolor[0].border;
						return "black";
					});
				//tip_cluster.hide(d);	
				tip.show(d);
				if(relatedType.indexOf("References") != -1){
					d3.selectAll(".dot")
						.filter(function(a){ return d.references.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						//.attr("stroke", "yellow")
						//.style("fill", "yellow")
						.style("fill-opacity", 0.9)
						.moveToFront();
				}
				if(relatedType.indexOf("Citations") != -1){
					d3.selectAll(".dot")
						.filter(function(a){ return d.citations.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						//.attr("stroke", "red")
						//.style("fill", "red")
						.style("fill-opacity", 0.9)
						.moveToFront();
				}
				d3.select(this)
					//.attr("r", 10)
					.attr("stroke-width", 1.5)
					//.attr("stroke", "blue")
					.style("fill-opacity", 1)
					//.style("box-shadow", "10px 10px #888")
					//.style("filter", "url(#drop-shadow)")
					.moveToFront();
				current_dot = d.index;
				showHeatMap_single();
			});
		
		// Create the dropdown list for cluster selection/filtering
		// Selection of multiple clusters
		/*
		var selectCluster = d3.select('#clusterOptions');
		
		var ClusterOptionData = [];
		//ClusterOptionData.push("All");
		ClusterOptionData.push.apply(ClusterOptionData, info["community_map_level" + cluster_level]);
		
		var options = selectCluster
		.selectAll("li")
		.data(ClusterOptionData).enter()
		.append("li")
		.attr("class", "li_cluster")
		.append("label")
			.attr("id", function(d) { return d; })
			.text(function (d) { return "Cluster " + d; })
			.style("background-color", function(d){
				return ColorLuminance(cluster_color[d%top_cluster_count], 0);
			})
		.append("input")
			.attr("type", "checkbox")
			.attr("checked", true)
			.attr("value", function (d) { return d; })
			.attr("id", function(d) { return d; })
			.attr("class", "myCheckbox_cluster");
		
		// Filter clusters based on the selection on checkboxes
		d3.selectAll('#clusterFilter').on('click', updateCluster);
		function updateCluster(){
			var choices = [];
			d3.selectAll(".myCheckbox_cluster").each(function(d){
				cb = d3.select(this);
				if(cb.property("checked")){
					choices.push(parseInt(cb.property("value")));
				}
			});
			currentClusters = choices;
			checkedClusters = choices;
			previous_cluster_level = cluster_level; // record the cluster level where the cluster selection/filtering was applied
			previous_type = type; // record the layout where the cluster selection/filtering was applied
			//console.log(choices);
			
			//newData = data.filter(function(d){ return choices.indexOf(d.clusters[cluster_level]) != -1 && currentYears.indexOf(d.year) != -1; });
			if(type == "layout_tsne"){
				newData = data.filter(function(d){ return choices.indexOf(d.clusters2[cluster_level]) != -1 && currentYears.indexOf(d.year) != -1; });
			}
			else if(type == "layout_tsne_text"){
				newData = data.filter(function(d){ return choices.indexOf(d.clusters3[cluster_level]) != -1 && currentYears.indexOf(d.year) != -1; });
			}
			else if(type == "layout_tsnePA_text"){
				newData = data.filter(function(d){ return choices.indexOf(d.clusters4[cluster_level]) != -1 && currentYears.indexOf(d.year) != -1; });
			}
			else{
				newData = data.filter(function(d){ return choices.indexOf(d.clusters[cluster_level]) != -1 && currentYears.indexOf(d.year) != -1; });
			}
			// global variable to record the displayed data points
			currentData = [];
			newData.forEach(function(d) {
				currentData.push(d.id);
			});
			updateNode();
			updateEdge();
		}
		*/
		
		// Select all clusters
		/*
		d3.select("#clusterAll").on("click", clusterAll);
		function clusterAll() {
			d3.selectAll('.myCheckbox_cluster').property('checked', true);
			updateCluster();
		}
		
		// Clear clusters
		d3.select("#clusterClear").on("click", clusterClear);
		function clusterClear() {
			d3.selectAll('.myCheckbox_cluster').property('checked', false);
			updateCluster();
			if(showEdge == 1){
				objects.selectAll(".links").remove();
			}
		}
		*/
		
		function zoom() {
			svg.select(".x.axis").call(xAxis);
			svg.select(".y.axis").call(yAxis);
			svg.selectAll(".dot")
			.attr("transform", transform);
			svg.selectAll(".links")
			.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
			hideHull();
			tip_cluster.hide();
			tip.hide();
			
			// A slow edge adding method
			/*svg.selectAll(".links")
			.attr("x1", function(e){
				//console.log(e);
				var pos;
				data.forEach(function(n){
					if(e.source == n.id){
						pos = x(n[type_x]);
					}	
				})
				return pos;
			})
			.attr("y1", function(e){
				//console.log(e);
				var pos;
				data.forEach(function(n){
					if(e.source == n.id){
						pos = y(n[type_y]);
					}	
				})
				return pos;
			})
			.attr("x2", function(e){
				//console.log(e);
				var pos;
				data.forEach(function(n){
					if(e.target == n.id){
						pos = x(n[type_x]);
					}	
				})
				return pos;
			})
			.attr("y2", function(e){
				//console.log(e);
				var pos;
				data.forEach(function(n){
					if(e.target == n.id){
						pos = y(n[type_y]);
					}	
				})
				return pos;
			});*/
		}

		function transform(d) {
			return "translate(" + x(d[type_x]) + "," + y(d[type_y]) + ")";
		}
		
		// Reset to apply all dimensions (document map and clustering) with all default settings
		d3.select("#ResetMap").on("click", resetMap);
		function resetMap(){
			//console.log("reset");
			d3.select("#articleProfile").selectAll("*").remove();
			d3.select("#vectorExplore0").select("svg").remove();
			d3.select("#vectorExplore6").select("svg").remove();
			d3.select("#vectorExplore6").select(".vectorExplore6_info").remove();
			d3.select("#vectorExplore6").select(".parcoords").remove();
			d3.select("#vectorExplore6").select(".selectDimensionAll_pc").remove();
			d3.select("#vectorExplore7").select("svg").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_mul").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_pair").remove();
			d3.select("#vectorExplore8").select("svg").remove();
			d3.select("#vectorExplore8").select(".selectDimensionCluster").remove();
			d3.select("#vectorExplore8").select(".selectDimensionAll_cor").remove();
			setDimensionsAll();
			runHC();
			tip.hide();
		}
		
		// Reset the document to the original styles/attributes
		d3.select("#ResetColor").on("click", resetColor);
		function resetColor(){
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
					basic_size = circle_size_s;
					if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
					return d.number_of_citations * citationSizePara + basic_size; 
				})
				.style("fill", function (d){ 
					if(assignments.length == 0) return cluster_color[0];
					return cluster_color[assignments[d.index] % 10];
				})
				.style("fill-opacity", 0.9)
				//.attr("stroke-width", 1)
				.attr("stroke-width", function(d){
					if(showHighlight == 1 && d.if_highlight == "1") return 3;
					return 1; 
				})
				.attr("stroke", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				});
			//current_dot = -1;
			tip.hide();
			//objects.selectAll(".links").remove();
			//showEdge = 0;
			//document.getElementById("showEdge").value = "Show Edges";
		}
		
		// Reset the document to the original styles/attributes (except the coloring scheme)
		function change() {
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
					basic_size = circle_size_s;
					if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
					return d.number_of_citations * citationSizePara + basic_size; 
				})
				.style("fill-opacity", 0.9)
				//.attr("stroke-width", 1)
				.attr("stroke-width", function(d){
					if(showHighlight == 1 && d.if_highlight == "1") return 3;
					return 1; 
				})
				.attr("stroke", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				});
			//current_dot = -1;
			tip.hide();
			//objects.selectAll(".links").remove();
			//showEdge = 0;
			//document.getElementById("showEdge").value = "Show Edges";
		}
		// click blank space for reset, realized with jquery
		//$("#scatter").on('click', function(e){
		//	if($(e.target).closest('.dot').length > 0) return;
		//	//alert('no dot clicked!');
		//	change();
		//}); 
		
		// Show Edges/*
		/*
		d3.select("#showEdge").on("click", showEdge);
		function showEdge() {
			if(showEdge == 1){
				objects.selectAll(".links").remove();
				showEdge = 0;
				document.getElementById("showEdge").value = "Show Edges";				
				return;
			}
			var current_links = graph.links.filter(function(d){
				return (currentData.indexOf(d.source) != -1) && (currentData.indexOf(d.target) != -1); 
			});
			
			//Reset the dots (so dots and newly added edges will have consistent zoom)
			updateNode();
			// Append edges
			objects.append("g")
				//.attr("class", "links")
				.selectAll(".links")
				.data(current_links)
				.enter()
				.append("line")
				.classed("links", true)
				.attr("stroke-width", function(d) { return Math.sqrt(d.value); })
				.attr("x1", function(d){
					var pos;
					data.forEach(function(n){
						if(d.source == n.id){
							pos = x(n[type_x]);
						}	
					})
					return pos;
				})
				.attr("y1", function(d){
					var pos;
					data.forEach(function(n){
						if(d.source == n.id){
							pos = y(n[type_y]);
						}	
					})
					return pos;
				})
				.attr("x2", function(d){
					var pos;
					data.forEach(function(n){
						if(d.target == n.id){
							pos = x(n[type_x]);
						}	
					})
					return pos;
				})
				.attr("y2", function(d){
					var pos;
					data.forEach(function(n){
						if(d.target == n.id){
							pos = y(n[type_y]);
						}	
					})
					return pos;
				});
			d3.selectAll(".dot").moveToFront();	
			showEdge = 1;
			document.getElementById("showEdge").value = "Hide Edges";	
		}
		*/
		
		// Update edge placements if showEdge == 1, mainly applied when changing the selection of years
		/*
		function updateEdge(){
			if(showEdge == 1){
				var current_links = graph.links.filter(function(d){
					return (currentData.indexOf(d.source) != -1) && (currentData.indexOf(d.target) != -1); 
				});
				objects.selectAll(".links").remove();
				objects.append("g")
					//.attr("class", "links")
					.selectAll(".links")
					.data(current_links)
					//.data(graph.links)
					.enter()
					.append("line")
					.classed("links", true)
					.attr("stroke-width", function(d) { return Math.sqrt(d.value); })
					.attr("x1", function(d){
						var pos;
						data.forEach(function(n){
							if(d.source == n.id){
								pos = x(n[type_x]);
							}	
						})
						return pos;
					})
					.attr("y1", function(d){
						var pos;
						data.forEach(function(n){
							if(d.source == n.id){
								pos = y(n[type_y]);
							}	
						})
						return pos;
					})
					.attr("x2", function(d){
						var pos;
						data.forEach(function(n){
							if(d.target == n.id){
								pos = x(n[type_x]);
							}	
						})
						return pos;
					})
					.attr("y2", function(d){
						var pos;
						data.forEach(function(n){
							if(d.target == n.id){
								pos = y(n[type_y]);
							}	
						})
						return pos;
					});
				d3.selectAll(".dot").moveToFront();	
			}
		}
		*/
		
		// Show the higlight of relevant article nodes
		d3.select("#showHighlight").on("click", showHighlight_func);
		function showHighlight_func() {
			if(showHighlight == 0){
				showHighlight = 1;
				document.getElementById("showHighlight").value = "Hide Benchmark";		
			}
			else{
				showHighlight = 0;
				document.getElementById("showHighlight").value = "Show Benchmark";
			}
			//updateNode();
			//updateEdge();
			objects.selectAll(".dot")
			.attr("r", function (d) { 
				//console.log("here");
				basic_size = circle_size_s;
				if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
				return d.number_of_citations * citationSizePara + basic_size; 
			})
			.attr("stroke-width", function(d){
				if(showHighlight == 1 && d.if_highlight == "1") {
					return 3;
				}
				else{
					//console.log(d3.select(this).attr("stroke-width"));
					//return d3.select(this).attr("stroke-width");
					return 1;
				}	
			})
			.attr("stroke", function (d){ 
				//if(d.if_highlight == "1") return mycolor[1].border;
				//else return mycolor[0].border;
				return "black";
			});
		}
		
		// Show the higlight of relevant article nodes
		d3.select("#showReference").on("click", showReferencet_func);
		function showReferencet_func() {
			var indexes = articlesReference;
			var findResult = 0;
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
				})
				//.style("fill", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].color;
					//else return mycolor[0].color;
					//return cluster_color(d.cluster);
				//})
				.attr("stroke", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				})
				.style("fill-opacity", function(d){
					if(indexes.indexOf(d.index) != -1){
						findResult = 1;
						d3.select(this).moveToFront();
						return 1;
					}
					else return 0.15;
				})
				.attr("stroke-width", function(d){
					if(indexes.indexOf(d.index) != -1){
						findResult = 1;
						return 1.5;
					}
					else return 0;
				});	
			if(findResult == 0){
				objects.selectAll(".dot")
				.style("fill-opacity", 0.5)
				.attr("stroke-width", 1);
			}
			//console.log(findResult);
		}
		
		// Include the next year
		d3.select("#SelectNext").on("click", selectNext);
		function selectNext() {
			var checked = 1989;
			d3.selectAll(".myCheckbox").each(function(d){
				cb = d3.select(this);
				if(cb.property("checked")){
					checked = parseInt(cb.property("value"));
				}
			});
			d3.selectAll(".myCheckbox").each(function(d){
				cb = d3.select(this);
				if(parseInt(cb.property("value")) == checked + 1 && !cb.property("checked")){
					cb.property('checked', true);
					//console.log(cb.property("value"));
				}
			});
			updateYear();
		}
		
		// Select all years
		d3.select("#SelectAll").on("click", selectAll);
		function selectAll() {
			d3.selectAll('.myCheckbox').property('checked', true);
			updateYear();
		}
		
		// Clear years
		d3.select("#Clear").on("click", clear);
		function clear() {
			d3.selectAll('.myCheckbox').property('checked', false);
			updateYear();
			if(showEdge == 1){
				objects.selectAll(".links").remove();
			}
		}
		
		// Update years -> update the displayed nodes and edges
		d3.selectAll(".myCheckbox").on("change", updateYear);
		function updateYear() {
			var choices = [];
			d3.selectAll(".myCheckbox").each(function(d){
				cb = d3.select(this);
				if(cb.property("checked")){
					choices.push(cb.property("value"));
				}
			});
			//console.log(choices);
			currentYears = choices;
			//newData = data.filter(function(d){ return choices.indexOf(d.year) != -1 && currentClusters.indexOf(d.clusters[previous_cluster_level]) != -1; });
			if(type == "layout_tsne"){
				newData = data.filter(function(d){ return choices.indexOf(d.year) != -1 && currentClusters.indexOf(d.clusters2[previous_cluster_level]) != -1; });
			}
			else if(type == "layout_tsne_text"){
				newData = data.filter(function(d){ return choices.indexOf(d.year) != -1 && currentClusters.indexOf(d.clusters3[previous_cluster_level]) != -1; });
			}
			else if(type == "layout_tsnePA_text"){
				newData = data.filter(function(d){ return choices.indexOf(d.year) != -1 && currentClusters.indexOf(d.clusters4[previous_cluster_level]) != -1; });
			}
			else{
				newData = data.filter(function(d){ return choices.indexOf(d.year) != -1 && currentClusters.indexOf(d.clusters[previous_cluster_level]) != -1; });
			}
			
			// global variable to record the displayed data points
			currentData = [];
			newData.forEach(function(d) {
				currentData.push(d.id);
			});
			updateNode();
			updateEdge();
		}
		 
		// Update (reset) nodes to the initiall (non-zoom) positions, and display nodes based on the selection of years and clusters (newData)
		function updateNode(){
			objects.selectAll(".dot").remove();
			
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects.selectAll(".dot")
			.data(newData)
			.enter()
			.append("circle")
			.classed("dot", true)
			//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
			.attr("r", function (d) { 
				basic_size = circle_size_s;
				if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
				return d.number_of_citations * citationSizePara + basic_size; 
			})
			.style("fill", function (d){ 
				//if(d.if_highlight == "1") return mycolor[1].color;
				//else return mycolor[0].color;
				//return cluster_color(d.cluster);
				/*
				current_community = 0;
				if(type == "layout_tsne"){
					current_community = d.clusters2[cluster_level];
				}
				else if(type == "layout_tsne_text"){
					current_community = d.clusters3[cluster_level];
				}
				else if(type == "layout_tsnePA_text"){
					current_community = d.clusters4[cluster_level];
				}
				else{
					current_community = d.clusters[cluster_level];
				}
				mark = "";
				if(type == "layout_tsne") mark = "2";
				if(type == "layout_tsne_text") mark = "3";
				if(type == "layout_tsnePA_text") mark = "4";
				top_community = info["community_map" + mark + "_level" + cluster_level][current_community];
				subid = info["community_subid" + mark + "_level" + cluster_level][current_community];
				//return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
				if(false){
				//if(showHighlight == 1 && d.if_highlight == "1"){
					return colorTextureScale(top_community%top_cluster_count)("Y").url();
				}
				else return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
				*/
				
				if(assignments.length == 0) return cluster_color[0];
				return cluster_color[assignments[d.index] % 10];
			})
			.style("fill-opacity", 0.9)
			//.attr("stroke-width", 1)
			.attr("stroke-width", function(d){
					if(showHighlight == 1 && d.if_highlight == "1") return 3;
					return 1; 
				})
			.attr("stroke", function (d){ 
				//if(d.if_highlight == "1") return mycolor[1].border;
				//else return mycolor[0].border;
				return "black";
			})
			.attr("transform", transform)
			/*.on("mouseover", function(d) {
				showHull(d);
				tip.show(d);
				updateKeywords(d.keywords);
				//console.log(d.keywords);
			})
			.on("mouseout", function(d) {
				tip.hide(d);
				resetKeywords();
			})*/
			.on("mouseover", function(d) {
				showHull(d);
				//tip.show(d);
				//if(current_dot == -1) tip_cluster.show(d);
				
				/*
				updateKeywords(d.keywords);
				current_community = 0;
				if(type == "layout_tsne"){
					current_community = d.clusters2[cluster_level];
				}
				else if(type == "layout_tsne_text"){
					current_community = d.clusters3[cluster_level];
				}
				else if(type == "layout_tsnePA_text"){
					current_community = d.clusters4[cluster_level];
				}
				else{
					current_community = d.clusters[cluster_level];
				}
				mark = "";
				if(type == "layout_tsne") mark = "2";
				if(type == "layout_tsne_text") mark = "3";
				if(type == "layout_tsnePA_text") mark = "4";
				top_community = info["community_map" + mark + "_level" + cluster_level][current_community];
				color = cluster_color_transparent[top_community%top_cluster_count];
				//cluster_keywords = "RAKE Key Phrases for the cluster: <br>" + info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				//cluster_keywords = info["cluster_title_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				cluster_keywords = info["cluster_abstract_keywords" + mark][cluster_level][d["clusters" + mark][cluster_level]];
				*/
				if(assignments.length == 0) return;
				//var keyword = "Cluster " + assignments[d.index] + ":\n" + cluster_keywords[assignments[d.index]];
				var keyword = "<b>Cluster " + assignments[d.index] + "</b>" 
						+ " (size: " + cluster_size[assignments[d.index]] + ")<br>"
						+ "Topics: " + cluster_keywords_highlight[assignments[d.index]];
				//consolelog(keyword);
				var color = cluster_color_transparent[assignments[d.index] % 10];
				updateClusterKeywords(keyword, color);
			})
			.on("mouseout", function(d) {
				//tip.hide(d);
				resetKeywords();
			})
			.on("click", function(d){
				objects.selectAll(".dot")
					//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
					.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
					})
					//.style("fill", function (d){ 
						//if(d.if_highlight == "1") return mycolor[1].color;
						//else return mycolor[0].color;
						//return cluster_color(d.cluster);
					//})
					.style("fill-opacity", 0.5) // was 0.15
					.attr("stroke-width", 0)
					.attr("stroke", function (d){ 
						//if(d.if_highlight == "1") return mycolor[1].border;
						//else return mycolor[0].border;
						return "black";
					});
				//tip.show;
				//tip_cluster.hide(d);	
				tip.show(d);
				if(relatedType.indexOf("References") != -1){
					d3.selectAll(".dot")
						.filter(function(a){ return d.references.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						.style("fill-opacity", 0.9)
						.moveToFront();
				}
				if(relatedType.indexOf("Citations") != -1){				
					d3.selectAll(".dot")
						.filter(function(a){ return d.citations.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						.style("fill-opacity", 0.9)
						.moveToFront();	
				}	
				d3.select(this)
					//.attr("r", 10)
					.attr("stroke-width", 1.5)
					//.attr("stroke", "blue")
					.style("fill-opacity", 1)
					.moveToFront();	
				current_dot = d.index;
				showHeatMap_single();
			});
		}
		
		// Change the mode of related publications
		d3.selectAll(".relatedType").on("change", updateRelated);
		function updateRelated() {
			relatedType = [];
			d3.selectAll(".relatedType").each(function(d){
				cb = d3.select(this);
				if(cb.property("checked")){
					relatedType.push(cb.property("value"));
				}
			});
			if(current_dot >= 0){
				if(relatedType.indexOf("References") != -1){
					d3.selectAll(".dot")
						.filter(function(a){ return data[current_dot].references.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						.style("fill-opacity", 0.9)
						.moveToFront();
				}
				else{
					d3.selectAll(".dot")
						.filter(function(a){ return data[current_dot].references.indexOf(a.index) != -1; })
						.attr("stroke-width", 0)
						.style("fill-opacity", 0.15)
				}
				if(relatedType.indexOf("Citations") != -1){				
					d3.selectAll(".dot")
						.filter(function(a){ return data[current_dot].citations.indexOf(a.index) != -1; })
						.attr("stroke-width", 1)
						.style("fill-opacity", 0.9)
						.moveToFront();	
				}
				else{
					d3.selectAll(".dot")
						.filter(function(a){ return data[current_dot].citations.indexOf(a.index) != -1; })
						.attr("stroke-width", 0)
						.style("fill-opacity", 0.15)
				}
			}
		}
		
		// Change the 2D layout (type of display)
		d3.selectAll(".mode").on("change", updateMode);
		function updateMode() {
			//previous_type = type;
			var current_mode = "";
			d3.selectAll(".mode").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					current_mode = radio.property("value");
				}
			});
			type = current_mode;
			
			// change the positions as well
			if(cluster_highlight == "normal"){
				current_type = current_mode;
			}
			else{
				current_type = current_mode + "_" + cluster_highlight + "_level" + cluster_level;
			}
			
			type_x = current_type + "_x";
			type_y = current_type + "_y";
			//console.log(type_x);
			//console.log(type_y);
			
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.style("fill", function (d){ 
				return cluster_color[0];
			})
			.attr("transform", transform);
			
			// Update edge placements if showEdge == 1
			updateEdge();
			
			// Update the dropdown list of cluster checkboxs if t-SNE <-> force-directed, since they have different clustering methods
			//updateDropdown();
			// Show or update the heatmap of document vectors, which are only shown when the display type is layout_tsne_text pr layout_tsnePA_text
			showHeatMap();
			showHeatMap_single();
			showClusterSummary();
			showClusterCompare();
			vectorExplore();
		}
		
		// Change the clustering level (change colors)
		d3.selectAll(".level").on("change", updateLevel);
		function updateLevel() {
			d3.selectAll(".level").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					cluster_level = radio.property("value");
				}
			});
			//console.log(cluster_level);
			/*if(cluster_level == 2){
				cluster_color = d3.scale.category10();
			}
			else if(cluster_level == 1){
				cluster_color = d3.scale.category20();
			}*/
			objects.selectAll(".dot")
			.style("fill", function (d){ 
				//return cluster_color(d.clusters[cluster_level]);
				current_community = 0;
				if(type == "layout_tsne"){
					current_community = d.clusters2[cluster_level];
				}
				else if(type == "layout_tsne_text"){
					current_community = d.clusters3[cluster_level];
				}
				else if(type == "layout_tsnePA_text"){
					current_community = d.clusters4[cluster_level];
				}
				else{
					current_community = d.clusters[cluster_level];
				}
				mark = "";
				if(type == "layout_tsne") mark = "2";
				if(type == "layout_tsne_text") mark = "3";
				if(type == "layout_tsnePA_text") mark = "4";
				top_community = info["community_map" + mark + "_level" + cluster_level][current_community];
				subid = info["community_subid" + mark + "_level" + cluster_level][current_community];
				//return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
				if(false){
				//if(showHighlight == 1 && d.if_highlight == "1"){
					return colorTextureScale(top_community%top_cluster_count)("Y").url();
				}
				else return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
			});
			//.style("fill-opacity", 0.9)
			//.attr("stroke-width", 1)
			//.attr("stroke", function (d){ 
			//	return "black";
			//})
			
			// change the node positions as well
			var current_mode = "";
			if(cluster_highlight == "normal"){
				current_mode = type;
			}
			else{
				current_mode = type + "_" + cluster_highlight + "_level" + cluster_level;
			}
			type_x = current_mode + "_x";
			type_y = current_mode + "_y";
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.attr("transform", transform);
			
			// Update edge placements if showEdge == 1
			updateEdge();
			
			// update the dropdown list for cluster selection
			updateDropdown();
			
			// update the cluster summary and comparison if applicable
			showClusterSummary();
			showClusterCompare();
		}
		
		// Update the dropdown list of cluster selection
		function updateDropdown(){
			var mark = "";
			if(type == "layout_tsne") mark = "2";
			if(type == "layout_tsne_text") mark = "3";
			if(type == "layout_tsnePA_text") mark = "4";
			var previous_mark = "";
			if(previous_type == "layout_tsne") previous_mark = "2";
			if(previous_type == "layout_tsne_text") previous_mark = "3";
			if(previous_type == "layout_tsnePA_text") previous_mark = "4";
			
			//console.log("type: " + type);
			//console.log("previous_type: " + previous_type);
			//console.log("level: " + cluster_level);
			//console.log("previous_level: " + previous_cluster_level);
			//console.log("currentClusters: " + currentClusters);
			
			// In case force-directed <--> t-SNE, need to have additional mappings: all clusters that have at least one node belongs to the previously selected cluster will be automatically checked
			newClusters = [];
			if(mark != previous_mark){
				for(i = 0; i < data.length; i++){
					if(currentClusters.indexOf(data[i]["clusters" + previous_mark][previous_cluster_level]) != -1){ // identify nodes belong to previously selected clusters
						new_cluster = data[i]["clusters" + mark][cluster_level];
						if(newClusters.indexOf(new_cluster) == -1) newClusters.push(new_cluster);
					}
				}
			}
			//console.log("newClusters: " + newClusters);
			
			// Do the cluster dropdown list update, and automatically check mapped clusters
			ClusterOptionData = [];			
			if(cluster_level == 2){
				//ClusterOptionData.push("All");
				ClusterOptionData.push.apply(ClusterOptionData, info["community_map" + mark + "_level" + cluster_level]);
				selectCluster.selectAll("li").remove();
				selectCluster
				.selectAll("li")
				.data(ClusterOptionData).enter()
				.append("li")
				.attr("class", "li_cluster")
				.append("label")
					.attr("id", function(d) { return d; })
					.text(function (d) { return "Cluster " + d; })
					.style("background-color", function(d){
						return ColorLuminance(cluster_color[d%top_cluster_count], 0);
					})
				.append("input")
					.attr("type", "checkbox")
					//.attr("checked", true)
					.attr("checked", function(d){
						if(mark == previous_mark){ 
							if(previous_cluster_level == 2){ // level2 -> level2
								if(currentClusters.indexOf(d) != -1) return true;
								else return null;
							}
							else{ // level0 or level1 -> level2
								for(i = 0; i < currentClusters.length; i++){
									if(info["community_map" + mark + "_level" + previous_cluster_level][currentClusters[i]] == d) return true;
								}
								return null;
							}
						}
						else{ // the clustering mode is changed, levelx -> level2
							/*for(i = 0; i < newClusters.length; i++){
								if(info["community_map" + mark + "_level" + cluster_level][newClusters[i]] == d) return true;
							}
							return null;*/
							if(newClusters.indexOf(d) != -1) return true;
							else return null;
						}
					})
					.attr("value", function (d) { return d; })
					.attr("id", function(d) { return d; })
					.attr("class", "myCheckbox_cluster");
			}
			else{
				for(i = 0; i < info["community_map" + mark + "_level" + cluster_level].length; i++){
					top_community = info["community_map" + mark + "_level" + cluster_level][i];
					subid = info["community_subid" + mark + "_level" + cluster_level][i];
					var current_option = {id: i, name: top_community + "-" + subid, color: ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count))};
					ClusterOptionData.push(current_option);
				}
				ClusterOptionData.sort(compare);
				selectCluster.selectAll("li").remove();
				selectCluster
				.selectAll("li")
				.data(ClusterOptionData).enter()
				.append("li")
				.attr("class", "li_cluster")
				.append("label")
					.attr("id", function(d) { return d.id; })
					.text(function (d) { return "Cluster " + d.name; })
					.style("background-color", function(d){ return d.color; })
				.append("input")
					.attr("type", "checkbox")
					//.attr("checked", true)
					.attr("checked", function(d){
						if(mark == previous_mark){
							if(previous_cluster_level == cluster_level){ // same level
								if(currentClusters.indexOf(d.id) != -1) return true;
								else return null;
							}
							else if(previous_cluster_level == 2){ // level2 -> level0 or level1
								if(currentClusters.indexOf(info["community_map" + mark + "_level" + cluster_level][d.id]) != -1) return true;
								else return null;
							}
							else{ // level0 <-> level1
								// switch between level0 and level1, need to consider the mappings between these two levels
								for(i = 0; i < info["community_map" + mark].length; i++){
									var current_object = info["community_map" + mark][i];
									if(current_object["level" + cluster_level] == d.id && currentClusters.indexOf(current_object["level" + previous_cluster_level]) != -1){
										//console.log(current_object);
										return true;
									}
								}
								return null;
							}
						}
						else{ // the clustering mode is changed, levelx -> level0 or level1
							if(newClusters.indexOf(d.id) != -1) return true;
							else return null;
						}
					})
					.attr("value", function (d) { return d.id; })
					.attr("id", function(d) { return d.id; })
					.attr("class", "myCheckbox_cluster");
			}
		}
		
		// Change the highlight/separation mode of clusters (change positions)
		//d3.selectAll(".highlight").on("change", updateHighlight);
		/*function updateHighlight() {
			d3.selectAll(".highlight").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					cluster_highlight = radio.property("value");
				}
			});
			
			var current_mode = "";
			if(cluster_highlight == "normal"){
				current_mode = type;
			}
			else{
				current_mode = type + "_" + cluster_highlight + "_level" + cluster_level;
			}

			type_x = current_mode + "_x";
			type_y = current_mode + "_y";
			//console.log(type_x);
			//console.log(type_y);
			
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.attr("transform", transform);
			
			// Update edge placements if showEdge == 1
			updateEdge();
		}*/
		
		function updateKeywords(keywords){
			var text = "";
			if(keywords.length > 1){
				for (i = 0; i < keywords.length; i++){ 
					text += keywords[i];
					if(i != keywords.length - 1) text += "; ";
				}
			}
			else text = "N/A"
			//document.getElementById("nodeInfo").innerHTML = text;
		}
		function resetKeywords(){
			var text = "";
			//document.getElementById("nodeInfo").innerHTML = text;
		}
		
		function updateClusterKeywords(keywords, color){
			document.getElementById("clusterInfo").innerHTML = keywords;
			d3.select("#clusterInfoDiv")
			.style("color", color);
			d3.select("#clusterInfo")
			.style("background-color", color);
		}
		function resetClusterKeywords(){
			document.getElementById("clusterInfo").innerHTML = "";
		}
		
		// handle the Zoom buttons
		d3.selectAll('.zoomButton')
		.on('click', zoomClick);
		
		function interpolateZoom (translate, scale) {
			var self = this;
			return d3.transition().duration(350).tween("zoom", function () {
				var iTranslate = d3.interpolate(zoomBeh.translate(), translate),
					iScale = d3.interpolate(zoomBeh.scale(), scale);
				return function (t) {
					zoomBeh
						.scale(iScale(t))
						.translate(iTranslate(t));
					zoom();
				};
			});
		}
		
		function zoomClick() {
			//console.log(d3.event);
			var clicked = d3.event.target,
				direction = 1,
				factor = 0.2,
				target_zoom = 1,
				center = [width / 2, height / 2],
				extent = zoomBeh.scaleExtent([0, 1500]),
				translate = zoomBeh.translate(),
				translate0 = [],
				l = [],
				view = {x: translate[0], y: translate[1], k: zoomBeh.scale()};

			d3.event.preventDefault();
			direction = (this.id === 'zoom_in') ? 1 : -1;
			target_zoom = zoomBeh.scale() * (1 + factor * direction);

			if (target_zoom < extent[0] || target_zoom > extent[1]) { return false; }

			translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
			view.k = target_zoom;
			l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

			view.x += center[0] - l[0];
			view.y += center[1] - l[1];

			interpolateZoom([view.x, view.y], view.k);
		}
		
		// Search publication by DOI
		d3.selectAll('#searchByDOI').on('click', searchByDOI);
		function searchByDOI(){
			var value = document.getElementById("searchDOI").value;
			var findResult = 0;
			
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
				})
				//.style("fill", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].color;
					//else return mycolor[0].color;
					//return cluster_color(d.cluster);
				//})
				.attr("stroke", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				})
				.style("fill-opacity", function(d){
					if(d.id == value){
						findResult = 1;
						d3.select(this).moveToFront();
						return 1;
					}
					else return 0.15;
				})
				.attr("stroke-width", function(d){
					if(d.id == value){
						findResult = 1;
						return 1.5;
					}
					else return 0;
				});	
			if(findResult == 0){
				objects.selectAll(".dot")
				.style("fill-opacity", 0.5)
				.attr("stroke-width", 1);
			}
		}
		
		// Search publication by text matching
		d3.selectAll('#searchByText').on('click', searchByText);
		function searchByText(){
			var str = document.getElementById("searchText").value;
			str = str.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, " ");
			str = str.toLowerCase();
			var words = str.split(" ");
			var findResult = 0;
			var index = [];
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
				})
				//.style("fill", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].color;
					//else return mycolor[0].color;
					//return cluster_color(d.cluster);
				//})
				.attr("stroke", function (d){ 
					var flag = 1;
					for(var word of words){
						var word_stem = stemmer(word);
						//console.log(word + " - " + word_stem);
						if(!(d.title_all.includes(word_stem) || d.abstract_all.includes(word_stem) || d.title_raw.includes(word) || d.abstract_raw.includes(word))){
							flag = 0;
						}
					}
					if(flag == 1){
						index.push(d.index);
						//return "#cc0000";
					}
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				})
				.style("fill-opacity", function(d){
					if(index.indexOf(d.index) != -1){
						findResult = 1;
						d3.select(this).moveToFront();
						return 1;
					}
					else return 0.15;
				})
				.attr("stroke-width", function(d){
					if(index.indexOf(d.index) != -1){
						findResult = 1;
						return 1.5;
					}
					else return 0;
				});	
			if(findResult == 0){
				objects.selectAll(".dot")
				.style("fill-opacity", 0.5)
				.attr("stroke-width", 1);
			}	
		}
		
		// (Update 2018/02/25)
		// Search publication by index, a list of index can be provided and separated by comma or blank space
		d3.selectAll('#searchByIndex').on('click', searchByIndex);
		function searchByIndex(){
			var value = document.getElementById("searchIndex").value;
			var findResult = 0;
			
			// process the selected dimensions
			var indexes = [];
			if(value.includes("ref")) indexes = articlesReference;
			else{
				var indexes_raw;
				if (value.includes(",")){ // use "," as the delimiter
					indexes_raw = value.split(",");
				}
				else{
					indexes_raw = value.split(" "); // use " " as the delimite
				}
				for (var i = 0; i < indexes_raw.length; i++){
					var element = indexes_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
						&& indexes.indexOf(parseInt(element.trim())) == -1){
						indexes.push(parseInt(element.trim()));
					}
				}
			}
			//console.log(indexes);
			
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
				})
				//.style("fill", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].color;
					//else return mycolor[0].color;
					//return cluster_color(d.cluster);
				//})
				.attr("stroke", function (d){ 
					//if(d.if_highlight == "1") return mycolor[1].border;
					//else return mycolor[0].border;
					return "black";
				})
				.style("fill-opacity", function(d){
					if(indexes.indexOf(d.index) != -1){
						findResult = 1;
						d3.select(this).moveToFront();
						return 1;
					}
					else return 0.15;
				})
				.attr("stroke-width", function(d){
					if(indexes.indexOf(d.index) != -1){
						findResult = 1;
						return 1.5;
					}
					else return 0;
				});	
			if(findResult == 0){
				objects.selectAll(".dot")
				.style("fill-opacity", 0.5)
				.attr("stroke-width", 1);
			}
		}
		
		// (Update 2018/09/10)
		// Update the feature selection based on the "Dimension Selection" text area
		function updateFeatureSelection(){
			var selection = [];		
			var selection_str = document.getElementById("dimensions").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& selection.indexOf(parseInt(element.trim())) == -1){
					selection.push(parseInt(element.trim()));
				}
			}
			selectedDimensions = selection;
			//console.log(selectedDimensions);
		}
		// Update the PC/heatmap labels to reflect selected dimensions
		function reflectFeatureSelection(){
			d3.selectAll(".label")
    			.style("font-weight", function(n){
    				//console.log(n);
    				var value = parseInt(n.substring(1));
    				if(selectedDimensions.includes(value)){
    					//console.log(value);
    					return "bold";
    				}
    				else return "normal";
    			})
    			.style("fill", function(n){
    				//console.log(n);
    				var value = parseInt(n.substring(1));
    				if(selectedDimensions.includes(value)){
    					//console.log(value);
    					return "#008CBA";
    				}
    				else return "black";
    			});
    		d3.selectAll(".heatmap_label")
    			.style("font-weight", function(n){
    				//console.log(n);
    				var value = parseInt(n.dim);
    				if(selectedDimensions.includes(value)){
    					//console.log(value);
    					return "bold";
    				}
    				else return "normal";
    			})
    			.style("fill", function(n){
    				//console.log(n);
    				var value = parseInt(n.dim);
    				if(selectedDimensions.includes(value)){
    					//console.log(value);
    					return "#008CBA";
    				}
    				else return "black";
    			});
		}
		
		// Jquery click actions, including
		// click to update the feature selection
		// click blank space to hideHull and tips, reset a clicked node, realized with jquery
		//$("#scatter").on('click', function(e){
		$(document).on('click', function(e){
			// reflect the selected features/dimensions in bold labels (PC label, and heatmap label)
			updateFeatureSelection();
  			reflectFeatureSelection();
			/*if($(e.target).closest('.searchButton_plain').length > 0 || $(e.target).closest('.searchButton').length > 0
				|| $(e.target).closest('#dimensions').length > 0){
				reflectFeatureSelection();
    		}
    		reflectFeatureSelection();
    		// update the selected features/dimensions when modifying the "Dimension Selection" textarea.
    		if($(e.target).closest('#dimensions').length > 0){
    			updateFeatureSelection();
    		}*/
    		
    		//console.log($(e.target).closest('rect').length);				
			if($(e.target).closest('.dot').length > 0) return;
			if($(e.target).closest('.searchButton').length > 0) return;
			if($(e.target).closest('.checkButton').length > 0) return;
			if($(e.target).closest('.dimension').length > 0) return;
			if($(e.target).closest('.heatmap_label').length > 0) return;
			//if($(e.target).closest('rect').length > 0) return;
			hideHull(); // hide the cluster hull
			tip.hide(); // hide the article profile
			tip_cluster.hide(); // hide the cluster information
			tip_dim.hide(); // hide the dimension selection box (PC)
			tip_dim2.hide(); // hide the dimension selection box (heatmap)
			//resetClusterKeywords(); // reset the text box for cluster keywords
			
			//console.log($(e.target).closest('.cell').length);
			if($(e.target).closest('.cell').length > 0) return;
			if($(e.target).closest('line').length > 0) return;
			//console.log($(e.target).closest('#scatter').length);
			if($(e.target).closest('#scatter').length == 0) change(); // if clicking outside of the document map, reset the clicked node
		});
		
		// Jquery keyboard actions, including
		// modify the "Dimension Selection" text area to update the feature selection
		$("#dimensions").keypress(function() {
  			//console.log( "Handler for .keypress() called." );
  			updateFeatureSelection();
  			reflectFeatureSelection();
		});
		
		/*------------------------*/
		// (Update 2017/12/20) 
		// ##### For a set of documents (e.g. highlighed documents), show their semantic representations (vectors) with a heatmap
		//showHeatMap();
		function showHeatMap(){
			d3.select("#heatmap").selectAll("*").remove();
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#heatmap").style("height", 0);
				return;
			}			
			
			var displayData = data.filter(function(d){ return d.if_highlight == "1";} ); // the documents whose vectors will be displayed as a heatmap
			var itemNumber = displayData.length;
			
			var itemDimension = 200;
      		var margin = {top: 0, right: 0, bottom: 10, left: 0};
      		var width = 1200;
      		var height = 30 * (itemNumber + 1);
      		var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;	
      		d3.select("#heatmap").style("height", Math.min(200, height));
      	
      		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
		
			var displayData_formated = []; // the postion and value of each heatmap-cell
			var max_value = 0;
			var min_value = 0;
			for(i = 0; i < itemNumber; i++){
				for(j = 0; j < displayData[i][vector_mark].length; j++){
					element = {};
					element["x"] = j;
					element["y"] = i;
					element["value"] = displayData[i][vector_mark][j];
					displayData_formated.push(element);
					
					if(element["value"] > max_value) max_value = element["value"];
					if(element["value"] < min_value) min_value = element["value"];
					
				}
			}
			//console.log(displayData_formated);
		
			var x_elements = d3.set(displayData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(displayData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (20+2)]);
        	
        	//var colorScale = d3.scale.threshold()
       	 	//	.domain([0, 1])
       		 //	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
       		 
       		 d3.select("#heatmap")
				.append("div")
				//.style("margin-left", 35)
				.html("<b>Semantic Vectors of Highlighted (Relevant) Articles:</b>");
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
		
			var heatmap_svg = d3.select("#heatmap")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g")
        		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(displayData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		.attr('height', function(d) { 
        			return (20 / (max_value - min_value)) * (d.value - min_value); 
        		})
        		.attr('y', function(d) { return yScale(d.y); })
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { return colorScale(d.value); });
        	}
        	     	
        // #####For a selected document, show its semantic representation (vector) with a heatmap (single row)
		function showHeatMap_single(){
			d3.select("#articleProfile").selectAll("*").remove();
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text" || current_dot == -1){
				d3.select("#articleProfile").style("height", 0);
				return;
			}
			var width = 1200;
			var height = 60;
      		//var height = 100 - margin.top - margin.bottom;
			var currentData = data.filter(function(d){ return d.index == current_dot;} ); // the documents whose vectors will be displayed as a heatmap
			var itemNumber = currentData.length;
			var itemDimension = 200;
			var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#articleProfile").style("height", height);
      	
      		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
		
			var currentData_formated = []; // the postion and value of each heatmap-cell
			var max_value = 0;
			var min_value = 0;
			for(i = 0; i < itemNumber; i++){
				for(j = 0; j < currentData[i][vector_mark].length; j++){
					element = {};
					element["x"] = j;
					element["y"] = i;
					element["value"] = currentData[i][vector_mark][j];
					currentData_formated.push(element);
					
					if(element["value"] > max_value) max_value = element["value"];
					if(element["value"] < min_value) min_value = element["value"];
				}
			}
			//console.log(displayData_formated);
		
			var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * itemSize]);
        	
        	//var colorScale = d3.scale.threshold()
       	 	//	.domain([0, 1])
       		 //	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);			
			
			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "<b>Dimension ID: </b>" + d.x
   						+"<br><b>Dimension Value: </b>" + d.value;
  					});
			
			d3.select("#articleProfile")
				.append("div")
				.html(function(){
					var str = "";
					str = "<b>Document ID: " + currentData[0].index + "</b> ----- "
					+ "<b>PMID:</b> " + currentData[0].id + " (" + currentData[0].year + ")     "
					+ "<a href='https://www.ncbi.nlm.nih.gov/pubmed/" + currentData[0].id + "' target='_blank'><b>Link to PubMed</b></a>"
					
					if(!articlesReference.includes(currentData[0].index))
						str += "&nbsp;&nbsp;&nbsp;<button id='selectReference' class='searchButton_plain2' onclick='selectReference();'>Select as a Reference Document</button>"
					else
						str += "&nbsp;&nbsp;&nbsp;<button id='selectReference' class='searchButton_plain2' onclick='selectReference();'>unSelect from Reference Documents</button>"
					
					str += "&nbsp;&nbsp;<button id='selectReference_reset' class='searchButton_plain2' onclick='selectReference_reset();'>Reset All Reference Documents</button>"
					str += "&nbsp;&nbsp;<button class='searchButton_plain2' onclick='clearArticleHeatmap();'>Close Profile</button><br>"
					str += "<b>Title:</b> " + currentData[0].title_raw + "<br>"
					//+ "<b>Semantic Vector:</b>");
					return str;
          		});

			var heatmap_svg = d3.select("#articleProfile")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g");
        		//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        	heatmap_svg.call(tip_articleVector);	
        
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(currentData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		//.attr('height', 20)
        		.attr('height', function(d) { 
        			return (20 / (max_value - min_value)) * (d.value - min_value); 
        		})
        		//.attr('y', function(d) { return yScale(d.y); })
        		.attr('y', function(d) { 
        			return yScale(d.y) + (20 - (20 / (max_value - min_value)) * (d.value - min_value)); 
        		})
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { return blue_to_red(d.value); })
        		.on('mouseover', function(d){
        			tip_articleVector.show(d);
        		})
      			.on('mouseout', function(d){
      				tip_articleVector.hide(d);
      			});
        	}
        	
        	// ###### Show cluster level information and summary - a window of abstracted cluster nodes, and cluster information per mouse-over
        	/*
        	var clusterVector = []; // global variable of the current cluster vector to be displayed
        	showClusterSummary();
        	function showClusterSummary(){
        		d3.select("#clusterSummary").selectAll("*").remove();
				if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
					d3.select("#clusterSummary").style("height", 0);
					return;
				}
        		var width = 400;
      			var height = 200;
      			//var margin = 30;
      			d3.select("#clusterSummary").style("height", 230);
      			d3.select("#clusterSummary")
					.append("div")
					.html("<b>Cluster Explorer and Summary</b>");
				
				var colorScale = d3.scale.threshold() // for silhouette coefficient
    				.domain([0, 0.1, 0.2, 0.3, 0.4])
    				.range(["#f2f2f2", "#d6f5d6", "#adebad", "#85e085", "#5cd65c", "#33cc33"]);
    				
    			var colorScale2 = d3.scale.threshold()
    				.domain([0.0001, 0.2, 0.4, 0.6, 0.8])
    				.range(["#f2f2f2", "#d6f5d6", "#adebad", "#85e085", "#5cd65c", "#33cc33"]);	
					
				var clusterColorMode = "0";		
				var colorMode = ["Cluster", "Internal Validity (Silhouette)", "External Validity (Gold-Standard Labels)"];
				var radioForm = d3.select("#clusterSummary").append("form").style("margin", 0);
				labels = radioForm.selectAll("label")
    				.data(colorMode)
   					.enter()
    				.append("label")
    				.text(function(d) {return d;})
    				.insert("input")
    				.attr({
        				type: "radio",
        				class: "clusterColorMode",
        				name: "mode",
        				value: function(d, i) {return i;}
    				})
    				.property("checked", function(d, i) {return i===0;})
    				.on("change", function(d) {
    					d3.selectAll(".clusterColorMode").each(function(d){
    						radio = d3.select(this);
    						if(radio.property("checked")){
    							clusterColorMode = radio.property("value");
    						}
    					});

    					clusters.selectAll("*").remove();
    					clusters.append('circle')
        					.classed("cluster_dot", true)
       						.attr("r", function (d) { 
								return 3 + d["size"]*0.15;
							})
							.style("fill", function(d) {
								if(clusterColorMode == "1"){
    								return colorScale(d["silhouette"]);	
								}
								if(clusterColorMode == "2"){
    								return colorScale2(d["highlight_recall"]);	
								}
								else{
									top_community = info["community_map" + mark + "_level" + cluster_level][d["id"]];
									subid = info["community_subid" + mark + "_level" + cluster_level][d["id"]];
									return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
								}
							})
							.style("fill-opacity", 0.7)
							.attr("stroke-width", 1)
							//.attr("transform", function(d) { return "translate(" + x(d["x"]) + "," + y(d["y"]) + ")";})
							.on("mouseover", function(d) {
								d3.selectAll(".clusterSummarySide").remove();
								clusterVector = [];
								showHeatMap_cluster();
								
								d3.select("#clusterSummary")
									.append("div")
									.attr("class", "clusterSummarySide")
									.html("<b>Cluster Summary Sidebar</b><br>"
										+"<b>Cluster ID:</b> " + d["id"] + "<br>"
										+"<b>Cluster Size:</b> " + d["size"] + "<br>"
										+"<b>Cluster Internal Validation (Silhouette Coefficient):</b> " + d["silhouette"] + "<br>"
										+"<b>Cluster External Validation (Highlighted/Relevant Articles):</b> Number=" + d["highlight_number"] + ", Recall="+ d["highlight_recall"] + ", Precision=" + d["highlight_precision"] + "<br>"
										+"<b>Averaged Cluster Semantic Vector:</b><br>");
								d3.select("#clusterSummarySide")
									.append("div")
									.attr("id", "clusterVector")
									.style("height", 0);
								clusterVector = d["vector"];	
								showHeatMap_cluster();
							});
					
						clusters
							.append("text")
							.attr("dx", function(d){return -0.2*(3+d["size"]*0.15);})
							.attr("dy", function(d){return 0.2*(3+d["size"]*0.15);})
							.text(function(d){return d["id"];});
					});
					
      			var mark = 0;
      			if(type == "layout_tsne_text") mark = "3";
      			else if (type == "layout_tsnePA_text") mark = "4";
      			else return;
      			
      			sourceData = info["cluster_center" + mark][cluster_level];
      			sourceData2 = info["cluster_size" + mark][cluster_level];
      			sourceData3 = info["cluster_vector" + mark][cluster_level];
      			sourceData4 = info["cluster_vector_active" + mark][cluster_level];
      			sourceData5 = info["cluster_silhouette" + mark][cluster_level];
      			sourceData6 = info["cluster_highlight_size" + mark][cluster_level];
      			clusterData = [];
      			for(i = 0; i < sourceData.length; i++){
      				element = {};
      				element["x"] = sourceData[i][0];
      				element["y"] = sourceData[i][1];
      				element["size"] = sourceData2[i];
      				element["vector"] = sourceData3[i];
      				element["vector_active"] = sourceData4[i];
      				element["silhouette"] = sourceData5[i]
      				element["highlight_number"] = sourceData6[i];
      				element["highlight_precision"] = sourceData6[i]/sourceData2[i];
      				element["highlight_recall"] = sourceData6[i]/info["number_highlight"];
      				element["id"] = i;
      				clusterData.push(element);
      			}
      			
      			var cluster_svg = d3.select("#clusterSummary")
					.append("svg")
        			.attr("width", width)
        			.attr("height", height)
        			.attr("class", "cluster_svg");
        			//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        		
        		var x = d3.scale.linear().range([0, width]).nice();
				var y = d3.scale.linear().range([height, 0]).nice();
				
        		var xMax = d3.max(clusterData, function(d) { return d["x"]; }) * 1.5,
					xMin = d3.min(clusterData, function(d) { return d["x"]; }) * 1.5,
					yMax = d3.max(clusterData, function(d) { return d["y"]; }) * 1.5,
					yMin = d3.min(clusterData, function(d) { return d["y"]; }) * 1.5;

				x.domain([xMin, xMax]);
				y.domain([yMin, yMax]);
				
        		var clusters = cluster_svg.selectAll('.cluster_dot')
       	 			.data(clusterData)
        			.enter()
        			.append("g")
        			.attr("transform", function(d) { return "translate(" + x(d["x"]) + "," + y(d["y"]) + ")";});
        			
        		clusters.append('circle')
        			.classed("cluster_dot", true)
       				.attr("r", function (d) { 
						return 3 + d["size"]*0.15;
					})
					.style("fill", function(d) {
						if(clusterColorMode == "1"){
    						return colorScale(d["silhouette"]);	
						}
						if(clusterColorMode == "2"){
    								return colorScale2(d["highlight_recall"]);	
						}
						else{
							top_community = info["community_map" + mark + "_level" + cluster_level][d["id"]];
							subid = info["community_subid" + mark + "_level" + cluster_level][d["id"]];
							return ColorLuminance(cluster_color[top_community%top_cluster_count], 0.2*(subid%sub_cluster_count));
						}
					})
					.style("fill-opacity", 0.7)
					.attr("stroke-width", 1)
					//.attr("transform", function(d) { return "translate(" + x(d["x"]) + "," + y(d["y"]) + ")";})
					.on("mouseover", function(d) {
						d3.selectAll(".clusterSummarySide").remove();
						clusterVector = [];
						showHeatMap_cluster();
						
						d3.select("#clusterSummary")
							.append("div")
							.attr("class", "clusterSummarySide")
							.html("<b>Cluster Summary Sidebar</b><br>"
								+"<b>Cluster ID:</b> " + d["id"] + "<br>"
								+"<b>Cluster Size:</b> " + d["size"] + "<br>"
								+"<b>Cluster Validation (Silhouette Coefficient):</b> " + d["silhouette"] + "<br>"
								+"<b>Cluster External Validation (Highlighted/Relevant Articles):</b> Number=" + d["highlight_number"] + ", Recall="+ d["highlight_recall"] + ", Precision=" + d["highlight_precision"] + "<br>"
								+"<b>Averaged Cluster Semantic Vector:</b><br>");
						d3.select("#clusterSummarySide")
							.append("div")
							.attr("id", "clusterVector")
							.style("height", 0);
						clusterVector = d["vector"];	
						showHeatMap_cluster();
					});
					
				clusters
					.append("text")
					.attr("dx", function(d){return -0.2*(3+d["size"]*0.15);})
					.attr("dy", function(d){return 0.2*(3+d["size"]*0.15);})
					.text(function(d){return d["id"];});
					
				cluster_svg.append("svg:line")
					.classed("axisLine hAxisLine", true)
					.attr("x1", 0)
					.attr("y1", 0)
					.attr("x2", width)
					.attr("y2", 0)
					.attr("transform", "translate(0," + height + ")");
		
				cluster_svg.append("svg:line")
					.classed("axisLine hAxisLine", true)
					.attr("x1", 0)
					.attr("y1", -height)
					.attr("x2", width)
					.attr("y2", -height)
					.attr("transform", "translate(0," + height + ")");	

				cluster_svg.append("svg:line")
					.classed("axisLine vAxisLine", true)
					.attr("x1", 0)
					.attr("y1", 0)
					.attr("x2", 0)
					.attr("y2", height);
			
				cluster_svg.append("svg:line")
					.classed("axisLine vAxisLine", true)
					.attr("x1", width)
					.attr("y1", 0)
					.attr("x2", width)
					.attr("y2", height);		
        	}
        	*/
        	
        	// ##### show the heatmap of the averaged cluster vector for the cluster which is mouseovered in the cluster exploration window
        	/*
        	function showHeatMap_cluster(){
				d3.select("#clusterVector").selectAll("*").remove();
				if(type != "layout_tsne_text" && type != "layout_tsnePA_text" || clusterVector == []){
					d3.select("#clusterVector").style("height", 0);
					return;
				}
				
				var itemDimension = 200;
      			var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      			var width = 1200;
      			var height = 30;
      			var itemSize = width/itemDimension;
      			var cellSize = itemSize - 1;
      			d3.select("#clusterVector").style("height", 100);
      			
				var currentData_formated = []; // the postion and value of each heatmap-cell
				for(j = 0; j < clusterVector.length; j++){
					element = {};
					element["x"] = j;
					element["y"] = 0;
					element["value"] = clusterVector[j];
					currentData_formated.push(element);
				}
				//console.log(displayData_formated);
		
				var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        		var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    			var xScale = d3.scale.ordinal()
        			.domain(x_elements)
        			.rangeBands([0, x_elements.length * itemSize]);

    			var yScale = d3.scale.ordinal()
        			.domain(y_elements)
        			.rangeBands([0, y_elements.length * itemSize]);
        	
        		//var colorScale = d3.scale.threshold()
       	 		//	.domain([0, 1])
       			//	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
        
       			var colorScale = d3.scale.threshold()
    				.domain([-2, -1, 0, 1, 2])
    				//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    				.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
					
				var heatmap_svg = d3.select(".clusterSummarySide")
					.append("svg")
        			.attr("width", width)
        			.attr("height", height)
        			.attr("class", "heatmap_svg")
        			.append("g");
        			//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  				
  				var tip_avgVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "<b>" + d.x + "</b>";
  					});	
  				//heatmap_svg.call(tip_avgVector);
  				        
        		var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 			.data(currentData_formated)
        			.enter().append('g').append('rect')
        			.attr('class', 'cell')
       				.attr('width', cellSize)
        			.attr('height', 20)
        			.attr('y', function(d) { return yScale(d.y); })
        			.attr('x', function(d) { return xScale(d.x); })
        			.attr('fill', function(d) { return colorScale(d.value); });
        	}
        	*/
        	
        	// (Update 2017/12/21)
        	// ##### Show pairwise cluster comparison information - matrix
        	/*
        	var clusterVectorPair = []; // the vectors of the two clusters which are selected for comparison
        	showClusterCompare();
        	function showClusterCompare(){
        		d3.select("#clusterCompare").selectAll("*").remove();
				if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
					d3.select("#clusterCompare").style("height", 0);
					return;
				}
				
				var width = 350;
				var height = 350;
				margin = {top: 30, right: 0, bottom: 20, left: 30};		
				var clusterNumber = info["level_size"][cluster_level];
				var itemSize = width/clusterNumber;
      			var cellSize = itemSize - 1;
      			//d3.select("#clusterCompare").style("height", height + margin.top + margin.bottom);
      			d3.select("#clusterCompare").style("height", "auto");
      			d3.select("#clusterCompare")
					.append("div")
					.html("<b>Cluster Comparison</b>");
      			
      			var mark = 0;
      			if(type == "layout_tsne_text") mark = "3";
      			else if (type == "layout_tsnePA_text") mark = "4";
      			else return;
				
				var clusterDataDisplay = []
				for(i = 0; i < clusterNumber; i++){
					for(j = 0; j < clusterNumber; j++){
						element = {};
						element["x"] = j;
						element["y"] = i;
						element["similarity"] = info["cluster_simi" + mark][cluster_level][i][j];
						element["idX"] = i;
						element["idY"] = j;
						element["sizeX"] = info["cluster_size" + mark][cluster_level][i];
						element["sizeY"] = info["cluster_size" + mark][cluster_level][j];
						element["silhouetteX"] = info["cluster_silhouette" + mark][cluster_level][i];
						element["silhouetteY"] = info["cluster_silhouette" + mark][cluster_level][j];
						element["vectorX"] = info["cluster_vector" + mark][cluster_level][i];
						element["vectorY"] = info["cluster_vector" + mark][cluster_level][j];
						element["highlight_numberX"] = info["cluster_highlight_size" + mark][cluster_level][i];
      					element["highlight_precisionX"] = element["highlight_numberX"]/element["sizeX"];
      					element["highlight_recallX"] = element["highlight_numberX"]/info["number_highlight"];
      					element["highlight_numberY"] = info["cluster_highlight_size" + mark][cluster_level][j];
      					element["highlight_precisionY"] = element["highlight_numberY"]/element["sizeY"];
      					element["highlight_recallY"] = element["highlight_numberY"]/info["number_highlight"];
						clusterDataDisplay.push(element);
					}
				}
				
				var x_elements = d3.set(clusterDataDisplay.map(function( item ) { return item.x; } )).values();
        		var y_elements = d3.set(clusterDataDisplay.map(function( item ) { return item.y; } )).values();
        		
        		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);
        		
        		var xAxis_matrix = d3.svg.axis()
        			.scale(xScale)
        			.tickFormat(function (d) {
            			return d;
        			})
        			.orient("top");

    			var yScale = d3.scale.ordinal()
        			.domain(y_elements)
        			.rangeBands([0, y_elements.length * itemSize]);
        			
        		var yAxis_matrix = d3.svg.axis()
        			.scale(yScale)
        			.tickFormat(function (d) {
            			return d;
        			})
        			.orient("left");	
        					
        		var colorScale = d3.scale.threshold()
    			.domain([0.5, 0.2, 0.4, 0.6, 0.8])
    			.range(["#ffffff", "#ffd6cc", "#ffad99", "#ff8566", "#ff5c33", "#ff3300"]);	
      			
      			
      			var cluster_svg_matrix = d3.select("#clusterCompare")
					.append("svg")
        			.attr("width", width + margin.left + margin.right)
        			.attr("height", height + margin.top + margin.bottom)
        			.attr("class", "cluster_svg_matrix")
        			.append("g")
        			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        			
        		var cells = cluster_svg_matrix.selectAll('.matrix_rect')
       	 			.data(clusterDataDisplay)
        			.enter().append('g').append('rect')
        			.attr('class', 'cell')
       				.attr('width', cellSize)
        			.attr('height', cellSize)
        			.attr('y', function(d) { return yScale(d.y); })
        			.attr('x', function(d) { return xScale(d.x); })
        			.attr('fill', function(d) { return colorScale(d.similarity); })
        			.on("mouseover", function(d) {
        				d3.selectAll(".clusterCompareSide").remove();
						clusterVectorPair = [];
						showHeatMap_clusterPair();
        			
						d3.select("#clusterCompare")
							.append("div")
							.attr("class", "clusterCompareSide")
							.html("<b>Cluster Compare Sidebar</b><br>"
								+"<b>Pairwise Similarity:</b> " + d["similarity"] + "<br>"
								+"<b>Cluster 1 (Row):</b> ID=" + d["idX"] + ", Size=" + d["sizeX"] + ", Internal Validation=" + d["silhouetteX"] + ", External Validation=(#:" + d["highlight_numberX"] + ", R:" + d["highlight_recallX"] + ", P:" + d["highlight_precisionX"] + ")<br>"
								+"<b>Cluster 2 (Col):</b> ID=" + d["idY"] + ", Size=" + d["sizeY"] + ", Internal Validation=" + d["silhouetteY"] + ", External Validation=(#:" + d["highlight_numberY"] + ", R:" + d["highlight_recallY"] + ", P:" + d["highlight_precisionY"] + ")<br>"
								+"<b>Averaged Cluster Semantic Vectors:</b><br>");
						d3.select("#clusterCompareSide")
							.append("div")
							.attr("id", "clusterVectorPair")
							.style("height", 0);
						clusterVectorPair.push(d["vectorX"]);
						clusterVectorPair.push(d["vectorY"]);	
						showHeatMap_clusterPair();
					});
					
				cluster_svg_matrix.append("g")
        			.attr("class", "y axis")
        			.call(yAxis_matrix)
        			.selectAll('text')
        			.attr('font-weight', 'normal');

    			cluster_svg_matrix.append("g")
        			.attr("class", "x axis")
        			.call(xAxis_matrix)
        			.selectAll('text')
        			.attr('font-weight', 'normal')
        			.style("text-anchor", "start")
        			.attr("dx", ".8em")
        			.attr("dy", ".5em")
        			.attr("transform", function (d) {
            			return "rotate(-65)";
        			});	
        	}
        	*/
        	
        	// ##### show the heatmap of the averaged cluster vectors for the 2 clusters which are selected for comparison in the cluster matrix
        	/*
        	function showHeatMap_clusterPair(){
			d3.select("#clusterVectorPair").selectAll("*").remove();
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text" || clusterVectorPair == []){
				d3.select("#clusterVectorPair").style("height", 0);
				return;
			}
			
			var itemDimension = 200;
      		var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		var width = 1200;
      		var height = 50;
      		var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		d3.select("#clusterVectorPair").style("height", 100);
      		
			var currentData_formated = []; // the postion and value of each heatmap-cell
			for(i = 0; i < clusterVectorPair.length; i++){
				for(j = 0; j < clusterVectorPair[i].length; j++){
					element = {};
					element["x"] = j;
					element["y"] = i;
					element["value"] = clusterVectorPair[i][j];
					currentData_formated.push(element);
				}
			}
			//console.log(displayData_formated);
		
			var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (20+2)]);
        	
        	//var colorScale = d3.scale.threshold()
       	 	//	.domain([0, 1])
       		 //	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
			
			var heatmap_svg = d3.select(".clusterCompareSide")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g");
        		//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(currentData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		.attr('height', 20)
        		.attr('y', function(d) { return yScale(d.y); })
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { return colorScale(d.value); });
        	}
        	*/
        	
        	// (Update 2017/12/21)
        	// ##### list all the dimensions of the semantic vector, enable interactive exploration of the vector dimensions
        	// per click a specific dimension, all articles with a high value in this dimension will be highlighted in the article distribution
			//vectorExplore_single();
			function vectorExplore_single(){
				d3.select("#vectorExplore1").selectAll("*").remove();
				if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
					d3.select("#vectorExplore1").style("height", 0);
					return;
				}
				
				var itemDimension = 200;
				var itemNumber = 1;
      			var margin = {top: 20, right: 20, bottom: 20, left: 30};
      			var width = 1200;
      			var height = 50;
      			var itemSize = width/itemDimension;
      			var cellSize = itemSize - 1;
      			d3.select("#vectorExplore1")
      				.style("min-height", height)
      				.style("height", "auto");
      	
      			var vector_type = ""; // "_PV" or "_PA"
      			if(type == "layout_tsne_text") vector_type = "_PV";
      			else if (type == "layout_tsnePA_text") vector_type = "_PA";
      			else return;
      			var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      			var vector_mark = "vector" + vector_type + vector_mode;
      			var threshold = 0.6; // the threshold of identifying high dimension values
		
				var currentData_formated = []; // the postion and value of each heatmap-cell
				for(i = 0; i < itemNumber; i++){
					for(j = 0; j < itemDimension; j++){
						element = {};
						element["x"] = j;
						element["y"] = i;
						element["value"] = 0;
						currentData_formated.push(element);
					}
				}
		
				var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        		var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    			var xScale = d3.scale.ordinal()
        			.domain(x_elements)
        			.rangeBands([0, x_elements.length * itemSize]);

    			var yScale = d3.scale.ordinal()
        			.domain(y_elements)
        			.rangeBands([0, y_elements.length * itemSize]);
        	
        		var colorScale = d3.scale.threshold()
       	 			.domain([0.5])
       		 		.range(["#00bfff", "#008cba"]);
       		 		
       		 	var tip_vector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "<b>" + d.x + "</b>";
  					});
			
				d3.select("#vectorExplore1")
					.append("div")
					.html("<b>Semantic Space Explorer - All Articles</b>");

				var vector_svg = d3.select("#vectorExplore1")
					.append("svg")
        			.attr("width", width)
        			.attr("height", 30)
        			.attr("class", "vector_svg")
        			.append("g");
        			//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        		vector_svg.call(tip_vector);	

        		var cells = vector_svg.selectAll('.vector_rect')
       	 			.data(currentData_formated)
        			.enter().append('g').append('rect')
        			.attr('class', 'cell')
       				.attr('width', cellSize)
        			.attr('height', 20)
        			.attr('y', function(d) { return yScale(d.y); })
        			.attr('x', function(d) { return xScale(d.x); })
        			.attr('fill', function(d) { return colorScale(d.value); })
        			//.append("title")
        			//.text(function(d) {return d.x;})
        			.on('mouseover', function(d){
        				tip_vector.show(d);
        			})
      				.on('mouseout', function(d){
      					tip_vector.hide(d);
      				})
      				.on("click", function(d){ // once click a dimension cell, highlight all document nodes that have a high value in this dimension in their semantic vectors
      					// handle the colors of dimension cells (darker color for the clicked dimension cell)
      					vector_svg.selectAll('rect')
      						.attr('fill', function(x){
      							return colorScale(x.value);
      						});
      					d.value = 1;
      					d3.select(this)
      						.attr('fill', function(x){
      							return colorScale(x.value);
      						});
      					d.value = 0;
      					// find and highlight corresponding document nodes
      					var index = [];  // record the list of matched document nodes to be highlighted (see the click action below)
      					var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the matched documents
      					var findResult = 0;
      					
						objects.selectAll(".dot")
							//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
							.attr("r", function (n) { 
								basic_size = circle_size_s;
								if(showHighlight == 1 && n.if_highlight == "1") basic_size = circle_size_m; 
								return n.number_of_citations * citationSizePara + basic_size; 
							})
							.attr("stroke", function (n){
								if(n[vector_mark][d.x] > threshold){
									index.push(n.index);
									keywords_list.push(n.keyword_rake);
									findResult = 1;
									//return "#cc0000";
									
								}
								return "black";
							})
							.style("fill-opacity", function(n){
								if(index.indexOf(n.index) != -1){
									findResult = 1;
									d3.select(this).moveToFront();
									return 1;
								}
								else return 0.15;
							})
							.attr("stroke-width", function(n){
								if(index.indexOf(n.index) != -1){
									findResult = 1;
									return 1.5;
								}
								else return 0;
							});
						if(findResult == 0){
							objects.selectAll(".dot")
								.style("fill-opacity", 0.5)
								.attr("stroke-width", 1);
						}
						
						// get the keywords summarized from the highlighted articles
      					var keywords_dict = {}; // keywords and their overall counts (a keyword might appear multiple times in a single document)
      					var keywords_dict2 = {}; // keywords and their document-counts (number of documents contain the keyword)
      					for(i = 0; i < index.length; i++){
      						var keywords_in_current_doc = []; // record whether a keyword has been counted in the current document
      						var keyword_rake = keywords_list[i].split(", ");
      						for(j = 0; j < keyword_rake.length; j++){
      							keyword = keyword_rake[j].trim();
      							if(keyword in keywords_dict){
      								keywords_dict[keyword] = keywords_dict[keyword] + 1;
      								if(keyword.indexOf(keywords_in_current_doc) == -1){
      									keywords_dict2[keyword] = keywords_dict2[keyword] + 1;
      									keywords_in_current_doc.push(keyword);
      								}
      							}
      							else{
      								keywords_dict[keyword] = 1;
      								keywords_dict2[keyword] = 1;
      								keywords_in_current_doc.push(keyword);
      							}
      						}
      					}
      					//console.log(keywords_dict);
      					//console.log(keywords_dict2);
      					
      					// sort the dictionary (sort keywords by their counts)
      					var keywords_dict2_sorted = Object.keys(keywords_dict2).map(function(key){
      						return [key, keywords_dict2[key]];
      					});
      					keywords_dict2_sorted.sort(function(first, second){
      						return second[1] - first[1];
      					});
						//console.log(keywords_dict2_sorted);
      					
						var number_keyword_display = Math.min(30, keywords_dict2_sorted.length);
						var keywords_display = [];
						var keywords_display_str = ""
      					for(i = 0; i < number_keyword_display; i++){
      						keywords_display.push(keywords_dict2_sorted[i][0]);
      						keywords_display_str += keywords_dict2_sorted[i][0];
      						keywords_display_str += "(" + keywords_dict2_sorted[i][1] + ") ";
      					}
      					
      					// display the identified keywords
      					d3.selectAll(".vectorKeywords").remove();
      					d3.select("#vectorExplore1")
						.append("div")
						.attr("class", "vectorKeywords")
						.html("<b>Selected Keywords</b><br>"
						//+ keywords_display);
						+keywords_display_str);	
      				});      				
        		}  		
        
       
       	// (Update 2018/03/01 and 2018/08/15 and 2018/09/04)
       	// calculate dimensions' behavior values, e.g. min, max, mean, item-based variance (standard deviation), and cluster-based variance (taking cluster average)
       	// calculate the correlation among dimensions (from the 200d dimension vectors)
       	var dimensionMean = [];
       	var dimensionMax = [];
       	var dimensionMin = [];
       	var dimensionVariance = [];
       	var dimensionVariance_cluster = [];
       	var dimensionVector = []; 
       	var dimensionCorrelation = [];  // pairwise dimension correlation
       	var dimensionDistance = []; // pairwise dimension distance
       	var dimensionCluster = [];
       	function initDimensions(){
       		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
      		
       		for(var dim = 0; dim < 200; dim++){
				dimensionMean.push(0);
				dimensionMax.push(-2);
				dimensionMin.push(2);
				dimensionVariance.push(0);
				dimensionVariance_cluster.push(0);
			}
			
			// (0) arrange the dimension vectors, 200*n
			for(var dim = 0; dim < 200; dim++){
				var currentVector = [];
				data.forEach(function(d){
					currentVector.push(d[vector_mark][dim]);
				});
				dimensionVector.push(currentVector);
			}
			//console.log(dimensionVector);
			
			// (1) calculate dimension min, max, and mean
			data.forEach(function(d){
				for(var dim = 0; dim < 200; dim++){
					dimensionMean[dim] += d[vector_mark][dim];
					if(d[vector_mark][dim] > dimensionMax[dim]) dimensionMax[dim] = d[vector_mark][dim];
					if(d[vector_mark][dim] < dimensionMin[dim]) dimensionMin[dim] = d[vector_mark][dim];
				}
			});
			for(var dim = 0; dim < 200; dim++){
				dimensionMean[dim] = dimensionMean[dim]/(data.length);
			}
			
			// (2) calculate dimension variances (item_based standard deviation)
			data.forEach(function(d){
				for(var dim = 0; dim < 200; dim++){
					dimensionVariance[dim] += Math.pow((d[vector_mark][dim] - dimensionMean[dim]), 2);
				}
			});
			for(var dim = 0; dim < 200; dim++){
				dimensionVariance[dim] = Math.sqrt(dimensionVariance[dim]/data.length);
			}
			
			// (3) calculate dimension variances (cluster_average_based standard deviation)
			if(assignments.length == 0) return;
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;			
      		for(var i = 0; i < clusterCount; i++){
      			for(var dim = 0; dim < 200; dim++){
      				//dimensionVariance_cluster[dim] += Math.pow((cluster_vectors[i][dim] - dimensionMean[dim]), 2);
      				dimensionVariance_cluster[dim] += cluster_size[i] * Math.pow((cluster_vectors[i][dim] - dimensionMean[dim]), 2); // weight clusters using their size
      			}
      		}
      		for(var dim = 0; dim < 200; dim++){
				dimensionVariance_cluster[dim] = Math.sqrt(dimensionVariance_cluster[dim]/clusterCount);
			}
      		//console.log(dimensionVariance_cluster);
      		
      		// (4) calculate dimension correlations
      		// https://github.com/agrueneberg/Spearson
      		for(var dim1 = 0; dim1 < 200; dim1++){
      			var currentDimCorrelation = [];
      			for(var dim2 = 0; dim2 < 200; dim2++){
      				var correlation = pearson(dimensionVector[dim1], dimensionVector[dim2], true);
      				currentDimCorrelation.push(correlation);
      			}
      			dimensionCorrelation.push(currentDimCorrelation);
      		}
      		//console.log(dimensionCorrelation);
      		
      		// (5) calculate dimension distances and clusters
      		//dimensionDistance = pairwiseDistance(dimensionVector);
      		//console.log(dimensionDistance);
      		//dimensionCluster = hierarchicalClustering(dimensionDistance, "complete");
      		//console.log(dimensionCluster);
      		/*console.log(dimensionCluster[0]);
      		console.log(dimensionCluster[0]["size"]);
      		console.log(dimensionCluster[0]["children"]);
      		console.log(dimensionCluster[0]["children"].length);
      		console.log(dimensionCluster[0]["children"][0]);
      		console.log(dimensionCluster[0]["children"][0]["size"]);
      		console.log(dimensionCluster[0]["children"][1]["size"]);*/
       	}
       	
       	// rank and display selected dimensions using calculated dimension behavior values
       	var dimensions_rankByIndex = []; // rank by dimension ids
       	var dimensions_rankByVariance = []; // rank by document-level variance (SD)
       	var dimensions_rankByClusterVariance = []; // rank by cluster-level variance (SD) - rely on the generated clusters
        d3.select("#checkDimensions_variance").on("click", checkDimensions_variance);
        function checkDimensions_variance(){
        	d3.select("#vectorExplore0").select("svg").remove();
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore2").style("height", 0);
				return;
			}
			d3.select("#vectorExplore0").selectAll("svg").remove();
			
			var width = 1200;
			var height = 150;
			var itemNumber = currentData.length;
			var itemDimension = 200;
			var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore0").style("height", height);
      	
      		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			
			if(dimensionVariance.length == 0 || dimensionMean.length == 0){
				initDimensions();
			}
			
			// selected dimensions
			var selection = [];		
			var selection_str = document.getElementById("checkDimensions_dim").value.trim();
			var selection_raw = [];
			if(selection_str.length < 1 || selection_str.toLowerCase() == "all"){
				//alert("All dimensions will be taken for examinations.")
				for(var dim = 0; dim < 200; dim++) selection_raw.push(toString(dim));
				//console.log(selection_raw);
			}
			else if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < 200
					&& selection.indexOf(parseInt(element.trim())) == -1){
					selection.push(parseInt(element.trim()));
				}
			}
			if(selection.length == 0){
				alert("All dimensions will be taken.");
				for(var dim = 0; dim < 200; dim++) selection.push(dim);
				
			}
			//console.log(selection); 
			
			var rank_mode = "";
			d3.selectAll(".checkDimensions_rank").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					rank_mode = radio.property("value");
				}
			});
			
			// prepare the data for line (dot) charts
			var dataMean = [];
			var dataMax = [];
			var dataMin = [];
			var dataAll = [];
			var dataAll_rank = [];
			for(var dim = 0; dim < 200; dim++){
				if(selection.indexOf(dim) != -1){
					var objMean = {};
					objMean["dim"] = dim;
					objMean["value"] = dimensionMean[dim];
					dataMean.push(objMean);
					
					var objMax = {};
					objMax["dim"] = dim;
					objMax["value"] = dimensionMax[dim];
					dataMax.push(objMax);
					
					var objMin = {};
					objMin["dim"] = dim;
					objMin["value"] = dimensionMin[dim];
					dataMin.push(objMin);
					
					var obj = {}
					obj["dim"] = dim;
					obj["mean"] = dimensionMean[dim];
					obj["max"] = dimensionMax[dim];
					obj["min"] = dimensionMin[dim];
					obj["variance"] = dimensionVariance[dim];
					obj["variance_cluster"] = dimensionVariance_cluster[dim];
					dataAll.push(obj);
					dataAll_rank.push(obj);
				}
			}
			//console.log(dataMean);
			
			// rank and prepare the data based on the dimension variances (standard deviation)
			if(rank_mode == "variance"){
				dataAll_rank.sort(function(a,b) {return (a.variance < b.variance) ? 1 : ((b.variance < a.variance) ? -1 : 0);} );
				for(var i in dataAll_rank){
					dimensions_rankByVariance.push(dataAll_rank[i]["dim"]);
				}
			}
			else if(rank_mode == "variance_cluster"){
				dataAll_rank.sort(function(a,b) {return (a.variance_cluster < b.variance_cluster) ? 1 : ((b.variance_cluster < a.variance_cluster) ? -1 : 0);} );
				for(var i in dataAll_rank){
					dimensions_rankByClusterVariance.push(dataAll_rank[i]["dim"]);
				}
			}
			else{
				dataAll_rank.sort(function(a,b) {return (a.dim > b.dim) ? 1 : ((b.dim > a.dim) ? -1 : 0);} );
				for(var i in dataAll_rank){
					dimensions_rankByIndex.push(dataAll_rank[i]["dim"]);
				}
			}
			//console.log(dataAll_rank);
			
			// draw the line (dot) chart
			var margin = {top: 10, right: 20, bottom: 20, left: 20};
			var x = d3.scale.linear().range([0, 1200]).domain([0, selection.length - 1]);
			var y = d3.scale.linear().range([100, 0]).domain([-2, 2]);
  			
  			// Define the axes
			var xAxis = d3.svg.axis().scale(x)
   				.orient("bottom").ticks(5);

			var yAxis = d3.svg.axis().scale(y)
   			 	.orient("left").ticks(5);

			// Define the line
			var valueMean = d3.svg.line()
    			.x(function(d, i) { return x(i); })
    			.y(function(d) { return y(d.mean); });
    		var valueMax = d3.svg.line()
    			.x(function(d, i) { return x(i); })
    			.y(function(d) { return y(d.max); });
    		var valueMin = d3.svg.line()
    			.x(function(d, i) { return x(i); })
    			.y(function(d) { return y(d.min); });		
    		
    		var svg = d3.select("#vectorExplore0")
				.append("svg")
        		.attr("width", 1200 + margin.left + margin.right)
        		.attr("height", 150 + margin.top + margin.bottom)
        		.attr("class", "lineChart_svg")	
        		.append("g")
        		.attr("transform", 
              		"translate(" + margin.left + "," + margin.top + ")");
        		
        	var tip = d3.tip()
  				.attr('class', 'd3-tip')
  				.offset([-10, 0])
  				.html(function(d) {
   					return "<b>" + d.dim + "</b>";
  				});
  			svg.call(tip);				
        	
        	 // Add the valueline path.
    		svg.append("path")
        		.attr("class", "lineChart_line")
        		.attr("d", valueMean(dataAll_rank));
        	svg.append("path")
        		.attr("class", "lineChart_line")
        		.attr("d", valueMax(dataAll_rank));
        	svg.append("path")
        		.attr("class", "lineChart_line")
        		.attr("d", valueMin(dataAll_rank));
        			
			var blues = d3.scale.linear()
  				.domain([1, -1])
  				//.range(["steelblue", "brown"])
  				//.range(["#82bce3", "#f0ae75"])
  				//.range(["#eb9447", "#439bd6"])
  				.range(["#003366", "#e6f2ff"])
  				.interpolate(d3.interpolateLab);
  				
  			var blue_to_orange = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#005c99", "#006bb3", "#0099ff", "#4db8ff", "#99d6ff", "#e6f5ff", "#fff5e6", "#ffd699", "#ffb84d", "#ff9900", "#e68a00", "#cc7a00"]);
			
			/*var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#0000e6", "#1a1aff", "#4d4dff", "#8080ff", "#b3b3ff", "#e6e6ff", "#ffebe6", "#ffc3b3", "#ff9b80", "#ff734d", "#ff4b1a", "#f43400"]);*/
    			
    		/*var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000099", "#0000cc", "#1a1aff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff734d", "#ff4b1a", "#f43400", "#b32700"]);*/
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);	

			// Add the bar chart
			svg.selectAll(".lineChart_verticleLine")
				.data(dataAll_rank)
				.enter()
				.append("line")  
    			.attr("class", "lineChart_verticleLine")
    			.attr("x1", function(d, i) { return x(i); })
    			.attr("y1", function(d, i) { return y(d.max); })  
   				.attr("x2", function(d, i) { return x(i); })
    			.attr("y2", function(d, i) { return y(d.min); })
    			.on("mouseover", function(d, i){
    				tip.show(d);
    				d3.select(this).style("stroke", "#51a5e1");
    			})
    			.on("mouseout", function(d){
    				tip.hide(d);
    				d3.select(this).style("stroke", "1f77b4");
    			})
    			.on("click", function(d){
    				var index = [];  // record highly responsive articles
      				var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    				var value_threshold = Quartile(dimensionVector[d.dim], 0.9);
    				//console.log(dimensionVector[d.dim]);
    				//console.log(value_threshold);
    				
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						var article_value = n[vector_mark][d.dim];
							if(article_value >= value_threshold){
								//console.log(article_value);
								index.push(n.index);
								keywords_list.push(n.keyword_rake);
							}
							return blue_to_red(article_value);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);
    				// generate keywords for the selected dimension (highlighted articles)
    				keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
					updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    			});
    			
    		// Add the X Axis
    		/*svg.append("g")
        		.attr("class", "x axis")
        		.attr("transform", "translate(0," + height + ")")
        		.call(xAxis);*/

   		 	// Add the Y Axis
    		svg.append("g")
        		.attr("class", "y axis")
        		//.attr("transform", "translate(0, 0)")
        		.call(yAxis);	
        		
        	// Add the value dots - indicate average values
        	svg.selectAll(".lineChart_dot")
    			.data(dataAll_rank)
 				.enter().append("circle") // Uses the enter().append() method
    			.attr("class", "lineChart_dot") // Assign a class for styling
    			.attr("cx", function(d, i) { return x(i); })
    			.attr("cy", function(d) { return y(d.mean); })
    			.attr("r", 3)
    			.on("mouseover", function(d, i){
    				tip.show(d);
    				//svg.append("line")  
    				//    .attr("class", "lineChart_verticleLine")
    				//	.attr("x1", x(i))
    				//	.attr("y1", y(d.max))  
   					// 	.attr("x2", x(i))
    				//	.attr("y2", y(d.min));  	
    			})
    			.on("mouseout", function(d){
    				tip.hide(d);
    				//d3.select("#vectorExplore0").selectAll("svg").selectAll(".lineChart_verticleLine").remove();
    			});
					  	
        }
        
        d3.select("#checkDimensions_reset").on("click", checkDimensions_reset);
        function checkDimensions_reset(){
         	objects.selectAll(".dot")
				.style("fill", function(d){
					return cluster_color[0];
				})
				.attr("stroke-width", function(d){
					if(showHighlight == 1 && d.if_highlight == "1") return 3;
					return 1; 
				})
				.attr("r", 3);
         }
        
        // (Update 2018/03/01)
        // after dimension variances and means have been checked/generated, 
        d3.select("#checkDimensions_varianceHighlight").on("click", checkDimensions_varianceHighlight);
        function checkDimensions_varianceHighlight(){
        	// get the threshold for dimension variance
			var varianceBottom_raw = document.getElementById("checkDimensions_varianceBottom").value.trim();
			var varianceBottom = 0;
			if(! (/^\d+\.\d+$/.test(varianceBottom_raw))){
				//alert("You didn't provide a valid treshold. The default threshold 0 will be taken.");
			}
			else{
				varianceBottom = parseFloat(varianceBottom_raw);
			}
			
			var varianceTop_raw = document.getElementById("checkDimensions_varianceTop").value.trim();
			var varianceTop = 2;
			if(! (/^\d+\.\d+$/.test(varianceTop_raw))){
				//alert("You didn't provide a valid treshold. The default threshold 2 will be taken.");
			}
			else{
				varianceTop = parseFloat(varianceTop_raw);
			}
			console.log(varianceBottom); 
			console.log(varianceTop); 
			
			// get the threshold for dimension mean
			var meanBottom_raw = document.getElementById("checkDimensions_meanBottom").value.trim();
			var meanBottom = -1;
			if(! (/^\d+\.\d+$/.test(meanBottom_raw))){
				//alert("You didn't provide a valid treshold. The default threshold -1 will be taken.");
			}
			else{
				meanBottom = parseFloat(meanBottom_raw);
			}
			
			var meanTop_raw = document.getElementById("checkDimensions_meanTop").value.trim();
			var meanTop = 1;
			if(! (/^\d+\.\d+$/.test(meanTop_raw))){
				//alert("You didn't provide a valid treshold. The default threshold 1 will be taken.");
			}
			else{
				meanTop = parseFloat(meanTop_raw);
			}
			console.log(meanBottom); 
			console.log(meanTop); 
        }
       
        // (Update 2018/02/19)
        // pairwise comparison of 2 article vectors or 2 cluster vectors, using bar charts
        // the bars can be ranked by the dimensions values of the first article
		d3.select("#comparePair").on("click", comparePair);
		function comparePair(){
			d3.select("#vectorExplore2").select("svg").remove();
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore2").style("height", 0);
				return;
			}
			
			// compare between articles or between clusters
			var compare_mode = "";
			d3.selectAll(".compareMode").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					compare_mode = radio.property("value");
				}
			});
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			if(compare_mode == "cluster" && (assignments.length == 0 || clusterCount < 2)){
				alert("Please run Clustering to generate at least 2 clusters before comparing clusters.");
				return;
			}
			//console.log(compare_mode);
			
			// the type of bar charts
			var chart_type = "";
			d3.selectAll(".compareChart").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					chart_type = radio.property("value");
				}
			});
			//console.log(chart_type);
			
			// whether to rank the bars (by the dimension values of the first article)
			var if_rank = "";
			d3.selectAll(".ifRank").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					if_rank = radio.property("value");
				}
			});
			//console.log(if_rank);
			
			// the selected article pairs or cluster pairs
			var selection = [];
			if(document.getElementById("compareItem1").value.length < 1 || document.getElementById("compareItem2").value.length < 1){
				if(compare_mode == "article") alert("Article 0 and Article 1 will be taken as an example");
				else alert("Cluster 0 and Cluster 1 will be taken as an example");
				selection.push(0);
				selection.push(1);
			}
			else{
				selection.push(parseInt(document.getElementById("compareItem1").value));
				selection.push(parseInt(document.getElementById("compareItem2").value));
			}
			//console.log(selection);
			//var currentData = data.filter(function(d){ return selection.indexOf(d.index) != -1;} ); // the documents whose vectors will be displayed as a heatmap
			var currentData = []
			if(compare_mode == "article"){
				for(var sel in selection){
					if(parseInt(selection[sel]) < 0 || parseInt(selection[sel]) >= data.length){
						alert("Invalid Article ID: " + selection[sel]);
						return;
					}
					for(var item in data){
						if(data[item].index == selection[sel]){
							currentData.push(data[item]);
							continue;
						}
					}
				}
			}
			else{
				currentData = selection;
				for(var sel in selection){
					if(parseInt(selection[sel]) < 0 || parseInt(selection[sel]) >= clusterCount){
						alert("Invalid Cluster ID: " + selection[sel]);
						return;
					}
				}
			}

			var width = 1200;
			var height = 100;
			var itemNumber = currentData.length;
			var itemDimension = 200;
			var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore2").style("height", height);
      	
      		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
      		
      		// order of dimensions - if the rank mode is selected, we need to get the order of dimensions based on the first article
      		var dimOrder = [];
      		for(var i in currentData[0][vector_mark]){
      			var obj = {};
      			obj["id"] = parseInt(i);
      			obj["value"] = currentData[0][vector_mark][i];
      			obj["rank"] = i;
      			dimOrder.push(obj);
      		}
      		dimOrder.sort(compareDimObjValue);
      		for(var i in dimOrder){
      			dimOrder[i]["rank"] = i;
      		}
      		dimOrder.sort(compareDimObjIndex);
      		//console.log(dimOrder);
      		
      		// order of dimensions - if the rank mode is selected, we need to get the order of dimensions based on the first cluster
      		var dimOrder_cluster = [];
      		for(var i in cluster_vectors[selection[0]]){
      			var obj = {};
      			obj["id"] = parseInt(i);
      			obj["value"] = cluster_vectors[selection[0]][i];
      			obj["rank"] = i;
      			dimOrder_cluster.push(obj);
      		}
      		dimOrder_cluster.sort(compareDimObjValue);
      		for(var i in dimOrder_cluster){
      			dimOrder_cluster[i]["rank"] = i;
      		}
      		dimOrder_cluster.sort(compareDimObjIndex);
      		//console.log(dimOrder_cluster);
      		
			// format elements to visualize in the bar chart
			var currentData_formated = []; // the postion and value of each heatmap-cell
			var max_value = 0;
			var min_value = 0;
			for(var i = 0; i < itemNumber; i++){
				if(compare_mode == "article"){
					for(var j = 0; j < currentData[i][vector_mark].length; j++){
						element = {};
						element["id"] = j;
						if(if_rank == "value") element["x"] = dimOrder[j]["rank"];
						else element["x"] = j;
						element["y"] = i;
						element["value"] = currentData[i][vector_mark][j];
						currentData_formated.push(element);
					
						if(element["value"] > max_value) max_value = element["value"];
						if(element["value"] < min_value) min_value = element["value"];
					}
				}
				else{
					for(var j = 0; j < cluster_vectors[selection[i]].length; j++){
						element = {};
						element["id"] = j;
						if(if_rank == "value") element["x"] = dimOrder_cluster[j]["rank"];
						else element["x"] = j;
						element["y"] = i;
						element["value"] = cluster_vectors[selection[i]][j];
						currentData_formated.push(element);
					
						if(element["value"] > max_value) max_value = element["value"];
						if(element["value"] < min_value) min_value = element["value"];
					}
				}
			}
			//console.log(displayData_formated);
		
			var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * itemSize]);
        	
        	//var colorScale = d3.scale.threshold()
       	 	//	.domain([0, 1])
       		 //	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);		
			
			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "<b>Dimension ID: </b>" + d.id
   						+"<br><b>Dimension Value: </b>" + d.value;
  					});
			
			/*d3.select("#articleProfile")
				.append("div")
				.html(
					"<b>PMID:</b> " + currentData[0].id + " (" + currentData[0].year + ")     "
					+ "<a href='https://www.ncbi.nlm.nih.gov/pubmed/" + currentData[0].id + "' target='_blank'><b>Link to PubMed</b></a><br>"
					+ "<b>Title:</b> " + currentData[0].title_raw + "<br>");
			*/
			
			/*d3.select("#vectorExplore2")
				.append("div")
				.html("<b>Semantic Space Explorer - Pairwise</b>");
			*/	
				
			/*
			d3.select("#vectorExplorer2")
				.append("input")
 	   			.attr('type','text')
 	   			.attr('id', 'selectItem1')
    			.attr('name','selectItem1')
    			.attr('value','123');
    			
    		d3.select("#vectorExplorer2")
    			.append("input")
 	   			.attr('type','text')
 	   			.attr('id', 'selectItem2')
    			.attr('name','selectItem2')
    			.attr('value','123');
    		*/	
			
			var heatmap_svg = d3.select("#vectorExplore2")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g");
        		//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        	heatmap_svg.call(tip_articleVector);	
        	
        	var cell_height = 30;
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(currentData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		//.attr('height', 20)
        		.attr('height', function(d) { 
        			return (cell_height / (max_value - min_value)) * (d.value - min_value); 
        		})
        		//.attr('y', function(d) { return yScale(d.y); })
        		.attr('y', function(d) {
        			if(chart_type == "align"){
        				if(d.y == 0){ 
        					return yScale(d.y) + (cell_height - (cell_height / (max_value - min_value)) * (d.value - min_value)); 
        					//return yScale(d.y); 
        				}
        				else {
        					return yScale(d.y) + (cell_height - 5); 
        				}
        			}
        			else{
        				if(d.y == 0){ 
        					return yScale(d.y);
        				}
        				else {
        					return yScale(d.y) + (cell_height - (cell_height / (max_value - min_value)) * (d.value - min_value)) + (cell_height - 10); 
        				}
        			}
        		})
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { return blue_to_red(d.value); })
        		.on('mouseover', function(d){
        			tip_articleVector.show(d);
        		})
      			.on('mouseout', function(d){
      				tip_articleVector.hide(d);
      			});
		}
		function compareDimObjValue(a,b) {
  			if (a.value > b.value)
    			return -1;
  			if (a.value < b.value)
    			return 1;
  			return 0;
		}
		function compareDimObjIndex(a,b) {
  			if (a.id < b.id)
    			return -1;
  			if (a.id > b.id)
    			return 1;
  			return 0;
		}

		 // (Update 2018/02/20)
        // comparison of 2 or more article vectors or 2 cluster vectors, using parallel coordinates (not in use)
        d3.select("#comparePair_pc").on("click", comparePair_pc);
		function comparePair_pc(){
			d3.select("#vectorExplore3").select("svg").remove();
			d3.select("#vectorExplore3").select(".vectorExplore3_info").remove();
			d3.select("#vectorExplore3").select(".parcoords").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore3").style("height", 0);
				return;
			}
			
			// compare between articles or between clusters
			var compare_mode = "";
			d3.selectAll(".compareMode_pc").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					compare_mode = radio.property("value");
				}
			});
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			if(compare_mode == "cluster" && (assignments.length == 0 || clusterCount < 2)){
				alert("Please run Clustering to generate at least 2 clusters before comparing clusters.");
				return;
			}
			//console.log(compare_mode);
			
			var selection = [];
			// process two IDs
			/*if(document.getElementById("compareItem1_pc").value.length < 1 || document.getElementById("compareItem2_pc").value.length < 1){
				alert("Article 1 and Article 2 will be taken as an example");
				selection.push(1);
				selection.push(2);
			}
			else{
				selection.push(parseInt(document.getElementById("compareItem1_pc").value));
				selection.push(parseInt(document.getElementById("compareItem2_pc").value));
			}*/
			
			// process the list of IDs
			var selection_str = document.getElementById("compareItems_pc").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& selection.indexOf(parseInt(element.trim())) == -1){
					selection.push(parseInt(element.trim()));
				}
			}
			if(selection.length == 0){
				if(compare_mode == "article") alert("You didn't specify any Items, Article 0 and 1 will be taken as an example");
				else alert("You didn't specify any Items, Cluster 0 and Cluster 1 will be taken as an example");
				selection.push(0);
				selection.push(1);
			}
			else if(selection.length > 20){
				alert("Pease provide no more than 20 items for comparison.");
				return;
			}
			//console.log(selection)
			
			var width = 1200;
			var height = 400;
			var itemNumber = selection.length;
			var itemDimension = 200;
			var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore3").style("height", height);
			
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "PV";
      		else if (type == "layout_tsnePA_text") vector_type = "PA";
      		else return;
      		
      		var vector_mode = "" // "" or "normArticle" or "normDim"
      		d3.selectAll(".compareValue_pc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "original") vector_mode = "";
					else vector_mode = "_" + radio.property("value");
				}
			});
      		var vector_mark = "vector_" + vector_type + vector_mode;

      		// arrange data for parallel coordinates - simply 2d array directly
      		/*
      		var currentData = []
			for(var sel in selection){
				for(var item in data){
					if(data[item].index == selection[sel]){
						currentData.push(data[item]);
						continue;
					}
				}
			} 
			var dataPC = [];
			var max_value = 0; // max_value of the vector of the first item
			var min_value = 0; // min_value of the vector of the first item
			for(var dim = 0; dim < 200; dim++){
				dataPC[dim] = new Array();
				for(var item in currentData){
					dataPC[dim].push(currentData[item][vector_mark][dim]);
					if(item == 0){
						if(currentData[item][vector_mark][dim] > max_value) max_value = currentData[item][vector_mark][dim];
						if(currentData[item][vector_mark][dim] < min_value) min_value = currentData[item][vector_mark][dim];
					}
				}
			}
			*/
			
			// arrange data for parallel coordinates.
			var dataPC;
			var dataPC_group; // group values to make several ordinal categories
			var max_value = 0; // max_value of the vector of the first item
			var min_value = 0; // min_value of the vector of the first item
			
			// prepare for PC
			d3.select("#vectorExplore3")
				.append("div")
				.attr("id", "vectorExplore3_svg")
				.attr("class", "parcoords")
				.style("height", height - 100)
				.style("width", width);	
			
			if(compare_mode == "cluster"){
				//console.log(compare_mode);
 				dataPC = [];
 				for(var i = 0; i < 200; i++){
 					var obj = {};
 					obj["DimensionID"] = "Dimension" + i;
 					if(vector_mode == ""){
 						for(sel in selection){
 							obj["Cluster" + selection[sel]] = cluster_vectors[selection[sel]][i];
 						}
 					}
 					else if(vector_mode == "_normArticle"){
 						for(sel in selection){
 							obj["Cluster" + selection[sel]] = cluster_vectors_normArticle[selection[sel]][i];
 						}
 					}
 					else{
 						for(sel in selection){
 							obj["Cluster" + selection[sel]] = cluster_vectors_normDim[selection[sel]][i];
 						}
 					}
 					dataPC.push(obj);
 				}
 				//console.log(dataPC)
 				for(var item in dataPC){
 					if(dataPC[item]["Cluster" + selection[0]] > max_value){
 						max_value = dataPC[item]["Cluster" + selection[0]];
 						//console.log("maxIndex: " + item + " ,maxValue: " + dataPC[item]["Article" + selection[0]]);
 					}
 					if(dataPC[item]["Cluster" + selection[0]] < min_value){
 						min_value = dataPC[item]["Cluster" + selection[0]];
 						//console.log("minIndex: " + item + " ,minValue: " + dataPC[item]["Article" + selection[0]]);
 					}	
 				}
 				//console.log(max_value);
 				//console.log(min_value);
 				
 				// linear color scale
				var blue_to_brown = d3.scale.linear()
  					.domain([max_value, min_value])
  					//.range(["steelblue", "brown"])
  					//.range(["#82bce3", "#f0ae75"])
  					.range(["#eb9447", "#439bd6"])
  					.interpolate(d3.interpolateLab);
  				// record dimensions of interests
  				var brushed_dimensions = [];
  				var brushed_dimensions_str = "";
 				
 				// Parellel Coordinates
				// Example: https://syntagmatic.github.io/parallel-coordinates/
				// https://github.com/syntagmatic/parallel-coordinates#parallel-coordinates
				var pc = d3.parcoords()("#vectorExplore3_svg")
  				.data(dataPC)
  				.hideAxis(["DimensionID"])
  				.bundlingStrength(0) // set bundling strength
				.smoothness(0)
				.bundleDimension("Cluster" + selection[0])
  				.color(function(d){ // quantitative color scale
  					return blue_to_brown(d["Cluster" + selection[0]]); 
  				}) 
  				.alpha(0.35)
  				.render()
  				.createAxes()
  				.brushMode("1D-axes")  // enable brushing
  				.reorderable()
    			.interactive()  // command line mode;
    			.on("brush", function(){ // on brush, get the brushed dimensions
    				//console.log(this.brushed());
    				var brushed_info = this.brushed();
    				brushed_dimensions = [];
    				brushed_dimensions_str = "";
    				for(var item in brushed_info){
    					brushed_dimensions.push(brushed_info[item]["DimensionID"].match(/\d+/));
    					brushed_dimensions_str = brushed_dimensions_str + " " + brushed_info[item]["DimensionID"].match(/\d+/);
    				}
    				d3.select("#vectorExplore3").select(".vectorExplore3_info").remove();
    				d3.select("#vectorExplore3")
						.append("div")
						.attr("class", "vectorExplore3_info")
						.style("margin", "5px")
						.style("color", "green")
						//.style("margin-left", 35)
						.html("<b>Brushed Dimensions: </b>" + brushed_dimensions_str);
    			});
    			pc.smoothness(0.2).render();	
    			pc.bundlingStrength(0.8).render();
 			}
 			else{ // if compare_mode is "article"
				d3.csv("./DERP/" + dataDirectory + "/" + vector_type + vector_mode + "_forArticle.csv", function(csv_data) {
					//console.log("./DERP/" + dataDirectory + "/" + vector_type + vector_mode + "_forArticle.csv");
 					dataPC = csv_data.map(function(d){
 						var obj = {};
 						obj["DimensionID"] = d.DimensionID;
 						for(sel in selection){
 							obj["Article" + selection[sel]] = parseFloat(d["Article" + selection[sel]]);
 						}
 						return obj;
 					});
 					//console.log(dataPC);
 					dataPC_group = csv_data.map(function(d){
 						var obj = {}
 						obj["DimensionID"] = d.DimensionID;
 						for(sel in selection){
 							var value = d["Article" + selection[sel]];
 							if(value <= -1.0) value = -1.0;
 							else if(value > -1 && value  <= -0.8) value = -0.8;
 							else if(value > -0.8 && value  <= -0.6) value = -0.6;
 							else if(value > -0.6 && value  <= -0.4) value = -0.4;
 							else if(value > -0.4 && value  <= -0.2) value = -0.2;
 							else if(value > -0.2 && value  <= 0) value = 0;
 							else if(value > 0 && value  <= 0.2) value = 0.2;
 							else if(value > 0.2 && value  <= 0.4) value = 0.4;
 							else if(value > 0.4 && value  <= 0.6) value = 0.6;
 							else if(value > 0.6 && value  <= 0.8) value = 0.8;
 							else if(value > 0.8 && value  <= 1.0) value = 1.0;
 							else value = 1.2;
 							obj["Article" + selection[sel]] = value;
 						}
 						return obj;
 					});
 					//console.log(dataPC_group);
 					for(var item in dataPC){
 						if(dataPC[item]["Article" + selection[0]] > max_value){
 							max_value = dataPC[item]["Article" + selection[0]];
 							//console.log("maxIndex: " + item + " ,maxValue: " + dataPC[item]["Article" + selection[0]]);
 						}
 						if(dataPC[item]["Article" + selection[0]] < min_value){
 							min_value = dataPC[item]["Article" + selection[0]];
 							//console.log("minIndex: " + item + " ,minValue: " + dataPC[item]["Article" + selection[0]]);
 						}
 					}
 					//console.log(max_value);
 					//console.log(min_value);
 					
 					// linear color scale
					var blue_to_brown = d3.scale.linear()
  						.domain([max_value, min_value])
  						//.range(["steelblue", "brown"])
  						//.range(["#82bce3", "#f0ae75"])
  						.range(["#eb9447", "#439bd6"])
  						.interpolate(d3.interpolateLab);
  					// record dimensions of interests
  					var brushed_dimensions = [];
  					var brushed_dimensions_str = "";
 					
 					// Parellel Coordinates
					// Example: https://syntagmatic.github.io/parallel-coordinates/
					// https://github.com/syntagmatic/parallel-coordinates#parallel-coordinates
					var pc = d3.parcoords()("#vectorExplore3_svg")
  					.data(dataPC)
  					.hideAxis(["DimensionID"])
  					.bundlingStrength(0) // set bundling strength
					.smoothness(0)
					.bundleDimension("Article" + selection[0])
  					.color(function(d){ // quantitative color scale
  						return blue_to_brown(d["Article" + selection[0]]); 
  					}) 
  					.alpha(0.35)
  					.render()
  					.createAxes()
  					.brushMode("1D-axes")  // enable brushing
  					.reorderable()
    				.interactive()  // command line mode;
    				.on("brush", function(){ // on brush, get the brushed dimensions
    					//console.log(this.brushed());
    					var brushed_info = this.brushed();
    					brushed_dimensions = [];
    					brushed_dimensions_str = "";
    					for(var item in brushed_info){
    						brushed_dimensions.push(brushed_info[item]["DimensionID"].match(/\d+/));
    						brushed_dimensions_str = brushed_dimensions_str + " " + brushed_info[item]["DimensionID"].match(/\d+/);
    					}
    					d3.select("#vectorExplore3").select(".vectorExplore3_info").remove();
    					d3.select("#vectorExplore3")
							.append("div")
							.attr("class", "vectorExplore3_info")
							.style("margin", "5px")
							.style("color", "green")
							//.style("margin-left", 35)
							.html("<b>Brushed Dimensions: </b>" + brushed_dimensions_str);
    				});
    				pc.smoothness(0.2).render();	
    				pc.bundlingStrength(0.3).render();
 				});
 			}
		}	
		
		// (Update 2018/03/08)
		// parallel coordinates, taking articles as items and taking dimensions as vertical axis
        // users can specify which articles (especially selected by clusters) to display
        // users can also specify how to rank the dimensions, and how many dimensions to display
        d3.select("#comparePair_pc2").on("click", comparePair_pc2);
		function comparePair_pc2(){
			d3.select("#vectorExplore6").select("svg").remove();
			d3.select("#vectorExplore6").select(".vectorExplore6_info").remove();
			d3.select("#vectorExplore6").select(".parcoords").remove();
			d3.select("#vectorExplore6").select(".selectDimensionAll_pc").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore6").style("height", 0);
				return;
			}
			
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "PV";
      		else if (type == "layout_tsnePA_text") vector_type = "PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			
			// Compare between articles or between clusters
			var compare_mode = "";
			d3.selectAll(".compareMode_pc2").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					compare_mode = radio.property("value");
				}
			});
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			if(compare_mode == "cluster" && (assignments.length == 0 || clusterCount < 2)){
				alert("Please run Clustering to generate at least 2 clusters before comparing clusters.");
				return;
			}
			//console.log(compare_mode);
			
			// The selection of articles
			var selection = []; // a list of article ids, or use cluster id to include all articles in the cluster
			// process the list of IDs
			var selection_str = document.getElementById("compareItems_pc2").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			if(compare_mode == "article"){
				for (var i = 0; i < selection_raw.length; i++){
					var element = selection_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
						&& selection.indexOf(parseInt(element.trim())) == -1){
						selection.push(parseInt(element.trim()));
					}
				}
				if(selection.length == 0){
					alert("You didn't specify any Items, Article 0 and 1 will be taken as an example");
					selection.push(0);
					selection.push(1);
				}
			}
			else if(compare_mode == "cluster"){
				for (var i = 0; i < selection_raw.length; i++){
					var element = selection_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null){
						for(var j in assignments){
							if(assignments[j] == parseInt(element.trim())) selection.push(parseInt(j));
						}
					}
				}
				if(selection.length == 0){
					//alert("You didn't specify any items, all articles from all clusters will be taken.");
					for(var i in assignments){
						//if(assignments[i] == 0) selection.push(parseInt(i)); // only taking articles from cluster 0
						if(true) selection.push(parseInt(i));
					}
				}
			}
			//console.log(selection)
			
			// The selection of how-to-rank-dimensions
			var rank_mode = "";
			d3.selectAll(".rankmode_pc2").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					rank_mode = radio.property("value");
				}
			});
			var clusterid = 0; // default cluster id
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;
			if(rank_mode == "variance_clusterAvg" || rank_mode == "variance_clusterDis" || rank_mode == "variance_clusterSimi" || rank_mode == "variance_clusterSimi_pca"){
				var clusterid_str = document.getElementById("rankmode_pc2_clusterid").value.trim();
				if(clusterid_str.length > 0 && clusterid_str.match(/^[0-9]+$/) != null
					&& parseInt(clusterid_str) >= 0 && parseInt(clusterid_str) < clusterCount - 1 ){
					clusterid = parseInt(clusterid_str);
				}
				else{
					alert("Please provide a valid cluster ID. Otherwise the default cluster 0 will be taken.");
					//return;
				}	
			}
			console.log(rank_mode);
			console.log(clusterid);
			
			// (Updated 2018/09) get PCA based dimension ranks
			if(rank_mode == "variance_clusterSimi_pca"){
				var vector_type2 = ""; // "_PV" or "_PA"
      			if(type == "layout_tsne_text") vector_type2 = "_PV";
      			else if (type == "layout_tsnePA_text") vector_type2 = "_PA";
      			var vector_mode2 = ""; // all dimensions ("") or only the most active cells ("_active")
      			var vector_mark2 = "vector" + vector_type2 + vector_mode2;
      			
				dataFeatureVector_inCluster = [];
				data.forEach(function(d){
					if(assignments[d.index] == clusterid){
						dataFeatureVector_inCluster.push(d[vector_mark2]);
					}
      			});
      			console.log(dataFeatureVector_inCluster);
      			PCA();
      		}
      		console.log(dimContribution_inCluster);
      		
			
			// The selection of dimensions
			var selectionDim = []; // a list of article ids, or use cluster id to include all articles in the cluster
			var selectionDim_str = document.getElementById("compareDims_pc2").value.trim().toLowerCase();
			var selectionDim_raw;
			var start = 0;
			var end = 29;
			if(selectionDim_str.includes("-")){
				start = parseInt(selectionDim_str.substr(0, selectionDim_str.indexOf("-")));
				end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
				start = Math.max(start, 0);
				end = Math.min(end, 199);
			}
			if(true){ 
				// get cluster-based (using the given cluster id) average and discrimination.
				// also get across (global) document/cluster variances if they were not calculated yet
				var dimensionVariance_clusterAvg = []; // within cluster x
				var dimensionVariance_clusterSimi = []; // within cluster x
				var dimensionVariance_clusterDis = []; // distinguish cluster x from the others
				for(var dim = 0; dim < 200; dim++){
					dimensionVariance_clusterAvg.push(cluster_vectors[clusterid][dim]);
					dimensionVariance_clusterDis.push(0);
					dimensionVariance_clusterSimi.push(Math.abs(cluster_vectors[clusterid][dim]) * (1/cluster_vectors_dis[clusterid][dim])); // weighted by the average absolute value
      			}
				for(var i = 0; i < clusterCount; i++){
					if(i == clusterid){
						continue;
					}
      				for(var dim = 0; dim < 200; dim++){
      					dimensionVariance_clusterDis[dim] += cluster_size[i] * Math.pow((cluster_vectors[i][dim] - cluster_vectors[clusterid][dim]), 2); // weight clusters using their size
      				}
      			}
      			for(var dim = 0; dim < 200; dim++){
					dimensionVariance_cluster[dim] = Math.sqrt(dimensionVariance_cluster[dim]/(clusterCount - 1));
				}
				
				var dataAll_rank = [];
				for(var dim = 0; dim < 200; dim++){		
					var obj = {};
					obj["dim"] = dim;
					obj["mean"] = dimensionMean[dim];
					obj["max"] = dimensionMax[dim];
					obj["min"] = dimensionMin[dim];
					obj["variance"] = dimensionVariance[dim]; // globally across document variance
					obj["variance_pca"] = dimContribution_globalDoc[dim]; // globally across document variance - pace based method
					obj["variance_cluster"] = dimensionVariance_cluster[dim]; // globally across cluster variance
					obj["clusterAvg"] = dimensionVariance_clusterAvg[dim]; // cluster-based (within) average
					obj["clusterDis"] = dimensionVariance_clusterDis[dim]; // cluster-based discrimination: cluster x vs. all other clusters
					obj["clusterSimi"] = dimensionVariance_clusterSimi[dim]; // cluster-based (within) similarity
					if(rank_mode == "variance_clusterSimi_pca") obj["clusterSimi_pca"] = dimContribution_inCluster[dim]; // cluster-based (within) similarity - pca based method, find the dimensions contributing less to in-cluster PCs
					dataAll_rank.push(obj);
				}
				//console.log(dataAll_rank);
					
				if(rank_mode == "index"){
					dataAll_rank.sort(function(a,b) {return (a.dim > b.dim) ? 1 : ((b.dim > a.dim) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance"){
					dataAll_rank.sort(function(a,b) {return (a.variance < b.variance) ? 1 : ((b.variance < a.variance) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance_pca"){
					dataAll_rank.sort(function(a,b) {return (a.variance_pca < b.variance_pca) ? 1 : ((b.variance_pca < a.variance_pca) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance_cluster"){
					dataAll_rank.sort(function(a,b) {return (a.variance_cluster < b.variance_cluster) ? 1 : ((b.variance_cluster < a.variance_cluster) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}					
				}
				else if(rank_mode == "variance_cluster_pca"){
					dataAll_rank.sort(function(a,b) {return (a.variance_cluster_pca < b.variance_cluster_pca) ? 1 : ((b.variance_cluster_pca < a.variance_cluster_pca) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}					
				}
				else if(rank_mode == "variance_clusterAvg"){
					dataAll_rank.sort(function(a,b) {return (a.clusterAvg < b.clusterAvg) ? 1 : ((b.clusterAvg < a.clusterAvg) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance_clusterDis"){
					dataAll_rank.sort(function(a,b) {return (a.clusterDis < b.clusterDis) ? 1 : ((b.clusterDis < a.clusterDis) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance_clusterSimi"){
					dataAll_rank.sort(function(a,b) {return (a.clusterSimi < b.clusterSimi) ? 1 : ((b.clusterSimi < a.clusterSimi) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "variance_clusterSimi_pca"){
					dataAll_rank.sort(function(a,b) {return (a.clusterSimi_pca > b.clusterSimi_pca) ? 1 : ((b.clusterSimi_pca > a.clusterSimi_pca) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
			}
			
			/*else if(selectionDim_str.includes("top")){ // top x dimensions (ranked by global dimension variances)
				if(!(selectionDim_str.includes("-"))){ // e.g. top20
					if(dimensions_rankByVariance.length != 0){
						var top = parseInt(selectionDim_str.match(/\d+/)[0]);
						//console.log("top: " + top);
						for(var i = 0; i < top; i++) selectionDim.push(dimensions_rankByVariance[i]);
					}
				}
				else { // e.g. top0-19
					var start = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("top") + 3, selectionDim_str.indexOf("-")));
					var end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
					start = Math.max(start, 0);
					end = Math.min(end, 199);
					for (var i = start; i <= end; i++) selectionDim.push(dimensions_rankByVariance[i]);
				}
			}
			else if(selectionDim_str.includes("bottom")){ // bottom x dimensions (ranked by global dimension variances)
				if(!(selectionDim_str.includes("-"))){ // e.g. bottom20
					if(dimensions_rankByVariance.length != 0){
						var bottom = parseInt(selectionDim_str.match(/\d+/)[0]);
						//console.log("bottom: " + bottom);
						for(var i = 0; i < bottom; i++) selectionDim.push(dimensions_rankByVariance[200-bottom+i]);
					}
				}
				else { // e.g. bottom0-19
					var start = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("bottom") + 6, selectionDim_str.indexOf("-")));
					var end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
					start = Math.max(start, 0);
					end = Math.min(end, 199);
					for (var i = start; i <= end; i++) selectionDim.push(dimensions_rankByVariance[199-end+i]);
				}
			}
			else if(selectionDim_str.includes("-")){
				var start = parseInt(selectionDim_str.substr(0, selectionDim_str.indexOf("-")));
				var end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
				start = Math.max(start, 0);
				end = Math.min(end, 199);
				for (var i = start; i <= end; i++){
					selectionDim.push(i);
				}
			}
			else{
				if (selectionDim_str.includes(",")){ // use "," as the delimiter
					selectionDim_raw = selectionDim_str.split(",");
				}
				else{
					selectionDim_raw = selectionDim_str.split(" "); // use " " as the delimite
				}
				for (var i = 0; i < selectionDim_raw.length; i++){
					var element = selectionDim_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < 200 
						&& selectionDim.indexOf(parseInt(element.trim())) == -1){
						selectionDim.push(parseInt(element.trim()));
					}
				}
			}*/
			//console.log(selectionDim)
			
			var width = 1200;
			var height = 360;
      		d3.select("#vectorExplore6").style("height", height);
      		
      		var vector_mode = "" // "" or "normArticle" or "normDim"
      		d3.selectAll(".compareValue_pc2").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "original") vector_mode = "";
					else vector_mode = "_" + radio.property("value");
				}
			});
      		var vector_mark = "vector_" + vector_type + vector_mode;

			// arrange data for parallel coordinates.
			var dataPC = []; // array of object - for parallel coordinates
			var dataArray = []; // array of array - for line charts
			var max_value = 0; // max_value of the vector of the first item
			var min_value = 0; // min_value of the vector of the first item
			
			// allow users to select/unselect all dimensions being displayed
			// (updated 2018/09) allow users to apply all displayed dimensions to the feature selection box via union, intersection, and deduction
  			if(true){
  				var new_div = d3.select("#vectorExplore6")
        			.append("div")
        			.attr("class", "selectDimensionAll_pc")
        			.style("margin-top", 10);
        		
        		// deduction
        		var new_button3 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_pc_button3")
          		.attr("value", "Deduction")
          		.style("float", "right")
          		.text("   Deduction")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return !selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
        			          		
          		var new_button2 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_pc_button2")
          		.attr("value", "Intersection")
          		.style("float", "right")
          		.text("   Intersection")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          		
          		var new_button1 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_pc_button1")
          		.attr("value", "Union")
          		.style("float", "right")
          		.text("   Union")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			for(var dim in selectionDim){
          				if(!selectedDimensions.includes(selectionDim[dim])) selectedDimensions.push(selectionDim[dim]);
          			}
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          	}
			
			// prepare for PC
			d3.select("#vectorExplore6")
				.append("div")
				.attr("id", "vectorExplore6_svg")
				.attr("class", "parcoords")
				.style("height", height - 120)
				.style("width", width - 10)
				.style("margin-left", 10)
				.style("margin-top", 30);	
				
			// group/cluster map to e.g. force the green cluster to be cluster #0
			groupMap = [2, 1, 0, 3, 5, 7, 4, 6];
			groupMap_verse = [2, 1, 0, 3, 6, 4, 7, 5];
			
 			if(compare_mode == "article" || compare_mode == "cluster"){ // if compare_mode is "article"
				d3.csv("./DERP/" + dataDirectory + "/" + vector_type + vector_mode + "_forDim.csv", function(csv_data) {
					//console.log("./DERP/" + dataDirectory + "/" + vector_type + vector_mode + "_forArticle.csv");
 					/*dataPC = csv_data.map(function(d, i){
 						var obj = {};
 						obj["ArticleID"] = d.ArticleID;
 						for(sel in selectionDim){
 							obj["Dimension" + selectionDim[sel]] = parseFloat(d["Dimension" + selectionDim[sel]]);
 						}
 						return obj;
 					});*/
 					for(var i in csv_data){
 						if(selection.indexOf(parseInt(i)) == -1) continue;
 						var obj = {};
 						var arr = [];
 						obj["ArticleID"] = csv_data[i].ArticleID;
 						for(var sel in selectionDim){
 							obj["D" + selectionDim[sel]] = parseFloat(csv_data[i]["Dimension" + selectionDim[sel]]);
 							arr.push(csv_data[i]["Dimension" + selectionDim[sel]]);
 						}
 						if(assignments.length > 0){
 							//obj["group"] = assignments[parseInt(i)];
 							//obj["cluster"] = groupMap[assignments[parseInt(i)]];
 							obj["cluster"] = assignments[parseInt(i)];
 						}
 						else{
 							obj["cluster"] = 0;
 						}
 						dataPC.push(obj);
 						dataArray.push(arr);
 					}
 					//console.log(dataPC);
 					//console.log(dataArray);
 					for(var item in dataPC){
 						for(var dim in selectionDim){
 							if(dataPC[item]["D" + selectionDim[dim]] > max_value){
 								max_value = dataPC[item]["D" + selectionDim[dim]];
 								//console.log("maxIndex: " + item + " ,maxValue: " + dataPC[item]["Article" + selection[0]]);
 							}
 							if(dataPC[item]["D" + selectionDim[dim]] < min_value){
 								min_value = dataPC[item]["D" + selectionDim[dim]];
 								//console.log("minIndex: " + item + " ,minValue: " + dataPC[item]["Article" + selection[0]]);
 							}
 						}
 					}
 					//console.log(max_value);
 					//console.log(min_value);
 					
 					// add two virtual articles, so that each dimension axis has the same value range
 					var max_obj = {};
 					var min_obj = {};
 					max_obj["ArticleID"] = "max";
 					min_obj["ArticleID"] = "min";
 					for(var sel in selectionDim){
 						max_obj["D" + selectionDim[sel]] = max_value;
 						min_obj["D" + selectionDim[sel]] = min_value;
 					}
 					dataPC.push(max_obj);
 					dataPC.push(min_obj);
 					//console.log(dataPC);
 					
 					// linear color scale
					var blue_to_brown = d3.scale.linear()
  						.domain([max_value, min_value])
  						//.range(["steelblue", "brown"])
  						//.range(["#82bce3", "#f0ae75"])
  						.range(["#eb9447", "#439bd6"])
  						.interpolate(d3.interpolateLab);
  					// record articles of interests
  					var brushed_articles = [];
  					var brushed_articles_str = "";
  					
  					//var d3_category10_copy = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
					//var d3_category10_transparent = ["rgba(31, 119, 180, 0.3)", "rgba(255, 127, 14, 0.3)", "rgba(44, 160, 44, 0.3)", "rgba(214, 39, 40, 0.3)", "rgba(148, 103, 189, 0.3)", "rgba(140, 86, 75, 0.3)", "rgba(227, 119, 194, 0.3)", "rgba(127, 127, 127, 0.3)", "rgba(188, 189, 34, 0.3)", "rgba(23, 190, 207, 0.3)"];
					//var cluster_color_new = d3_category10_transparent;
 					
 					// Parellel Coordinates
					// Example: https://syntagmatic.github.io/parallel-coordinates/
					// https://github.com/syntagmatic/parallel-coordinates#parallel-coordinates
					var pc = d3.parcoords()("#vectorExplore6_svg")
  					.data(dataPC)
  					.hideAxis(["ArticleID"])
  					.bundlingStrength(0) // set bundling strength
					.smoothness(0)
					.bundleDimension("D" + selectionDim[0])
  					.color(function(d){ // quantitative color scale
  						/*return blue_to_brown(d["D" + selectionDim[0]]); */
  						if(d["ArticleID"] == "max" || d["ArticleID"] == "min") return "#ffffff";
  						//return cluster_color[groupMap_verse[d["cluster"]] % 10];
  						return cluster_color[d["cluster"] % 10];
  					}) 
  					.alpha(0.35)
  					.render()
  					.createAxes()
  					.brushMode("1D-axes")  // enable brushing
  					.reorderable()
    				.interactive()  // command line mode;
    				.on("brush", function(){ // on brush, get the brushed dimensions
    					//console.log(this.brushed());
    					var brushed_info = this.brushed();
    					//console.log(brushed_info);
    					brushed_articles = [];
    					brushed_articles_str = "";
    					for(var item in brushed_info){
    						brushed_articles.push(brushed_info[item]["ArticleID"].match(/\d+/));
    						brushed_articles_str = brushed_articles_str + " " + brushed_info[item]["ArticleID"].match(/\d+/);
    					}
    					d3.select("#vectorExplore6").select(".vectorExplore6_info").remove();
    					d3.select("#vectorExplore6")
							.append("div")
							.attr("class", "vectorExplore6_info")
							.style("margin", "5px")
							.style("color", "green");
							//.style("margin-left", 35)
							//.html("<b>Brushed Articles: </b>" + brushed_articles_str);
    				});
    				pc.smoothness(0.1).render();	
    				pc.bundlingStrength(0.3).render();
    				
    				var blue_to_red = d3.scale.threshold()
    				.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    				.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);	
					
					// click label to trigger function: enable users to explore/select the specific dimension
  					pc.svg.call(tip_dim);	
  					pc.svg.selectAll(".dimension")
    				.on("click", function(d){
    					var dim = parseInt(d.substring(1)); // "D42" -> "42"
    					currentDimension = dim;
    					tip_dim.show(dim);
    					//console.log("click" + dim);
    					var index = [];  // record highly responsive articles
      					var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    					var value_threshold = Quartile(dimensionVector[dim], 0.9);
    					
    					objects.selectAll(".dot")
    						.style("fill", function(n){
    							var article_value = n[vector_mark][dim];
								if(article_value >= value_threshold){
									//console.log(article_value);
									index.push(n.index);
									keywords_list.push(n.keyword_rake);
								}
    							return blue_to_red(n[vector_mark][dim]);
    						})
    						.attr("stroke-width", 0.1)
    						.attr("r", 5);	
    					
    					// generate keywords for the selected dimension (highlighted articles)
    					keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
						updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    					})
    				.selectAll(".label")
    				.style("cursor", "pointer");
 				
 					// draw the line chart
					/*
					var margin = {top: 10, right: 0, bottom: 10, left: 40};
					var x = d3.scale.linear().range([0, 1200]).domain([0, selectionDim.length]);
					var y = d3.scale.linear().range([170, 20]).domain([min_value, max_value]);  			
    				var svg = d3.select("#vectorExplore6")
						.append("svg")
        				.attr("width", 1200 + margin.left)
        				.attr("height", 220 + margin.top + margin.bottom)
        				.attr("class", "lineChart_svg")	
        				.append("g")
        				.attr("transform", 
              			"translate(" + margin.left + "," + margin.top + ")");
        			// Define the axes
					var xAxis = d3.svg.axis().scale(x)
   						.orient("bottom").ticks(5);
					var yAxis = d3.svg.axis().scale(y)
   			 			.orient("left").ticks(5);
        			// Add the X Axis
    				svg.append("g")
        				.attr("class", "x axis")
        				.attr("transform", "translate(0," + height + ")")
        				.call(xAxis);
   		 			// Add the Y Axis
    				svg.append("g")
        				.attr("class", "y axis")
        				//.attr("transform", "translate(0, 0)")
        				.call(yAxis);
        				
        			var tip = d3.tip()
  						.attr('class', 'd3-tip')
  						.offset([-10, 0])
  						.html(function(d) {
   							return "<b>" + d.dim + "</b>";
  						});
  					svg.call(tip);				
        	
        			// Define and add the line
        			var lines = [];
        			for(var k = 0; k < dataArray.length; k++){
        				var currentLine = d3.svg.line()
        					.x(function(d, i) { return x(i); })
    						.y(function(d, i) { return y(d); });
    					svg.append("path")
        				.attr("class", "lineChart_line")
        				.attr("d", currentLine(dataArray[k]));	
        			}
        			*/
        		});	
 			}
		}
		
		// (Update 2018/08/20)
		// heatmaps, taking articles as rows and taking dimensions as columns
        // users can specify which articles (can be selected by clusters) to compare
        // users can also specify how to rank the dimensions, and how many dimensions to display
        d3.select("#compareMultiple").on("click", compareMultiple);
		function compareMultiple(){
			d3.select("#vectorExplore7").select("svg").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_mul").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_pair").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore7").style("height", 0);
				return;
			}
			
			// Compare between articles or between clusters
			var compare_mode = "";
			d3.selectAll(".compareMode_hm").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					compare_mode = radio.property("value");
				}
			});
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			if(compare_mode == "cluster" && (assignments.length == 0 || clusterCount < 2)){
				alert("Please run Clustering to generate at least 2 clusters before comparing clusters.");
				return;
			}
			//console.log(compare_mode);
			
			// The selection of articles
			var selection = []; // a list of article ids, or use cluster id to include all articles in the cluster
			var selection_ref = []; // a list of article ids for reference (updated 2018/08)
			
			// process the list of IDs
			var selection_str = document.getElementById("compareItems_hm").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			
			var selection_str_ref = document.getElementById("compareItems_hm_ref").value;
			var selection_raw_ref;
			if (selection_str_ref.includes(",")){ // use "," as the delimiter
				selection_raw_ref = selection_str_ref.split(",");
			}
			else{
				selection_raw_ref = selection_str_ref.split(" "); // use " " as the delimite
			}
			
			if(compare_mode == "article"){
				for (var i = 0; i < selection_raw.length; i++){
					var element = selection_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
						&& selection.indexOf(parseInt(element.trim())) == -1){
						selection.push(parseInt(element.trim()));
					}
				}
				if(selection.length == 0){
					alert("You didn't specify any Items, Article 0,1,2,3 will be taken as examples");
					selection.push(0);
					selection.push(1);
					selection.push(2);
					selection.push(3);
				}
				
				for (var i = 0; i < selection_raw_ref.length; i++){
					var element = selection_raw_ref[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
						&& selection_ref.indexOf(parseInt(element.trim())) == -1){
						selection_ref.push(parseInt(element.trim()));
					}
				}
				
			}
			else if(compare_mode == "cluster"){
				for (var i = 0; i < selection_raw.length; i++){
					var element = selection_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null){
						for(var j in assignments){
							if(assignments[j] == parseInt(element.trim())) selection.push(parseInt(j));
						}
					}
				}
				if(selection.length == 0){
					alert("You didn't specify any Items, Cluster 0 will be taken as an example");
					selection.push(0);
				}
			}
			//console.log(selection)
			
			// The selection of how-to-rank-dimensions
			var rank_mode = "";
			d3.selectAll(".ifRank_hm").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					rank_mode = radio.property("value");
				}
			});
			var articleid = 0; // default article id
			/*var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;*/
			if(rank_mode == "value"){
				var articleid_str = document.getElementById("ifRank_hm_id").value.trim();
				if(articleid_str.length > 0 && articleid_str.match(/^[0-9]+$/) != null
					&& parseInt(articleid_str) >= 0 && parseInt(articleid_str) < data.length){
					articleid = parseInt(articleid_str);
				}
				else{
					alert("You didn't provide an article ID, the default article 0 will be used.");
					articleid = 0;
				}	
			}
			//console.log(rank_mode);
			//console.log(articleid);
			
			// The selection of dimensions
			var selectionDim = [];
			var selectionDim_str = document.getElementById("compareDims_hm").value.trim().toLowerCase();
			var selectionDim_raw;
			var start = 0;
			var end = 29;
			if(selectionDim_str.includes("-")){
				start = parseInt(selectionDim_str.substr(0, selectionDim_str.indexOf("-")));
				end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
				start = Math.max(start, 0);
				end = Math.min(end, 199);
			}
			
			// The rank of dimensions
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			if(true){ 
				// get cluster-based (using the given cluster id) average and discrimination.
				// also get across (global) document/cluster variances if they were not calculated yet
				var dimensionVariance_articleSimi = [];
				var dimensionVariance_articleDis = [];
				var dimensionVariance_articleAvg = [];
				var dimensionVariance_articleValue = [];
				for(var dim = 0; dim < 200; dim++){
					dimensionVariance_articleSimi.push(0);
					dimensionVariance_articleDis.push(0);
					dimensionVariance_articleAvg.push(0);
					dimensionVariance_articleValue.push(0);
				}
				for(var dim = 0; dim < 200; dim++){
					for(i = 0; i < selection.length; i++){
						dimensionVariance_articleAvg[dim] += data[selection[i]][vector_mark][dim];
						if(selection[i] == articleid) dimensionVariance_articleValue[dim] = data[selection[i]][vector_mark][dim];
					}
					dimensionVariance_articleAvg[dim] = dimensionVariance_articleAvg[dim]/selection.length;
					for(i = 0; i < selection.length; i++){
						dimensionVariance_articleDis[dim] += Math.pow((data[selection[i]][vector_mark][dim] - dimensionVariance_articleAvg[dim]), 2);
					}
					dimensionVariance_articleDis[dim] = Math.sqrt(dimensionVariance_articleDis[dim]/selection.length);
					dimensionVariance_articleSimi[dim] = (1/dimensionVariance_articleDis[dim]);
				}
				
				var dataAll_rank = [];
				for(var dim = 0; dim < 200; dim++){		
					var obj = {};
					obj["dim"] = dim;
					obj["simi"] = Math.abs(dimensionVariance_articleAvg[dim]) * dimensionVariance_articleSimi[dim];
					obj["dis"] = dimensionVariance_articleDis[dim];
					obj["avg"] = dimensionVariance_articleAvg[dim];
					obj["rank_value"] = dimensionVariance_articleValue[dim];
					dataAll_rank.push(obj);
					console.log(obj);
				}
				//console.log(dataAll_rank);
					
				if(rank_mode == "index"){
					dataAll_rank.sort(function(a,b) {return (a.dim > b.dim) ? 1 : ((b.dim > a.dim) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "simi"){
					dataAll_rank.sort(function(a,b) {return (a.simi < b.simi) ? 1 : ((b.simi < a.simi) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "dis"){
					dataAll_rank.sort(function(a,b) {return (a.dis < b.dis) ? 1 : ((b.dis < a.dis) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}					
				}
				else if(rank_mode == "avg"){
					dataAll_rank.sort(function(a,b) {return (a.avg < b.avg) ? 1 : ((b.avg < a.avg) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "value"){
					dataAll_rank.sort(function(a,b) {return (a.rank_value < b.rank_value) ? 1 : ((b.rank_value < a.rank_value) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
			}
			
			// Handle the data to display
			var displayData = data.filter(function(d){ return selection.includes(d.index) == true;} ); // the documents whose vectors will be displayed as a heatmap
			var displayData_ref = data.filter(function(d){ return selection_ref.includes(d.index) == true;} ); // the documents whose vectors will be displayed as a heatmap
			var itemNumber = displayData.length;
			var itemNumber_ref = displayData_ref.length;
			//console.log(itemNumber);
			//console.log(itemNumber_ref);
			
			var itemDimension = end - start + 1;
      		var margin = {top: 20, right: 0, bottom: 20, left: 10};
      		var width = 1200;
      		var height = 20 * (itemNumber + itemNumber_ref + 7);
      		var itemSize = (width-50)/itemDimension;
      		var cellSize = itemSize - 1;	
      		//d3.select("#vectorExplore7").style("height", Math.min(300, height + 60));
      		d3.select("#vectorExplore7").style("height", height + 55);
		
			var displayData_formated = []; // the postion and value of each heatmap-cell
			var max_value = 0;
			var min_value = 0;
			for(var i = 0; i < itemNumber; i++){
				//for(j = 0; j < displayData[i][vector_mark].length; j++){
				for(var dim = 0; dim < selectionDim.length; dim++){
					element = {};
					element["x"] = dim;
					element["y"] = i;
					element["value"] = displayData[i][vector_mark][selectionDim[dim]];
					displayData_formated.push(element);
					if(element["value"] > max_value) max_value = element["value"];
					if(element["value"] < min_value) min_value = element["value"];
				}
			}
			//console.log(displayData_formated);
			if(itemNumber_ref > 0){
				// add a breaking line to separate the reference articles 
				element = {};
				element["x"] = dim;
				element["y"] = itemNumber;
				element["value"] = 0;
				displayData_formated.push(element);
				// include the reference articles
				for(var i = itemNumber + 1; i < itemNumber + itemNumber_ref + 1; i++){
					//for(j = 0; j < displayData_ref[i][vector_mark].length; j++){
					for(var dim = 0; dim < selectionDim.length; dim++){
						element = {};
						element["x"] = dim;
						element["y"] = i;
						element["value"] = displayData_ref[i - itemNumber - 1][vector_mark][selectionDim[dim]];
						displayData_formated.push(element);
					}
				}
			}
			//console.log(displayData_formated);
			
			var labels_data = []; // the dimension labels to display as headers
			for(var dim = 0; dim < selectionDim.length; dim++){
				element = {};
				element["x"] = dim;
				element["y"] = 0;
				element["dim"] = selectionDim[dim];
				labels_data.push(element);
			}
		
			var x_elements = d3.set(displayData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(displayData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (20+2)]); 
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);			
			
			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
  						var articleID = d.y < itemNumber ? displayData[d.y]["index"] : displayData_ref[d.y - itemNumber - 1]["index"];
   						return "<b>Article " + articleID + "</b>"
   						+ "<br><b>Dimension ID: </b>" + selectionDim[d.x]
   						+"<br><b>Dimension Value: </b>" + d.value;
  					});
  					
			// allow users to select/unselect all dimensions being displayed
  			if(true){
  				var new_div = d3.select("#vectorExplore7")
        			.append("div")
        			.attr("class", "selectDimensionAll_mul")
        			.style("margin-top", 10);
        		
        		var new_button3 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_mul_button3")
          		.attr("value", "Deduction")
          		.style("float", "right")
          		.text("   Deduction")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return !selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
        		        		
          		var new_button2 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_mul_button2")
          		.attr("value", "Intersection")
          		.style("float", "right")
          		.text("   Intersection")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          		
          		var new_button1 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_mul_button1")
          		.attr("value", "Union")
          		.style("float", "right")
          		.text("   Union")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			for(var dim in selectionDim){
          				if(!selectedDimensions.includes(selectionDim[dim])) selectedDimensions.push(selectionDim[dim]);
          			}
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          	}
          	
			var heatmap_svg = d3.select("#vectorExplore7")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g")
        		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        		
        	heatmap_svg.call(tip_articleVector);
        	heatmap_svg.call(tip_dim2);		
        	
        	var labels = heatmap_svg.selectAll('.heatmap_label')
        		.data(labels_data)
        		.enter().append('g').append('text')
        		.attr('class', 'heatmap_label')
        		.attr('width', cellSize)
        		.attr('height', 20)
        		.attr('y', function(d) { return yScale(d.y) + 10; })
        		.attr('x', function(d) { return xScale(d.x) + cellSize/3; })
        		.text(function(d){return "D" + d.dim;})
        		.attr("font-family", "sans-serif")
            	.attr("font-size", "11px")
            	.style("line-height", "1.5")
            	.style("cursor", "pointer")
            	.attr("fill", "black")
            	.on('click', function(d){
      				tip_articleVector.hide(d);
      				currentDimension = d.dim;
      				tip_dim2.show(d.dim);
      				var index = [];  // record highly responsive articles
      				var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    				var value_threshold = Quartile(dimensionVector[d.dim], 0.9);
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						var article_value = n[vector_mark][d.dim];
							if(article_value >= value_threshold){
								//console.log(article_value);
								index.push(n.index);
								keywords_list.push(n.keyword_rake);
							}
    						return blue_to_red(n[vector_mark][d.dim]);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);	
    					
    				// generate keywords for the selected dimension (highlighted articles)
    				keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
					updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    				})
    			.selectAll(".label")
    			.style("cursor", "pointer");	
        
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(displayData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		//.attr('height', function(d) { 
        		//	return (20 / (max_value - min_value)) * (d.value - min_value); 
        		//})
        		.attr('height', function(d){
        			if(d.y == itemNumber) return 5;
        			else return 18;
        		})
        		.attr('y', function(d) { return yScale(d.y) + 15; })
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { 
        			if(d.y == itemNumber) return "white"; 
        			else return blue_to_red(d.value); 
        		})
        		.on('mouseover', function(d){
        			if(d.y == itemNumber) return;
        			tip_articleVector.show(d);
        			d3.select(this).moveToFront();
        			heatmap_svg.selectAll('.cell')
        				.filter(function(c){ return c.x == d.x; })
        				.attr('width', cellSize)
        				.attr('height', 25)
        				.moveToFront();
        				/*
        				.attr("stroke-width", function(c){
        					if(c.x == d.x) return 2;
        					else return 0;
        				})
        				.attr("stroke", function(c){
        					if(c.x == d.x) return "#F7DC6F";
        				});*/
        		})
      			.on('mouseout', function(d){
      				if(d.y == itemNumber) return;
      				tip_articleVector.hide(d);
      				heatmap_svg.selectAll('.cell')
        				.attr('width', cellSize)
        				.attr('height', 18);
        				//.attr("stroke-width", 0);
      			});
		}
		
		// (Update 2018/08/20)
		// Pairwise comparison of two articles using aligned bar charts
		d3.select("#comparePair_new").on("click", comparePair_new);
		function comparePair_new(){
			d3.select("#vectorExplore7").select("svg").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_mul").remove();
			d3.select("#vectorExplore7").select(".selectDimensionAll_pair").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore7").style("height", 0);
				return;
			}
			
			// compare between articles or between clusters
			var compare_mode = "";
			d3.selectAll(".compareMode_hm").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					compare_mode = radio.property("value");
				}
			});
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			if(compare_mode == "cluster" && (assignments.length == 0 || clusterCount < 2)){
				alert("Please run Clustering to generate at least 2 clusters before comparing clusters.");
				return;
			}
			//console.log(compare_mode);
			
			// the type of bar charts
			var chart_type = "";
			d3.selectAll(".compareChart").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					chart_type = radio.property("value");
				}
			});
			//console.log(chart_type);
			
			// the selected article pairs or cluster pairs
			var selection = [];
			if(document.getElementById("compareItem1").value.length < 1 || document.getElementById("compareItem2").value.length < 1){
				if(compare_mode == "article") alert("Article 0 and Article 1 will be taken as an example");
				//else alert("Cluster 0 and Cluster 1 will be taken as an example");
				selection.push(0);
				selection.push(1);
			}
			else{
				selection.push(parseInt(document.getElementById("compareItem1").value));
				selection.push(parseInt(document.getElementById("compareItem2").value));
			}
			//console.log(selection);
			
			// The selection of how-to-rank-dimensions
			var rank_mode = "";
			d3.selectAll(".ifRank_hm").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					rank_mode = radio.property("value");
				}
			});
			var articleid = 0; // default article id
			/*var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;*/
			if(rank_mode == "value"){
				var articleid_str = document.getElementById("ifRank_hm_id").value.trim();
				if(articleid_str.length > 0 && articleid_str.match(/^[0-9]+$/) != null
					&& parseInt(articleid_str) >= 0 && parseInt(articleid_str) < data.length){
					articleid = parseInt(articleid_str);
				}
				else{
					alert("You didn't provide an article ID, the default article 0 will be used.");
					articleid = 0;
				}	
			}
			//console.log(rank_mode);
			//console.log(articleid);
			
			// The selection of dimensions
			var selectionDim = [];
			var selectionDim_str = document.getElementById("compareDims_hm").value.trim().toLowerCase();
			var selectionDim_raw;
			var start = 0;
			var end = 30;
			if(selectionDim_str.includes("-")){
				start = parseInt(selectionDim_str.substr(0, selectionDim_str.indexOf("-")));
				end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
				start = Math.max(start, 0);
				end = Math.min(end, 199);
			}
			
			// The rank of dimensions
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			if(true){ 
				// get cluster-based (using the given cluster id) average and discrimination.
				// also get across (global) document/cluster variances if they were not calculated yet
				var dimensionVariance_articleSimi = [];
				var dimensionVariance_articleDis = [];
				var dimensionVariance_articleAvg = [];
				var dimensionVariance_articleValue = [];
				for(var dim = 0; dim < 200; dim++){
					dimensionVariance_articleSimi.push(0);
					dimensionVariance_articleDis.push(0);
					dimensionVariance_articleAvg.push(0);
					dimensionVariance_articleValue.push(0);
				}
				for(var dim = 0; dim < 200; dim++){
					for(i = 0; i < selection.length; i++){
						dimensionVariance_articleAvg[dim] += data[selection[i]][vector_mark][dim];
						if(selection[i] == articleid) dimensionVariance_articleValue[dim] = data[selection[i]][vector_mark][dim];
					}
					dimensionVariance_articleAvg[dim] = dimensionVariance_articleAvg[dim]/selection.length;
					for(i = 0; i < selection.length; i++){
						dimensionVariance_articleDis[dim] += Math.pow((data[selection[i]][vector_mark][dim] - dimensionVariance_articleAvg[dim]), 2);
					}
					dimensionVariance_articleDis[dim] = Math.sqrt(dimensionVariance_articleDis[dim]/selection.length);
					dimensionVariance_articleSimi[dim] = 1 - dimensionVariance_articleDis[dim];
				}
				
				var dataAll_rank = [];
				for(var dim = 0; dim < 200; dim++){		
					var obj = {};
					obj["dim"] = dim;
					obj["simi"] = Math.abs(dimensionVariance_articleAvg[dim]) * dimensionVariance_articleSimi[dim];
					obj["dis"] = dimensionVariance_articleDis[dim];
					obj["avg"] = dimensionVariance_articleAvg[dim];
					obj["rank_value"] = dimensionVariance_articleValue[dim];
					dataAll_rank.push(obj);
				}
				//console.log(dataAll_rank);
					
				if(rank_mode == "index"){
					dataAll_rank.sort(function(a,b) {return (a.dim > b.dim) ? 1 : ((b.dim > a.dim) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "simi"){
					dataAll_rank.sort(function(a,b) {return (a.simi < b.simi) ? 1 : ((b.simi < a.simi) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "dis"){
					dataAll_rank.sort(function(a,b) {return (a.dis < b.dis) ? 1 : ((b.dis < a.dis) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}					
				}
				else if(rank_mode == "avg"){
					dataAll_rank.sort(function(a,b) {return (a.avg < b.avg) ? 1 : ((b.avg < a.avg) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
				else if(rank_mode == "value"){
					dataAll_rank.sort(function(a,b) {return (a.rank_value < b.rank_value) ? 1 : ((b.rank_value < a.rank_value) ? -1 : 0);} );
					for(var i = start; i <= end; i++){
						selectionDim.push(dataAll_rank[i]["dim"]);
					}
				}
			}
			
			// arrange the data for visualization
			//var currentData = data.filter(function(d){ return selection.indexOf(d.index) != -1;} ); // the documents whose vectors will be displayed as a heatmap
			var currentData = []
			if(compare_mode == "article"){
				for(var sel in selection){
					if(parseInt(selection[sel]) < 0 || parseInt(selection[sel]) >= data.length){
						alert("Invalid Article ID: " + selection[sel]);
						return;
					}
					for(var item in data){
						if(data[item].index == selection[sel]){
							currentData.push(data[item]);
							continue;
						}
					}
				}
			}
			else{ // not supporting cluster mode
			}

			var width = 1200;
			var height = 220;
			var itemNumber = currentData.length;
			var itemDimension = end - start + 1;
			var itemSize = width/itemDimension;
      		var cellSize = itemSize - 1;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore7").style("height", height + 45);
      	
      		var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
      		
			// format elements to visualize in the bar chart
			var currentData_formated = []; // the postion and value of each heatmap-cell
			var max_value = 0;
			var min_value = 0;
			for(var i = 0; i < itemNumber; i++){
				if(compare_mode == "article"){
					for(var dim = 0; dim < selectionDim.length; dim++){
						element = {};
						element["y"] = i;
						element["x"] = dim;
						element["id"] = selectionDim[dim];
						element["value"] = currentData[i][vector_mark][selectionDim[dim]];
						currentData_formated.push(element);
						
						if(element["value"] > max_value) max_value = element["value"];
						if(element["value"] < min_value) min_value = element["value"];
					}
				}
				else{ // not supporting cluster mode
				}
			}
			//console.log(displayData_formated);
			var labels_data = []; // the dimension labels to display as headers
			for(var dim = 0; dim < selectionDim.length; dim++){
				element = {};
				element["x"] = dim;
				element["y"] = 0;
				element["dim"] = selectionDim[dim];
				labels_data.push(element);
			}
		
			var x_elements = d3.set(currentData_formated.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(currentData_formated.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (40+2)]);
        	
        	//var colorScale = d3.scale.threshold()
       	 	//	.domain([0, 1])
       		 //	.range(["#2980B9", "#E67E22", "#27AE60", "#27AE60"]);
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);		
			
			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "<b>Article " + selection[d.y] + "</b>"
   						+ "<br><b>Dimension ID: </b>" + d.id
   						+"<br><b>Dimension Value: </b>" + d.value;
  					});
			
			/*d3.select("#articleProfile")
				.append("div")
				.html(
					"<b>PMID:</b> " + currentData[0].id + " (" + currentData[0].year + ")     "
					+ "<a href='https://www.ncbi.nlm.nih.gov/pubmed/" + currentData[0].id + "' target='_blank'><b>Link to PubMed</b></a><br>"
					+ "<b>Title:</b> " + currentData[0].title_raw + "<br>");
			*/
			
			/*d3.select("#vectorExplore2")
				.append("div")
				.html("<b>Semantic Space Explorer - Pairwise</b>");
			*/	
				
			/*
			d3.select("#vectorExplorer2")
				.append("input")
 	   			.attr('type','text')
 	   			.attr('id', 'selectItem1')
    			.attr('name','selectItem1')
    			.attr('value','123');
    			
    		d3.select("#vectorExplorer2")
    			.append("input")
 	   			.attr('type','text')
 	   			.attr('id', 'selectItem2')
    			.attr('name','selectItem2')
    			.attr('value','123');
    		*/	
    		
    		// allow users to select/unselect all dimensions being displayed
  			if(true){
  				var new_div = d3.select("#vectorExplore7")
        			.append("div")
        			.attr("class", "selectDimensionAll_pair")
        			.style("margin-top", 10);
        			          		
          		var new_button2 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_pair_button2")
          		.attr("value", "unSelectAll")
          		.style("float", "right")
          		.text("  unSelectAll")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return !selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          		
          		var new_button1 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_pair_button1")
          		.attr("value", "SelectAll")
          		.style("float", "right")
          		.text("SelectAll")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			for(var dim in selectionDim){
          				if(!selectedDimensions.includes(selectionDim[dim])) selectedDimensions.push(selectionDim[dim]);
          			}
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          	}
			
			var heatmap_svg = d3.select("#vectorExplore7")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_svg")
        		.append("g");
        		//.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        	heatmap_svg.call(tip_articleVector);	
        	heatmap_svg.call(tip_dim2);	
        	
        	var labels = heatmap_svg.selectAll('.heatmap_label')
        		.data(labels_data)
        		.enter().append('g').append('text')
        		.attr('class', 'heatmap_label')
        		.attr('width', cellSize)
        		.attr('height', 20)
        		.attr('y', function(d) { return yScale(d.y) + 30; })
        		.attr('x', function(d) { return xScale(d.x) + cellSize/3; })
        		.text(function(d){return "D" + d.dim;})
        		.attr("font-family", "sans-serif")
            	.attr("font-size", "11px")
            	.style("line-height", "1.5")
            	.style("cursor", "pointer")
            	.attr("fill", "black")
            	.on('click', function(d){
      				tip_articleVector.hide(d);
      				currentDimension = d.dim;
      				tip_dim2.show(d.dim);
      				var index = [];  // record highly responsive articles
      				var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    				var value_threshold = Quartile(dimensionVector[d.dim], 0.9);
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						var article_value = n[vector_mark][d.dim];
							if(article_value >= value_threshold){
								//console.log(article_value);
								index.push(n.index);
								keywords_list.push(n.keyword_rake);
							}
    						return blue_to_red(n[vector_mark][d.dim]);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);	
    					
    				// generate keywords for the selected dimension (highlighted articles)
    				keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
					updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    				})
    			.selectAll(".label")
    			.style("cursor", "pointer");	
        	
        	var cell_height = 40;
        	var cells = heatmap_svg.selectAll('.heatmap_rect')
       	 		.data(currentData_formated)
        		.enter().append('g').append('rect')
        		.attr('class', 'cell')
       			.attr('width', cellSize)
        		//.attr('height', 20)
        		.attr('height', function(d) { 
        			return (cell_height / (max_value - min_value)) * (d.value - min_value); 
        		})
        		//.attr('y', function(d) { return yScale(d.y); })
        		.attr('y', function(d) {
        			if(chart_type == "align"){
        				if(d.y == 0){ 
        					return 30 + yScale(d.y) + (cell_height - (cell_height / (max_value - min_value)) * (d.value - min_value)); 
        					//return yScale(d.y); 
        				}
        				else {
        					//return 30 + yScale(d.y) + (cell_height - 5); 
        					return 30 + (cell_height + 2); 
        				}
        			}
        			else{
        				if(d.y == 0){ 
        					return 30 + yScale(d.y);
        				}
        				else {
        					return 30 + (cell_height - (cell_height / (max_value - min_value)) * (d.value - min_value)) + (cell_height + 2); 
        				}
        			}
        		})
        		.attr('x', function(d) { return xScale(d.x); })
        		.attr('fill', function(d) { return blue_to_red(d.value); })
        		.on('mouseover', function(d){
        			tip_articleVector.show(d);
        		})
      			.on('mouseout', function(d){
      				tip_articleVector.hide(d);
      			});
		}
		
		// (Update 2018/02/22)
        // per selecting multiple dimension:
        // (1) all articles with a high value in this dimension will be highlighted in the article distribution
        // (2) keywords will be summarized for the selected dimensions
		d3.selectAll("#exploreDimensions").on("click", exploreDimensions);
		function exploreDimensions(){				    		
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore4").style("height", 0);
				return;
			}
			
			var width = 1200;
			var height = 200;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore4").style("height", height);
      		
      		// semantic document vector type
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "PV";
      		else if (type == "layout_tsnePA_text") vector_type = "PA";
      		else return;
      		
      		var vector_mode = "" // "" or "normArticle" or "normDim"
      		/*d3.selectAll(".compareValue_pc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "original") vector_mode = "";
					else vector_mode = "_" + radio.property("value");
				}
			});*/
      		var vector_mark = "vector_" + vector_type + vector_mode;
      		//console.log(vector_mark);
			
			// process the list of dimension IDs
			var selection = [];		
			var selection_str = document.getElementById("dimensions").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& selection.indexOf(parseInt(element.trim())) == -1){
					selection.push(parseInt(element.trim()));
				}
			}
			if(selection.length == 0){
				alert("You didn't specify any Items, Dimension 0, 1, 2, 3 will be taken as an example");
				selection.push(0);
				selection.push(1);
				selection.push(2);
				selection.push(3);
			}
			else if(selection.length > 200){
				alert("Pease provide no more than 200 items for exploration.");
				return;
			}
			//console.log(selection);
			
			// get the mode to identify responsive articles
			var mode_articles = "value"; // highlight articles by "value" or "distance"
      		d3.selectAll(".exploreDimensions_mode").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "distance") mode_articles = "distance";
				}
			});
			//console.log(mode_articles);
			
			// if the article value mode is selected
			// get the article value threshold (bottom), i.e. the averaged value (for selected dimensions) an article should be above the threshold
			var threshold_article = 0 - Number.MAX_VALUE;
			if(mode_articles == "value"){
				var threshold_article_raw = document.getElementById("exploreDimensions_at").value.trim();
				//if(! (/^\d+\.\d+$/.test(threshold_article_raw))){
				if(! (/^-?\d+\.?\d*$/.test(threshold_article_raw))){
					//alert("You didn't provide a valid value threshold. The default bottom threshold unlimited will be taken.");
				}
				else{
					threshold_article = parseFloat(threshold_article_raw);
				}
			}
			//console.log(threshold_article);
			
			// get the article value threshold (top), i.e. the averaged value (for selected dimensions) an article should be under the threshold
			var threshold_article2 = Number.MAX_VALUE;
			if(mode_articles == "value"){
				var threshold_article_raw2 = document.getElementById("exploreDimensions_at2").value.trim();
				//if(! (/^\d+\.\d+$/.test(threshold_article_raw)2)){
				if(! (/^-?\d+\.?\d*$/.test(threshold_article_raw2))){
					//alert("You didn't provide a valid value threshold. The default top threshold unlimited will be taken.");
				}
				else{
					threshold_article2 = parseFloat(threshold_article_raw2);
				}
			}
			//console.log(threshold_article2);
			
			// if the article distance mode is selected
			// get the distance threshold, and the reference articles to be used
			// the averaged distance to the reference articles will be considered
			var threshold_article_distance = 0.4;
			var dataVectors = []; // article vectors with selected dimensions only
			var dataVector_ref; // the averaged vector of reference articles, using selected dimensions only
			var articleDistances = [];
			if(mode_articles == "distance"){
				var threshold_article_distance_raw = document.getElementById("exploreDimensions_dist").value.trim();
				if(! (/^\d+\.\d+$/.test(threshold_article_distance_raw))){
					alert("You didn't provide a valid distance threshold. The default threshold 0.4 will be taken.");
				}
				else{
					threshold_article_distance = parseFloat(threshold_article_distance_raw);
				}
				
				var selection_ref = [];		
				var selection_ref_str = document.getElementById("exploreDimensions_ref").value;
				var selection_ref_raw;
				if (selection_ref_str.includes(",")){ // use "," as the delimiter
					selection_ref_raw = selection_ref_str.split(",");
				}
				else{
					selection_ref_raw = selection_ref_str.split(" "); // use " " as the delimite
				}
				for (var i = 0; i < selection_ref_raw.length; i++){
					var element = selection_ref_raw[i];
					if(element.trim().match(/^[0-9]+$/) != null
						&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
						&& selection_ref.indexOf(parseInt(element.trim())) == -1){
						selection_ref.push(parseInt(element.trim()));
					}
				}
				if(selection_ref.length == 0){
					alert("You didn't specify any reference articles, Article 0, 1, 2, 3 will be taken as an example");
					selection_ref.push(0);
					selection_ref.push(1);
					selection_ref.push(2);
					selection_ref.push(3);
				}
				else if(selection_ref.length > 50){
					alert("Pease provide no more than 50 reference articles.");
					return;
				}
				//console.log(selection_ref);
				
				// get article vectors with the selected dimensions only
				for(var i = 0; i < data.length; i++){
					var vector = [];
					for(var sel in selection){
						vector.push(data[i][vector_mark][selection[sel]]);
					}
					dataVectors.push(vector);
				}
				//console.log(dataVectors);
				// get averaged vector of reference articles, using the selected dimensions
				dataVector_ref = new Array(selection.length).fill(0);
				for(var i in selection_ref){
					//dataVector_ref += dataVectors[sel];
					dataVector_ref = dataVector_ref.map(function(num, idx){
						return num + dataVectors[selection_ref[i]][idx];
					});
				}
				dataVector_ref = dataVector_ref.map(function(num){
					return num/selection_ref.length;
				});
				//console.log(dataVector_ref);
				// get article distances to the reference articles
				for(var i = 0; i < data.length; i++){
					//var article_distance = euclidean(dataVectors[i], dataVector_ref);
					var article_distance = cosineSimi(dataVectors[i], dataVector_ref);
					articleDistances.push(1-article_distance);
				}
				//console.log(articleDistances);
			}
			
			// get the number of keywords to be displayed
			var number_keywords_raw = document.getElementById("exploreDimensions_kt").value.trim();
			var number_keywords = 20;
			if(! (/^\d+$/.test(number_keywords_raw))){
				//alert("You didn't provide a valid number. The default number 20 will be taken.");
			}
			else if(parseInt(number_keywords_raw) > 100){
				alert("A maximum number of 100 keywords will be displayed.");
				number_keywords = 100;
			}
			else{
				number_keywords = parseInt(number_keywords_raw);
			}
			//console.log(number_keywords);
			
			// get the mode of keywords, whether ranked by term frequency or document frequency
			var mode_keywords = "termFrequency"; // "" or "normArticle" or "normDim"
      		d3.selectAll(".exploreDimensions_kr").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "documentFrequency") mode_keywords = "documentFrequency";
				}
			});
			//console.log(mode_keywords);
      		
      		// find and highlight corresponding document (article) nodes based on the selected dimensions and article threshold
      		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);	
    		
    		var blue_to_red2 = d3.scale.threshold()
    			.domain([0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);	
    			
      		var index = [];  // record the list of matched document nodes to be highlighted (see the click action below)
      		var indexValue = {}; // record all articles and their values (averaged dimensions value)
      		var indexDistance = {}; // record all articles and their distances to the reference articles (using the selected dimensions)
      		var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the matched documents
      		var findResult = 0;
			objects.selectAll(".dot")
				//.attr("r", function (d) { return d.number_of_citations * 0.2 + 3; })
				.attr("r", function (n) { 
					basic_size = circle_size_s;
					if(showHighlight == 1 && n.if_highlight == "1") basic_size = circle_size_m; 
					return n.number_of_citations * citationSizePara + basic_size; 
				})
				.attr("stroke", function (n){
					// get article value
					if(mode_articles == "value"){
						var article_value = 0;
						for(var sel in selection){
							article_value += n[vector_mark][selection[sel]];
						}
						article_value = article_value / selection.length;
						//console.log(article_value);
						if(article_value >= threshold_article && article_value <= threshold_article2){
							index.push(n.index);
							keywords_list.push(n.keyword_rake);
							findResult = 1;
						}
						indexValue[n.index] = article_value;
					}
					// get article distance
					if(mode_articles == "distance"){
						var article_distance = articleDistances[n.index];
						if(article_distance <= threshold_article_distance){
							index.push(n.index);
							keywords_list.push(n.keyword_rake);
							findResult = 1;
						}
						indexDistance[n.index] = article_distance;
					}
					return "black";
				})
				.style("fill-opacity", function(n){
					if(index.indexOf(n.index) != -1){
						findResult = 1;
						d3.select(this).moveToFront();
						return 1;
					}
					else return 0.5;
				})
				.style("fill", function(n){
    				if(mode_articles == "value") return blue_to_red(indexValue[n.index]);
    				if(mode_articles == "distance") return blue_to_red2(1 - indexDistance[n.index]);
    			})
				.attr("stroke-width", function(n){
					if(index.indexOf(n.index) != -1){
						findResult = 1;
						if(showHighlight == 1 && n.if_highlight == "1") return 3;
						else return 1.5;
					}
					else return 0.1;
				});
			
			if(findResult == 0){
				objects.selectAll(".dot")
					.style("fill-opacity", 0.5)
					.attr("stroke-width", 1);
			}
			
			// process the keywords extracted from the highlighted articles
			/*var keywords_dict1 = {}; // keywords and their overall counts (a keyword might appear multiple times in a single document)
      		var keywords_dict2 = {}; // keywords and their document-counts (number of documents contain the keyword)
      		for(i = 0; i < index.length; i++){
      			var keywords_in_current_doc = []; // record whether a keyword has been counted in the current document
      			var keyword_rake = keywords_list[i].split(", "); // keywords for each document
      			for(j = 0; j < keyword_rake.length; j++){
      				keyword = keyword_rake[j].trim();
      				if(keyword in keywords_dict1){
      					keywords_dict1[keyword] = keywords_dict1[keyword] + 1;
      					if(keyword.indexOf(keywords_in_current_doc) == -1){
      						keywords_dict2[keyword] = keywords_dict2[keyword] + 1;
      						keywords_in_current_doc.push(keyword);
      					}
      				}
      				else{
      					keywords_dict1[keyword] = 1;
      					keywords_dict2[keyword] = 1;
      					keywords_in_current_doc.push(keyword);
      				}
      			}
      		}
      		
      		// sort the dictionary (sort keywords by their counts)
      		var keywords_dict1_sorted = Object.keys(keywords_dict1).map(function(key){
      			return [key, keywords_dict1[key]];
      		});
      		keywords_dict1_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict1_sorted);
      		var keywords_dict2_sorted = Object.keys(keywords_dict2).map(function(key){
      			return [key, keywords_dict2[key]];
      		});
      		keywords_dict2_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict2_sorted);
      		
      		// arrange the keywords for display
      		var number_keywords_display = 0;
      		var keywords_display = [];
			var keywords_display_str = ""
      		if(mode_keywords == "documentFrequency"){ // by document frequency
      			number_keywords_display = Math.min(number_keywords, keywords_dict2_sorted.length);
      			for(i = 0; i < number_keywords_display; i++){
      				keywords_display.push(keywords_dict2_sorted[i][0]);
      				keywords_display_str += keywords_dict2_sorted[i][0];
      				keywords_display_str += "(" + keywords_dict2_sorted[i][1] + ") ";
      			}
      		}
      		else{ // by term frequency in total
      			number_keywords_display = Math.min(number_keywords, keywords_dict1_sorted.length);
      			for(i = 0; i < number_keywords_display; i++){
      				keywords_display.push(keywords_dict1_sorted[i][0]);
      				keywords_display_str += keywords_dict1_sorted[i][0];
      				keywords_display_str += "(" + keywords_dict1_sorted[i][1] + ") ";
      			}
      		}
      		//console.log(keywords_display);
      		//console.log(keywords_display_str);*/
      		
      		// display the identified keywords
      		/*d3.selectAll(".vectorKeywords").remove();
      		d3.select("#vectorExplore4")
				.append("div")
				.attr("class", "vectorKeywords")
				.style("margin", "5px")
				.style("color", "green")
				.html("<b>Keywords</b>" + " (from " + index.length + " articles)<br>"
				//+ keywords_display);
				+ keywords_display_str);*/
				
			keywords_display_str = keywordForDimensions(index, keywords_list, number_keywords, mode_keywords);
			updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
        }
        
        // generate keywords for a group of articles (stored in the array of index) - which can be responsive articles for a selected dimension
        // input arguments: (1) index, the article list, (2) the rake keyword list for the articles, (3) number of keywords to display, (4) TF or DF
        function keywordForDimensions(index, keywords_list, number_keywords, mode_keywords){
        	// process the keywords extracted from the highlighted articles
			var keywords_dict1 = {}; // keywords and their overall counts (a keyword might appear multiple times in a single document)
      		var keywords_dict2 = {}; // keywords and their document-counts (number of documents contain the keyword)
      		for(i = 0; i < index.length; i++){
      			var keywords_in_current_doc = []; // record whether a keyword has been counted in the current document
      			var keyword_rake = keywords_list[i].split(", "); // keywords for each document
      			for(j = 0; j < keyword_rake.length; j++){
      				keyword = keyword_rake[j].trim();
      				if(keyword in keywords_dict1){
      					keywords_dict1[keyword] = keywords_dict1[keyword] + 1;
      					if(keyword.indexOf(keywords_in_current_doc) == -1){
      						keywords_dict2[keyword] = keywords_dict2[keyword] + 1;
      						keywords_in_current_doc.push(keyword);
      					}
      				}
      				else{
      					keywords_dict1[keyword] = 1;
      					keywords_dict2[keyword] = 1;
      					keywords_in_current_doc.push(keyword);
      				}
      			}
      		}
      		
      		// sort the dictionary (sort keywords by their counts)
      		var keywords_dict1_sorted = Object.keys(keywords_dict1).map(function(key){
      			return [key, keywords_dict1[key]];
      		});
      		keywords_dict1_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict1_sorted);
      		var keywords_dict2_sorted = Object.keys(keywords_dict2).map(function(key){
      			return [key, keywords_dict2[key]];
      		});
      		keywords_dict2_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict2_sorted);
      		
      		// arrange the keywords for display
      		var number_keywords_display = 0;
      		var keywords_display = [];
			var keywords_display_str = ""
      		if(mode_keywords == "documentFrequency"){ // by document frequency
      			number_keywords_display = Math.min(number_keywords, keywords_dict2_sorted.length);
      			for(i = 0; i < number_keywords_display; i++){
      				keywords_display.push(keywords_dict2_sorted[i][0]);
      				keywords_display_str += keywords_dict2_sorted[i][0];
      				keywords_display_str += "(" + keywords_dict2_sorted[i][1] + ") ";
      			}
      		}
      		else{ // by term frequency in total
      			number_keywords_display = Math.min(number_keywords, keywords_dict1_sorted.length);
      			for(i = 0; i < number_keywords_display; i++){
      				keywords_display.push(keywords_dict1_sorted[i][0]);
      				keywords_display_str += keywords_dict1_sorted[i][0];
      				keywords_display_str += "(" + keywords_dict1_sorted[i][1] + ") ";
      			}
      		}
      		//console.log(keywords_display_str);
      		return keywords_display_str;
        }
            
        // (Update 2018/02/22)
        // generate and display keywords for both common keywords and specific keywords
        // (1) all articles with a high value in this dimension will be highlighted in the article distribution
        // (2) keywords will be summarized for the selected dimensions
        var keywords_display = [];
        var keywords_display_common = [];
        var keywords_display_specific = [];
		d3.selectAll("#generateKeywords").on("click", generateKeywords);
		function generateKeywords(){				    		
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore5").style("height", 0);
				return;
			}
			
			var width = 1200;
			var height = 300;
      		//var heatmap_margin = {top: 20, right: 20, bottom: 20, left: 30};
      		d3.select("#vectorExplore5").style("height", height);
			
			// get the cut-off between common keywords and specific keywords, using document frequency (DF) in the format of ratio
			var threshold_keyword_raw = document.getElementById("exploreKeywords_cutoff").value.trim();
			var threshold_keyword = 50;
			if(! (/^\d+$/.test(threshold_keyword_raw))){
				alert("You didn't provide a valid cutoff. The default cutoff 50 will be taken.");
			}
			else{
				threshold_keyword = parseFloat(threshold_keyword_raw);
			}
			//console.log(threshold_keyword);
			
			// get the number of keywords to be displayed
			var number_keywords_raw = document.getElementById("exploreKeywords_kt").value.trim();
			var number_keywords = 20;
			if(! (/^\d+$/.test(number_keywords_raw))){
				alert("You didn't provide a valid number. The default number 20 will be taken.");
			}
			else if(parseInt(number_keywords_raw) > 100){
				alert("A maximum number of 100 keywords will be displayed.");
				number_keywords = 100;
			}
			else{
				number_keywords = parseInt(number_keywords_raw);
			}
			//console.log(number_keywords);
			
			// get the mode of keywords, whether ranked by term frequency or document frequency
			var mode_keywords = "termFrequency"; // "" or "normArticle" or "normDim"
      		d3.selectAll(".exploreKeywords_kr").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "documentFrequency") mode_keywords = "documentFrequency";
				}
			});
			//console.log(mode_keywords);
			
			// semantic document vector type
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "PV";
      		else if (type == "layout_tsnePA_text") vector_type = "PA";
      		else return;
      		
      		var vector_mode = "" // "" or "normArticle" or "normDim"
      		/*d3.selectAll(".compareValue_pc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "original") vector_mode = "";
					else vector_mode = "_" + radio.property("value");
				}
			});*/
      		var vector_mark = "vector_" + vector_type + vector_mode;
      		//console.log(vector_mark);
      		
      		// summarize the keywords from all articles
      		var keywords_list = [];
      		data.forEach(function(d){
      			keywords_list.push(d.keyword_rake);
      			
      		});
      		//console.log(keywords_list.length)
      		
			var keywords_dict1 = {}; // keywords and their overall counts (a keyword might appear multiple times in a single document)
      		var keywords_dict2 = {}; // keywords and their document-counts (number of documents contain the keyword)
      		for(i = 0; i < keywords_list.length; i++){
      			var keywords_in_current_doc = []; // record whether a keyword has been counted in the current document
      			var keyword_rake = keywords_list[i].split(", "); // keywords for each document
      			for(j = 0; j < keyword_rake.length; j++){
      				keyword = keyword_rake[j].trim();
      				if(keyword in keywords_dict1){
      					keywords_dict1[keyword] = keywords_dict1[keyword] + 1;
      					if(keyword.indexOf(keywords_in_current_doc) == -1){
      						keywords_dict2[keyword] = keywords_dict2[keyword] + 1;
      						keywords_in_current_doc.push(keyword);
      					}
      				}
      				else{
      					keywords_dict1[keyword] = 1;
      					keywords_dict2[keyword] = 1;
      					keywords_in_current_doc.push(keyword);
      				}
      			}
      		}
      		
      		// sort the dictionary (sort keywords by their counts)
      		var keywords_dict1_sorted = Object.keys(keywords_dict1).map(function(key){
      			return [key, keywords_dict1[key]];
      		});
      		keywords_dict1_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict1_sorted);
      		var keywords_dict2_sorted = Object.keys(keywords_dict2).map(function(key){
      			return [key, keywords_dict2[key]];
      		});
      		keywords_dict2_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
			//console.log(keywords_dict2_sorted);
      		
      		// arrange the keywords for display
      		var number_keywords_display = 0;
      		keywords_display = [];
			var keywords_display_str = ""
			keywords_display_common = [];
			var keywords_display_str_common = ""
			keywords_display_specific = [];
			var keywords_display_str_specific = ""
      		if(mode_keywords == "documentFrequency"){ // by document frequency
      			number_keywords_display = Math.min(number_keywords, keywords_dict2_sorted.length);
      			var count = 0;
      			var count_common = 0;
      			var count_specific = 0;
      			var i = 0;
      			while(i < keywords_dict2_sorted.length && (count < number_keywords_display || count_common < number_keywords_display || count_specific < number_keywords_display)){
      				if(count < number_keywords_display){
      					keywords_display.push(keywords_dict2_sorted[i][0] + "(" + keywords_dict2_sorted[i][1] + ")");
      					keywords_display_str += keywords_dict2_sorted[i][0];
      					keywords_display_str += "(" + keywords_dict2_sorted[i][1] + ") ";
      					count++;
      				}
      				if(count_common < number_keywords_display && keywords_dict2_sorted[i][1] >= threshold_keyword){
      					keywords_display_common.push(keywords_dict2_sorted[i][0] + "(" + keywords_dict2_sorted[i][1] + ")");
      					keywords_display_str_common += keywords_dict2_sorted[i][0];
      					keywords_display_str_common += "(" + keywords_dict2_sorted[i][1] + ") ";
      					count_common++;
      				}
      				if(count_specific < number_keywords_display && keywords_dict2_sorted[i][1] < threshold_keyword){
      					keywords_display_specific.push(keywords_dict2_sorted[i][0] + "(" + keywords_dict2_sorted[i][1] + ")");
      					keywords_display_str_specific += keywords_dict2_sorted[i][0];
      					keywords_display_str_specific += "(" + keywords_dict2_sorted[i][1] + ") ";
      					count_specific++;
      				}
      				i++;
      			}
      		}
      		else{ // by term frequency in total
      			number_keywords_display = Math.min(number_keywords, keywords_dict1_sorted.length);
      			var count = 0;
      			var count_common = 0;
      			var count_specific = 0;
      			var i = 0;
      			while(i < keywords_dict1_sorted.length && (count < number_keywords_display || count_common < number_keywords_display || count_specific < number_keywords_display)){
      				if(count < number_keywords_display){
      					keywords_display.push(keywords_dict1_sorted[i][0] + "(" + keywords_dict1_sorted[i][1] + ")");
      					keywords_display_str += keywords_dict1_sorted[i][0];
      					keywords_display_str += "(" + keywords_dict1_sorted[i][1] + ") ";
      					count++;
      				}
      				if(count_common < number_keywords_display && keywords_dict1_sorted[i][1] >= threshold_keyword){
      					keywords_display_common.push(keywords_dict1_sorted[i][0] + "(" + keywords_dict1_sorted[i][1] + ")");
      					keywords_display_str_common += keywords_dict1_sorted[i][0];
      					keywords_display_str_common += "(" + keywords_dict1_sorted[i][1] + ") ";
      					count_common++;
      				}
      				if(count_specific < number_keywords_display && keywords_dict1_sorted[i][1] < threshold_keyword){
      					keywords_display_specific.push(keywords_dict1_sorted[i][0] + "(" + keywords_dict1_sorted[i][1] + ")");
      					keywords_display_str_specific += keywords_dict1_sorted[i][0];
      					keywords_display_str_specific += "(" + keywords_dict1_sorted[i][1] + ") ";
      					count_specific++;
      				}
      				i++;
      			}
      		}
      		//console.log(keywords_display);
      		//console.log(keywords_display_str);
      		//console.log(keywords_display_common);
      		//console.log(keywords_display_str_common);
      		//console.log(keywords_display_specific);
      		//console.log(keywords_display_str_specific);
      		
      		// display the identified keywords - clicked text (button) for each keyword for further exploration
      		d3.selectAll("#exploreKeywords").selectAll("*").remove();
      		d3.select("#exploreKeywords")
				.attr("class", "exploreKeywords")
				.style("margin", "5px")
				.style("color", "green")
				.html(function(){
					var display = "";
					display += "<b>Common Keywords</b><br>";
					for(var i in keywords_display_common){
						display += "<button class=\"plainButton\" id=\"keywords_common_" + i + "\">" + keywords_display_common[i] + "</button>&nbsp;";
					}
					display += "<br><b>Specific Keywords</b><br>";
					for(var i in keywords_display_specific){
						display += "<button class=\"plainButton\" id=\"keywords_specific_" + i + "\">" + keywords_display_specific[i] + "</button>&nbsp;";
					}
					return display;
					}
				);	
        }
        
        // (Update 2018/02/23) 
        // per click a keyword, highlight the corresponding article nodes, and suggest the related dimensions
        var selectedKeyword = ""; // record the selected keyword for exploration (article and dimension query)
        var selectedArticles = []; // record the articles which contain the selected keyword
		$(document).on('click', function(e){
			if($(e.target).closest('.plainButton').length > 0){
				// get the clicked/queries keyword
				var keyword = ($(e.target).closest('.plainButton').text().split("("))[0].trim();
				selectedKeyword = keyword;
				//console.log(keyword);
				
				// look for the articles which contain the keyword
				var index = [];  // record the list of matched document nodes to be highlighted (see the click action below)
      			var findResult = 0;
				objects.selectAll(".dot")
					.attr("r", function (d) { 
						basic_size = circle_size_s;
						if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
						return d.number_of_citations * citationSizePara + basic_size; 
					})
					.attr("stroke", function (d){
						if(d.keyword_rake.indexOf(keyword) != -1){
							index.push(d.index);
							findResult = 1;
						}
						return "black";
					})
					.style("fill-opacity", function(d){
						if(index.indexOf(d.index) != -1){
							findResult = 1;
							d3.select(this).moveToFront();
							return 1;
						}
						else return 0.15;
					})
					.attr("stroke-width", function(d){
						if(index.indexOf(d.index) != -1){
							findResult = 1;
							return 1.5;
						}
						else return 0;
					});
			
				if(findResult == 0){
					objects.selectAll(".dot")
						.style("fill-opacity", 0.5)
						.attr("stroke-width", 1);
				}
				//console.log(index);
				
				document.getElementById("selectedKeyword").innerHTML = "Selected Keyword: " + keyword;
				selectedArticles = index;
			}
		});
		
		// (Update 2018/02/13)
		// per a selecte keyword and the corresponding (related) article, get dimensions which might be associated with the keyword
		// based on the dimension values on the keyword related articles
		d3.select("#getDimensions").on("click", getDimensions);
		function getDimensions() {
			if(selectedKeyword == ""){
				alert("You haven't selected a keyword for exploration, please select one from the Keyword Explorer.");
				return;
			}
			
			// get the threshold of dimension value
			var dimension_value_raw = document.getElementById("exploreKeywords_dv").value.trim();
			var dimension_value = 0.4;
			if(! (/^\d+\.\d+$/.test(dimension_value_raw))){
				alert("You didn't provide a valid threshold of dimension value. The default threshold 0.4 will be taken.");
			}
			else{
				dimension_value = parseFloat(dimension_value_raw);
			}
			//console.log(dimension_value);
			
			// get the threshold of article number / frequency
			var article_frequency_raw = document.getElementById("exploreKeywords_af").value.trim();
			var article_frequency = 3;
			if(! (/^\d+$/.test(article_frequency_raw))){
				alert("You didn't provide a valid threshold of article frequency. The default threshold 3 will be taken.");
			}
			else if(parseInt(article_frequency_raw) <= 0){
				alert("The minimum threshold 1 will be taken.");
				article_frequency = 1;
			}
			else{
				article_frequency = parseInt(article_frequency_raw);
			}
			//console.log(article_frequency);
			
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "PV";
      		else if (type == "layout_tsnePA_text") vector_type = "PA";
      		else return;
      		
			var vector_mode = "" // "" or "normArticle" or "normDim"
      		/*d3.selectAll(".compareValue_pc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					if(radio.property("value") == "original") vector_mode = "";
					else vector_mode = "_" + radio.property("value");
				}
			});*/
      		var vector_mark = "vector_" + vector_type + vector_mode;
      		//console.log(vector_mark);
      		
      		/*
      		// identify the dimensions which have an above-threshold-value in the identified articles
      		// maintain the dimension ID, and the number of responsive articles with the specified keywords
			var dimensions = {};
			data.forEach(function(d){
				if(selectedArticles.indexOf(d.index) != -1){
					for(var i = 0; i < 200; i++){
						if(d[vector_mark][i] >= dimension_value){
							if(i in dimensions){
								dimensions[i]++;
							}
							else{
								dimensions[i] = 1;
							}
						}
					}
				}
			});
			//console.log(dimensions);
			
			// sort the dictionary (sort keywords by their counts)
      		var dimensions_sorted = Object.keys(dimensions).map(function(key){
      			return [key, dimensions[key]];
      		});
      		dimensions_sorted.sort(function(first, second){
      			return second[1] - first[1];
      		});
      		//console.log(dimensions_sorted);
      		
      		// arrange the dimensions for display
      		var number_dimensions = 100;
      		var dimensions_display = [];
			var dimensions_display_str = ""
      		var number_dimensions_display = Math.min(number_dimensions, dimensions_sorted.length);
      		for(i = 0; i < number_dimensions_display; i++){
      			if(dimensions_sorted[i][1] >= article_frequency){
      				dimensions_display.push(dimensions_sorted[i][0]);
      				dimensions_display_str += dimensions_sorted[i][0];
      				dimensions_display_str += "(" + dimensions_sorted[i][1] + ") ";
      			}
      			if(dimensions_display.length > 100) break;
      		}
      		// display the identified dimensions
      		d3.select("#vectorExplore5").style("height", 280);
      		d3.selectAll(".getDimensions").remove();
      		d3.select("#vectorExplore5")
				.append("div")
				.attr("class", "getDimensions")
				.style("margin", "5px")
				.style("color", "green")
				.html("<b>Relevant Dimensions</b><br>"
				//+ keywords_display);
				+dimensions_display_str);
			*/
			
			// identify the dimensions which have an above-threshold-value in the identified articles
      		// maintain the dimension ID, and the number of responsive articles with the specified keywords
			var dimensions = new Array(200).fill(0);
			data.forEach(function(d){
				if(selectedArticles.indexOf(d.index) != -1){
					for(var i = 0; i < 200; i++){
						if(d[vector_mark][i] >= dimension_value){
							dimensions[i]++;
						}
					}
				}
			});
			//console.log(dimensions);
				
			// prepare the dimension data for visualization
			var dataAll = [];
			var dataAll_rank = [];
			for(var i = 0; i < 200; i++){
				var obj = {}
				obj["dim"] = i;
				obj["value"] = dimensions[i];
				dataAll.push(obj);
				dataAll_rank.push(obj);
			}
			dataAll_rank.sort(function(a,b) {return (a.value < b.value) ? 1 : ((b.value < a.value) ? -1 : 0);} );
			
			// draw the line (dot) chart
			var margin = {top: 10, right: 20, bottom: 20, left: 30};
			var x = d3.scale.linear().range([0, 1200]).domain([0, 199]);
			var y = d3.scale.linear().range([80, 0]).domain([dataAll_rank[199]["value"], dataAll_rank[0]["value"]]);
  			
  			// Define the axes
			var xAxis = d3.svg.axis().scale(x)
   				.orient("bottom").ticks(5);

			var yAxis = d3.svg.axis().scale(y)
   			 	.orient("left").ticks(5);
        				
    		var blue_to_red = d3.scale.threshold()
    			.domain([-1.5, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.5])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);	
			
			d3.select("#vectorExplore5").selectAll("svg").remove();
			var svg = d3.select("#vectorExplore5")
				.append("svg")
        		.attr("width", 1200 + margin.left + margin.right)
        		.attr("height", 150 + margin.top + margin.bottom)
        		.attr("class", "lineChart_svg")	
        		.append("g")
        		.attr("transform", 
              		"translate(" + margin.left + "," + margin.top + ")");
              		
			var tip = d3.tip()
  				.attr('class', 'd3-tip')
  				.offset([-10, 0])
  				.html(function(d) {
   					return "<b>D" + d.dim + "</b> "
   							+ "(" + d.value + ")";
  				});
  			svg.call(tip);
			
			// Add the bar chart
			svg.selectAll(".lineChart_verticleLine")
				.data(dataAll_rank)
				.enter()
				.append("line")  
    			.attr("class", "lineChart_verticleLine")
    			.attr("x1", function(d, i) { return x(i); })
    			.attr("y1", function(d, i) { return y(d.value); })  
   				.attr("x2", function(d, i) { return x(i); })
    			.attr("y2", function(d, i) { return y(0); })
    			.on("mouseover", function(d, i){
    				tip.show(d);
    				d3.select(this).style("stroke", "#51a5e1");
    			})
    			.on("mouseout", function(d){
    				tip.hide(d);
    				d3.select(this).style("stroke", "1f77b4");
    			})
    			.on("click", function(d){
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						return blue_to_red(n[vector_mark][d.dim]);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);	
    			});
    			
    		// Add the X Axis
    		/*svg.append("g")
        		.attr("class", "x axis")
        		.attr("transform", "translate(0," + height + ")")
        		.call(xAxis);*/

   		 	// Add the Y Axis
    		svg.append("g")
        		.attr("class", "y axis")
        		//.attr("transform", "translate(0, 0)")
        		.call(yAxis);			
		}	
        
        // (Update 2018/02/12)
        // Dynamic t-SNE layout with selected dimensions
        // Change the 2D layout (type of display)
		var dimensions = []; // the dimensions selected by user
		var selected_data = []; // data with selected dimensions (considered as the original high-dimensional data)
		var tsne_2D = []; // 2D data produced by t-SNE (considered as the processed 2D data)
		// initialize tsne_2D as the information read from the input json (updated in 2018/08)
		/*data.forEach(function(d){
			var item = [];
			item.push(d.layout_tsne_x);
			item.push(d.layout_tsne_y);
			tsne_2D.push(item);
		});*/
		var tsne_2D_adjust = []; // after cluster highlight/aggregation
		
		// Kmeans parameters
		var means ; // cluster means
		var assignments = []; // cluster assignment
		var points; // multi-dimensional data points for clustering
		var k = 5; // the default number of clusters for kmeans
		var step = 30; // the default number of steps/iterations for kmeans
		var clusterMethod = ""; // kmeans or hc (hierarchical clustering)
		
		// calculate 2D cluster means and the global mean
		var cluster_size;
		var cluster_mean_2D; // 2D cluster centers
		var global_mean_2D; // the 2D global center
		var cluster_keywords; // keywords or topics of clusters
		var cluster_keywords_highlight;// keywords or topics of clusters (highlight keywords with high specificity)
		var cluster_vectors; // (e.g. 200 dimensional) vectors of clusters, averaged from document vectors
		var cluster_vectors_normArticle; 
		var cluster_vectors_normDim; 
		var cluster_vectors_dis; // the discriminative capability of each dimension in each cluster
		
		// Update the 2D layout based on the selected dimensions
		d3.select("#setDimensions").on("click", setDimensions);
		function setDimensions() {
			// initialize t-SNE
			// Resource: https://github.com/karpathy/tsnejs
			// Resource: https://cs.stanford.edu/people/karpathy/tsnejs/csvdemo.html
			var opt = {}
			
			if(document.getElementById("tsne_perplexity").value.length < 1){
				//alert("The default P=30 will be taken");
				// the default perplexity is 30, however, we might need to assign smaller perplexity for larger dataset with i.e. more than 1000 articles
				if(data.length < 1000) opt.perplexity = 30;
				else if(data.length >= 1000 && data.length < 2000) opt.perplexity = 20;
				else opt.perplexity = 10;
			}
			else{
				opt.perplexity = parseInt(document.getElementById("tsne_perplexity").value);
			}
			
			if(document.getElementById("tsne_rate").value.length < 1){
				//alert("The default Rate=10 will be taken");
				// the default learningRate is 10, however, we might need to assign larger perplexity for larger dataset with i.e. more than 1000 articles
				if(data.length < 1000) opt.epsilon = 10;
				else if(data.length >= 1000 && data.length < 2000) opt.epsilon = 30;
				else opt.epsilon = 50;
			}
			else{
				opt.epsilon = parseInt(document.getElementById("tsne_rate").value);
			}
			
			//opt.epsilon = 10; // epsilon is learning rate (10 = default)
			//opt.perplexity = 30; // roughly how many neighbors each point influences (30 = default)
			opt.dim = 2; // dimensionality of the embedding (2 = default)
			var tsne = new tsnejs.tSNE(opt); // create a tSNE instance
			
			// process the selected dimensions
			var dimensions_str = document.getElementById("dimensions").value;
			var dimensions_raw;
			if (dimensions_str.includes(",")){ // use "," as the delimiter
				dimensions_raw = dimensions_str.split(",");
			}
			else{
				dimensions_raw = dimensions_str.split(" "); // use " " as the delimite
			}
			dimensions = [];
			for (var i = 0; i < dimensions_raw.length; i++){
				var element = dimensions_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& dimensions.indexOf(parseInt(element.trim())) == -1){
					dimensions.push(parseInt(element.trim()));
				}
			}
			if(dimensions.length == 0){
				alert("You didn't specify any dimensions, so all dimensions will be taken.");
				for (var i = 0; i < 200; i++){
					dimensions.push(i);
				}
			}
			//console.log(dimensions);
			
			// train t-SNE with our data with selected dimensions
			//dimensions = [50, 119, 120, 164] // sample dimensions for test only
			selected_data = [];
			data.forEach(function(d){
				var current_vector = [];
				for (dim in dimensions){
					current_vector.push(d["vector_PV"][dim]);
				}
				selected_data.push(current_vector);
			});
			tsne.initDataRaw(selected_data);
			for(var k = 0; k < 100; k++) {
  				tsne.step(); // every time you call this, solution gets better
			}
			tsne_2D = tsne.getSolution(); // Y is an array of 2-D points that you can plot
			//console.log(tsne);
			
			// assign the dynamically calculated t-SNE 2D positions to each data point
			data.forEach(function(d){
				d["dynamic_tsne_x"] = +tsne_2D[d.index][0];
				d["dynamic_tsne_y"] = +tsne_2D[d.index][1];
			});
			
			type_x = "dynamic_tsne_x";
			type_y = "dynamic_tsne_y";
		
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.style("fill", function (d){ 
				return cluster_color[0];
			})
			.attr("transform", transform);
			
			// reset the cluster assignments
			assignments = [];
		}
		
		// Update the 2D layout by selecting dimensions
		d3.select("#setDimensionsAll").on("click", setDimensionsAll);
		setDimensionsAll();
		function setDimensionsAll() {
			// initialize t-SNE
			// Resource: https://github.com/karpathy/tsnejs
			// Resource: https://cs.stanford.edu/people/karpathy/tsnejs/csvdemo.html
			var opt = {}
			
			if(document.getElementById("tsne_perplexity").value.length < 1){
				//alert("The default P=30 will be taken");
				// the default perplexity is 30, however, we might need to assign smaller perplexity for larger dataset with i.e. more than 1000 articles
				if(data.length < 1000) opt.perplexity = 30;
				else if(data.length >= 1000 && data.length < 2000) opt.perplexity = 20;
				else opt.perplexity = 10;
			}
			else{
				opt.perplexity = parseInt(document.getElementById("tsne_perplexity").value);
			}
			
			if(document.getElementById("tsne_rate").value.length < 1){
				//alert("The default Rate=10 will be taken");
				// the default learningRate is 10, however, we might need to assign larger learning rate for larger dataset with i.e. more than 1000 articles
				if(data.length < 1000) opt.epsilon = 10;
				else if(data.length >= 1000 && data.length < 2000) opt.epsilon = 30;
				else opt.epsilon = 50;
			}
			else{
				opt.epsilon = parseInt(document.getElementById("tsne_rate").value);
			}
			
			//opt.epsilon = 10; // epsilon is learning rate (10 = default)
			//opt.perplexity = 30; // roughly how many neighbors each point influences (30 = default)
			opt.dim = 2; // dimensionality of the embedding (2 = default)
			var tsne = new tsnejs.tSNE(opt); // create a tSNE instance
			
			// process the selected dimensions
			dimensions = [];
			for (var i = 0; i < 200; i++){
				dimensions.push(i);
			}
			//console.log(dimensions);
			
			// train t-SNE with our data with selected dimensions
			//dimensions = [50, 119, 120, 164] // sample dimensions for test only
			selected_data = [];
			data.forEach(function(d){
				var current_vector = [];
				for (dim in dimensions){
					current_vector.push(d["vector_PV"][dim]);
				}
				selected_data.push(current_vector);
			});
			tsne.initDataRaw(selected_data);
			for(var k = 0; k < 100; k++) {
  				tsne.step(); // every time you call this, solution gets better
			}
			
			// (option 1) get the 2D positions from the tsne function (randomness)
			//tsne_2D = tsne.getSolution(); // Y is an array of 2-D points that you can plot
			
			// (option 2) get the 2D positions from an external file (deterministic)
			tsne_2D = tsne_2D_fix;
			console.log(tsne_2D);
			
			// assign the dynamically calculated t-SNE 2D positions to each data point
			data.forEach(function(d){
				d["dynamic_tsne_x"] = +tsne_2D[d.index][0];
				d["dynamic_tsne_y"] = +tsne_2D[d.index][1];
			});
			
			type_x = "dynamic_tsne_x";
			type_y = "dynamic_tsne_y";
		
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.style("fill", function (d){ 
				return cluster_color[0];
			})
			.attr("transform", transform);
			
			// reset the cluster assignments
			assignments = [];
		}
		
		// Change the mode of clustering, either based on the original high dimensional data or 2D data produced by t-SNE
		d3.selectAll(".clusterMode").on("change", updateClusterMode);
		function updateClusterMode() {
			d3.selectAll(".clusterMode").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					cluster_mode = radio.property("value");
				}
			});
			//console.log(cluster_mode);
		}
		
		// Call kmeans clustering
		d3.selectAll('#runKmeans').on('click', runKmeans);
		function runKmeans(){
			if(document.getElementById("kmeans_k").value.length < 1){
				alert("The default k=5 will be taken");
				k = 5;
			}
			else{
				k = parseInt(document.getElementById("kmeans_k").value);
			}
			
			if(document.getElementById("kmeans_step").value.length < 1){
				alert("The default step=500 will be taken");
				step = 500;
			}
			else{
				step = parseInt(document.getElementById("kmeans_step").value);
			}
			
			// calculate k-means clusters based on the data with selected dimensions
			// Reference: http://bl.ocks.org/jbeuckm/5731501
			clusterMethod = "kmeans";
			if(cluster_mode == "2d"){
				points = tsne_2D;
			}
			else{ // cluster_mode is "original"
				points = selected_data;
			}
			means = [];
			assignments = kmeans.assignPointsToMeans(points, means);
			//console.log(assignments);
			changeK(k);
			var index = step;
			while(index > 0){
				kmeans_step();
				index--;
			}
			//console.log(assignments);
			//console.log(means);
			
			// calculate 2D cluster means and the global mean
			cluster_size = [];
			for(var index = 0; index < means.length; index++){
				cluster_size.push(0);
			}
			cluster_mean_2D = []; // 2D cluster centers
			for(var index = 0; index < means.length; index++){
				cluster_mean_2D.push([0, 0]);
			}
			global_mean_2D = [0, 0]; // the 2D global center
			
			for (var index = 0; index < assignments.length; index++){
				var assign = assignments[index];
				cluster_size[assign]++;
				cluster_mean_2D[assign][0] += tsne_2D[index][0];
				cluster_mean_2D[assign][1] += tsne_2D[index][1];
				global_mean_2D[0] += tsne_2D[index][0];
				global_mean_2D[1] += tsne_2D[index][1];
			}
			
			//console.log(cluster_mean_2D);
			//console.log(cluster_size);
			//console.log(global_mean_2D);
			
			for (var index = 0; index < means.length; index++){
				cluster_mean_2D[index][0] = cluster_mean_2D[index][0]/cluster_size[index];
				cluster_mean_2D[index][1] = cluster_mean_2D[index][1]/cluster_size[index];
			}
			global_mean_2D[0] = global_mean_2D[0]/(assignments.length);
			global_mean_2D[1] = global_mean_2D[1]/(assignments.length);
			
			// generate cluster keywords
			generateClusterKeywords();
			
			// generate cluster vectors (average from document vectors)
			generateClusterVectors();
			
			// update dimension behaviors, especially cluster-level behaviors
			initDimensions();
			
			// display the information of article number and cluster number
			var articleRange = data.length - 1;
			clusterRange = k - 1;
			var displayInfo = "Number of Articles: " + data.length + " (IDs: 0-" + articleRange + ")<br>"
							+ "Number of Clusters: " + k + " (IDs: 0-" + clusterRange + ")<br>"
							+ "Number of Dimensions: " + 200 + " (IDs: 0-" + 199 + ")";
			document.getElementById("overallInfo").innerHTML = displayInfo;
		}
		
		// cluster aggregation
		// trigger by radio buttons
		d3.selectAll(".highlight").on("change", updateHighlight);
		function updateHighlight() {
			d3.selectAll(".highlight").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					cluster_highlight = radio.property("value");
				}
			});
			
			var aggregate_rate;
			if(cluster_highlight == "adjust"){ // medium
				aggregate_rate = aggregate_rate_m;
			}
			else if(cluster_highlight == "adjust2"){ // high
				aggregate_rate = aggregate_rate_l; 
			}
			else{ // low
				aggregate_rate = aggregate_rate_s;
			}
			
			tsne_2D_adjust = [];
			for(var index = 0; index < assignments.length; index++){
				var assign = assignments[index];
				var element = [];
				element.push(tsne_2D[index][0] + aggregate_rate*(cluster_mean_2D[assign][0] - global_mean_2D[0]));
				element.push(tsne_2D[index][1] + aggregate_rate*(cluster_mean_2D[assign][1] - global_mean_2D[1]));
				tsne_2D_adjust.push(element);
			}
			
			// assign the dynamically calculated t-SNE 2D positions to each data point
			data.forEach(function(d){
				d["dynamic_tsne_x"] = +tsne_2D_adjust[d.index][0];
				d["dynamic_tsne_y"] = +tsne_2D_adjust[d.index][1];
			});
			
			type_x = "dynamic_tsne_x";
			type_y = "dynamic_tsne_y";
		
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.attr("transform", transform);
		}
		// trigger by submit button
		d3.selectAll("#clusterHighlight").on("click", updateHighlight2);
		function updateHighlight2() {
			var alpha = 0;
			var alpha_raw = document.getElementById("highlight_mag").value.trim();
			if(! (/^-?\d+\.?\d*$/.test(alpha_raw))){
				//alert("You didn't provide a valid value threshold. The default value 0 will be takne.");
			}
			else{
				alpha = parseFloat(alpha_raw);
			}
			//console.log(alpha);
			
			var aggregate_rate = alpha;
			
			tsne_2D_adjust = [];
			for(var index = 0; index < assignments.length; index++){
				var assign = assignments[index];
				var element = [];
				element.push(tsne_2D[index][0] + aggregate_rate*(cluster_mean_2D[assign][0] - global_mean_2D[0]));
				element.push(tsne_2D[index][1] + aggregate_rate*(cluster_mean_2D[assign][1] - global_mean_2D[1]));
				tsne_2D_adjust.push(element);
			}
			
			// assign the dynamically calculated t-SNE 2D positions to each data point
			data.forEach(function(d){
				d["dynamic_tsne_x"] = +tsne_2D_adjust[d.index][0];
				d["dynamic_tsne_y"] = +tsne_2D_adjust[d.index][1];
			});
			
			type_x = "dynamic_tsne_x";
			type_y = "dynamic_tsne_y";
		
			xMax = d3.max(data, function(d) { return d[type_x]; }) * 1.05,
			xMin = d3.min(data, function(d) { return d[type_x]; }),
			yMax = d3.max(data, function(d) { return d[type_y]; }) * 1.05,
			yMin = d3.min(data, function(d) { return d[type_y]; });
			x.domain([xMin, xMax]);
			y.domain([yMin, yMax]);
			
			zoomBeh
			.x(x)
			.y(y)
			.scaleExtent([0, 1500])
			.on("zoom", zoom);
			
			objects
			.selectAll(".dot")
			.attr("transform", transform);
		}
		
		// call a kmeans step (iteration)
		function kmeans_step() {
    		oldAssignments = assignments;
    		kmeans.moveMeansToCenters(points, assignments, means);
    		assignments = kmeans.assignPointsToMeans(points, means);

    		var changeCount = kmeans.countChangedAssignments(assignments, oldAssignments);
			var aveDistance = kmeans.findAverageDistancePointToMean(points, means, assignments);
			var aveMeanSeparation = kmeans.findAverageMeanSeparation(means);
			var sse = kmeans.sumSquaredError(points, means, assignments);

			var row = d3.select('#stats-table').append('tr');
			row.append('td').html(changeCount);
    		row.append('td').html(sse);

    		redraw();
  		}
		
		// adjust the k value for kmeans clustering
  		function changeK(amt) {
    		if (amt > 0) {
      			while (amt--) {
        			var i = Math.floor(Math.random() * points.length);
        			var p = points[i];
        			var newPoint = p.slice(0);
					//console.log("adding new point "+newPoint);
        			means.push(newPoint);
      			}
    		}
    		else while (amt < 0) {
      			means.pop();
      			amt++;
    		}
    		assignments = kmeans.assignPointsToMeans(points, means);
    		redraw();
  		}
  		
  		// adjust the 2D placements and color of article nodes after adjusting/applying the kmeans clustering
  		//var color = d3.scale.category10();
  		function redraw() {
  			//var color = d3.scale.category10();
  			objects
			.selectAll(".dot")
			.style("fill", function (d){ 
				//return color(assignments[d.index]);
				return cluster_color[assignments[d.index] % 10];
			});
  		}
		
		// show the convex hull for a mouse-overed node's cluster boundry
		var hull = svg.append("path")
			.attr("class", "hull");
		function showHull(node) {
			//var color = d3.scale.category10();
			var vertices = [];
			if(assignments.length == 0) return;
			data.forEach(function(d){
				if(assignments[d.index] == assignments[node.index]){
					//console.log([x(d[type_x]), y(d[type_y])]);
					vertices.push([x(d[type_x]), y(d[type_y])]);
				}
			});

			hull.datum(d3.geom.hull(vertices)).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
			d3.selectAll("path").moveToBack();
			d3.selectAll("path")
			.style("fill", cluster_color_transparent[assignments[node.index] % 10]);
		}
		
		function hideHull(){
			//console.log("clear");
			d3.selectAll("path").remove();
			hull = svg.append("path").attr("class", "hull");
			//tip_cluster.hide();
		}
		
		// generate keywords of clusters
		function generateClusterKeywords() {
			if(assignments.length == 0) return;
			
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;
			
			// for each cluster, get the rake_keywords from each membership articles
			var cluster_member = new Array(clusterCount);
			var keywords_list = new Array(clusterCount);
			for(var i = 0; i < clusterCount; i++){
				cluster_member[i] = [];
				keywords_list[i] = [];
			}
			data.forEach(function(d){
				var cluster_id = assignments[d.index];
				cluster_member[cluster_id].push(d.keyword_rake);
				keywords_list[cluster_id].push(d.keyword_rake);
      		});      		
      		
			// for each cluster, arrange the rake_keywords
      		cluster_keywords = [];// global variable, for all clusters, the keywords to display
      		cluster_keywords_highlight = [];// global variable, for all clusters, the keywords to display (highlight keywords with high specificity)
      		var cluster_keywords_items = []; 
      		for(var c = 0; c < clusterCount; c++){
      			var keywords_dict = {}; // for a cluster, keywords and their overall counts (a keyword might appear multiple times in a single document)
      			var keywords_dict2 = {}; // for a cluster, keywords and their document-counts (number of documents contain the keyword)
      			for(var i = 0; i < cluster_member[c].length; i++){
      				var keywords_in_current_doc = []; // record whether a keyword has been counted in the current document
      				var keyword_rake = keywords_list[c][i].split(", ");
      				for(j = 0; j < keyword_rake.length; j++){
      					var keyword = keyword_rake[j].trim();
      					if(keyword in keywords_dict){
      						keywords_dict[keyword] = keywords_dict[keyword] + 1;
      						if(keyword.indexOf(keywords_in_current_doc) == -1){
      							keywords_dict2[keyword] = keywords_dict2[keyword] + 1;
      							keywords_in_current_doc.push(keyword);
      						}
      					}
      					else{
      						keywords_dict[keyword] = 1;
      						keywords_dict2[keyword] = 1;
      						keywords_in_current_doc.push(keyword);
      					}
      				}
      			}
      			//console.log(keywords_dict);
      			//console.log(keywords_dict2);
      					
      			// sort the dictionary (sort keywords by their counts)
      			var keywords_dict2_sorted = Object.keys(keywords_dict2).map(function(key){
      				return [key, keywords_dict2[key]];
      			});
      			keywords_dict2_sorted.sort(function(first, second){
      				return second[1] - first[1];
      			});
				//console.log(keywords_dict2_sorted);
      					
				var number_keyword_display = Math.min(50, keywords_dict2_sorted.length);
				var keywords_display = [];
				var keywords_display_str = "";
      			for(i = 0; i < number_keyword_display; i++){
      				//keywords_display.push(keywords_dict2_sorted[i][0]);
      				keywords_display_str += keywords_dict2_sorted[i][0];
      				keywords_display_str += "(" + keywords_dict2_sorted[i][1] + ") ";
      				var element = {};
      				element["keyword"] = keywords_dict2_sorted[i][0];
      				element["frequency"] = keywords_dict2_sorted[i][1];
      				keywords_display.push(element);
      			}
      			cluster_keywords.push(keywords_display_str);
      			cluster_keywords_items.push(keywords_display);
			}
			
			// (Updated 2018/09) a keyword list/string that can highly keywords with high specificity in clusters
			var keywordAcrossCluster = {}; // record a keyword appears in #cluster topcis
			var threshold = 0.4; // 40% clusters
			for(var c = 0; c < clusterCount; c++){
				for(var i = 0; i < cluster_keywords_items[c].length; i++){
					var keyword = cluster_keywords_items[c][i]["keyword"];
					if(keyword in keywordAcrossCluster) keywordAcrossCluster[keyword]++;
					else keywordAcrossCluster[keyword] = 1;
				}
			}
			for(var c = 0; c < clusterCount; c++){
				var keywords_display_str = "";
				for(var i = 0; i < cluster_keywords_items[c].length; i++){
					var keyword = cluster_keywords_items[c][i]["keyword"];
					if(keywordAcrossCluster[keyword]/clusterCount > threshold){ // a general keyword appears in more than 40% clusters
						keywords_display_str += keyword;
      					keywords_display_str += "(" + cluster_keywords_items[c][i]["frequency"] + ") ";
					}
					else{
						keywords_display_str += "<b>" + keyword + "</b>"; // a specific keyword appears in less than 40% clusters
      					keywords_display_str += "(" + cluster_keywords_items[c][i]["frequency"] + ") ";
					}
				}
				cluster_keywords_highlight.push(keywords_display_str);
			}
		}
		
		// generate vectors of clusters (by averaging document vectors)
		function generateClusterVectors(){
			if(assignments.length == 0) return;
			
			var clusterCount;
			if(clusterMethod == "kmeans") clusterCount = k;
			else if(clusterMethod == "hc") clusterCount = cluster_number;
			else return;
			
			// determine the type of document vectors
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			
			// for each cluster, arrange all the member documents and average the document vectors
			var cluster_member = new Array(clusterCount);
			var vectors = new Array(clusterCount);
			var vectors_normArticle = new Array(clusterCount);
			var vectors_normDim = new Array(clusterCount);
			var vectors_dis = new Array(clusterCount);
			for(var i = 0; i < clusterCount; i++){
				cluster_member[i] = [];
				vectors[i] = new Array(200).fill(0);
				vectors_normArticle[i] = new Array(200).fill(0);
				vectors_normDim[i] = new Array(200).fill(0);
				vectors_dis[i] = new Array(200).fill(0);
			}
			data.forEach(function(d){
				var cluster_id = assignments[d.index];
				cluster_member[cluster_id].push(d.index);
				for(var i = 0; i < 200; i++){
					vectors[cluster_id][i] += d[vector_mark][i];
					vectors_normArticle[cluster_id][i] += d[vector_mark + "_normArticle"][i];
					vectors_normDim[cluster_id][i] += d[vector_mark + "_normDim"][i]; 
				}
      		});
      		for(var i = 0; i < clusterCount; i++){
      			for(var j = 0; j < 200; j++){
      				vectors[i][j] = vectors[i][j] / cluster_member[i].length;
      				vectors_normArticle[i][j] = vectors_normArticle[i][j] / cluster_member[i].length;
      				vectors_normDim[i][j] = vectors_normDim[i][j] / cluster_member[i].length;
      			}
      		}
      		data.forEach(function(d){
				var cluster_id = assignments[d.index];
				for(var i = 0; i < 200; i++){
					vectors_dis[cluster_id][i] += Math.pow((d[vector_mark][i] - vectors[cluster_id][i]), 2);
				}
      		});
      		for(var i = 0; i < clusterCount; i++){
      			for(var j = 0; j < 200; j++){
      				vectors_dis[i][j] = Math.sqrt(vectors_dis[i][j] / cluster_member[i].length);
      			}
      		}
      		cluster_vectors = vectors;
      		cluster_vectors_normArticle = vectors_normArticle;
      		cluster_vectors_normDim = vectors_normDim;
      		cluster_vectors_dis = vectors_dis;
      		//console.log(cluster_vectors);
		}
		
		// (Update 2018/03/02)
		// Hierarchical Clustering
		// Reference: https://github.com/upphiminn/jHC
		
		// records of all clustering results - only compute once 
		// and the specific clustering result to be applied can be readily selected from these repositories
		// Ward mode
		// original space
		var assignments_ward = []; // cluster assignment of hierarchical clustering
		var cluster_size_ward = [];
		var assignments_raw_ward = [];
		var cluster_map_ward = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		// 2d space
		var assignments_ward2d = []; // cluster assignment of hierarchical clustering
		var cluster_size_ward2d = [];
		var assignments_raw_ward2d = [];
		var cluster_map_ward2d = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		
		// Complete mode
		// original space
		var assignments_complete = []; // cluster assignment of hierarchical clustering
		var cluster_size_complete = [];
		var assignments_raw_complete = [];
		var cluster_map_complete = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		// 2d space
		var assignments_complete2d = []; // cluster assignment of hierarchical clustering
		var cluster_size_complete2d = [];
		var assignments_raw_complete2d = [];
		var cluster_map_complete2d = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		
		// Single mode
		// original space
		var assignments_single = []; // cluster assignment of hierarchical clustering
		var cluster_size_single = [];
		var assignments_raw_single = [];
		var cluster_map_single = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		// 2d space
		var assignments_single2d = []; // cluster assignment of hierarchical clustering
		var cluster_size_single2d = [];
		var assignments_raw_single2d = [];
		var cluster_map_single2d = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		
		// Average mode
		// original space
		var assignments_average = []; // cluster assignment of hierarchical clustering
		var cluster_size_average = [];
		var assignments_raw_average = [];
		var cluster_map_average = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		// 2d space
		var assignments_average2d = []; // cluster assignment of hierarchical clustering
		var cluster_size_average2d = [];
		var assignments_raw_average2d = [];
		var cluster_map_average2d = []; // map original HC cluster ids to cluster ids indexing from 0, 1, 2, ...etc.
		
		var node_count = data.length;
		var linkage; // the selected hierarchical clustering mode
		var level; // the selected clustering level
		var cluster_number; // number of clusters on the selected clustering level
		var cluster_mode_hc;
		
		// run hierarchical clustering
		d3.selectAll('#runHC').on('click', runHC);
		runHC();
		function runHC(){
			// get the parameters
			//var level = 4;
			level = 4
			if(document.getElementById("hc_level").value.length < 1){
				alert("The default level = 4 will be taken");
			}
			if(document.getElementById("hc_level").value < 1 || document.getElementById("hc_level").value > 20){
				alert("A valid level should be between 1 and 20. The default level = 4 will be taken");
			}
			else{
				level = parseInt(document.getElementById("hc_level").value);
			}
			//console.log("cluster level is: " + level);
			
			d3.selectAll(".linkage_hc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					linkage = radio.property("value");
				}
			});
			
			d3.selectAll(".clusterMode_hc").each(function(d){
				radio = d3.select(this);
				if(radio.property("checked")){
					cluster_mode_hc = radio.property("value");
				}
			});
			
			clusterMethod = "hc";
			var raw_point_data = [];
			//var raw_point_data = [[1,1,3],[0,2,3],[0,1,1],[2,1,1],[6,6,6],[5,6,4],[7,6,5],[12,12,12],[12,14,13],[12,14,12]]; // sample and simple data for testing
			if(cluster_mode_hc == "2d"){
				raw_point_data = tsne_2D;
			}
			else{
				//data.forEach(function(d){
					//raw_point_data.push(d["vector_PV"]);
				//})
				raw_point_data = selected_data;
			}
			//console.log(raw_point_data)
			
			// https://www.mathworks.com/help/stats/linkage.html
			if(linkage == "WARD"){
				if(cluster_mode_hc == "original"){
					if(assignments_ward.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("WARD").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_ward = [];
						assignments_raw_ward.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_ward[0][i] = root["name"];
						getClusterResultHC(root, 0, "ward");
						//console.log(assignments_raw_ward);
						arrangeClusterResultPC("ward");
						//console.log(cluster_map_ward);
						//console.log(cluster_size_ward);
						//console.log(assignments_ward);
					}
					// recolor the article nodes
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						//return color(assignments[d.index]);
						return cluster_color[assignments_ward[level][d.index] % 10];
						});
					// apply the clustering result with the selected linkage and level	
					assignments = assignments_ward[level];
					cluster_number = cluster_size_ward[level];
					//console.log("adjust level " + level);
					//console.log(assignments);
					//console.log(cluster_number);
				}
				else if(cluster_mode_hc == "2d"){
					if(assignments_ward2d.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("WARD").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_ward2d = [];
						assignments_raw_ward2d.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_ward2d[0][i] = root["name"];
						getClusterResultHC(root, 0, "ward");
						arrangeClusterResultPC("ward");
					}
					// recolor the article nodes
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_ward2d[level][d.index] % 10];
						});
					// apply the clustering result with the selected linkage and level	
					assignments = assignments_ward2d[level];
					cluster_number = cluster_size_ward2d[level];
				}
			}
			else if(linkage == "COMPLETE"){
				if(cluster_mode_hc == "original"){
					if(assignments_complete.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("COMPLETE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_complete = [];
						assignments_raw_complete.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_complete[0][i] = root["name"];
						getClusterResultHC(root, 0, "complete");
						arrangeClusterResultPC("complete");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_complete[level][d.index] % 10];
						});
					assignments = assignments_complete[level];
					cluster_number = cluster_size_complete[level];
				}
				else if(cluster_mode_hc == "2d"){
					if(assignments_complete2d.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("COMPLETE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_complete2d = [];
						assignments_raw_complete2d.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_complete2d[0][i] = root["name"];
						getClusterResultHC(root, 0, "complete");
						arrangeClusterResultPC("complete");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_complete2d[level][d.index] % 10];
						});
					assignments = assignments_complete2d[level];
					cluster_number = cluster_size_complete2d[level];
				}
			}
			else if(linkage == "SINGLE"){
				if(cluster_mode_hc == "original"){
					if(assignments_single.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("SINGLE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_single = [];
						assignments_raw_single.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_single[0][i] = root["name"];
						getClusterResultHC(root, 0, "single");
						arrangeClusterResultPC("single");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_single[level][d.index] % 10];
						});
					assignments = assignments_single[level];
					cluster_number = cluster_size_single[level];
				}
				else if(cluster_mode_hc == "2d"){
					if(assignments_single2d.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("SINGLE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_single2d = [];
						assignments_raw_single2d.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_single2d[0][i] = root["name"];
						getClusterResultHC(root, 0, "single");
						arrangeClusterResultPC("single");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_single2d[level][d.index] % 10];
						});
					assignments = assignments_single2d[level];
					cluster_number = cluster_size_single2d[level];
				}	
			}
			else if(linkage == "AVERAGE"){
				if(cluster_mode_hc == "original"){
					if(assignments_average.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("AVERAGE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_average = [];
						assignments_raw_average.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_average[0][i] = root["name"];
						getClusterResultHC(root, 0, "average");
						arrangeClusterResultPC("average");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_average[level][d.index] % 10];
						});
					assignments = assignments_average[level];
					cluster_number = cluster_size_average[level];
				}
				else if(cluster_mode_hc == "2d"){
					if(assignments_average2d.length == 0 || assignments.length == 0){
						var hc = jHC().linkage("AVERAGE").distance('EUCLIDEAN').data(raw_point_data);
						var hierarchy_tree = hc();
						//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
						var root = hierarchy_tree[hierarchy_tree.length - 1];
			
						assignments_raw_average2d = [];
						assignments_raw_average2d.push(new Array(node_count));
						for(var i = 0; i < node_count; i++) assignments_raw_average2d[0][i] = root["name"];
						getClusterResultHC(root, 0, "average");
						arrangeClusterResultPC("average");
					}
					objects
						.selectAll(".dot")
						.style("fill", function (d){ 
						return cluster_color[assignments_average2d[level][d.index] % 10];
						});
					assignments = assignments_average2d[level];
					cluster_number = cluster_size_average2d[level];
				}
			}
			
			// calculate 2D cluster means and the global mean
			cluster_size = [];
			for(var index = 0; index < cluster_number; index++){
				cluster_size.push(0);
			}
			cluster_mean_2D = []; // 2D cluster centers
			for(var index = 0; index < cluster_number; index++){
				cluster_mean_2D.push([0, 0]);
			}
			global_mean_2D = [0, 0]; // the 2D global center
			
			for (var index = 0; index < assignments.length; index++){
				var assign = assignments[index];
				cluster_size[assign]++;
				cluster_mean_2D[assign][0] += tsne_2D[index][0];
				cluster_mean_2D[assign][1] += tsne_2D[index][1];
				global_mean_2D[0] += tsne_2D[index][0];
				global_mean_2D[1] += tsne_2D[index][1];
			}
			
			//console.log(cluster_mean_2D);
			//console.log(cluster_size);
			//console.log(global_mean_2D);
			
			for (var index = 0; index < cluster_number; index++){
				cluster_mean_2D[index][0] = cluster_mean_2D[index][0]/cluster_size[index];
				cluster_mean_2D[index][1] = cluster_mean_2D[index][1]/cluster_size[index];
			}
			global_mean_2D[0] = global_mean_2D[0]/(assignments.length);
			global_mean_2D[1] = global_mean_2D[1]/(assignments.length);
			
			// generate cluster keywords
			generateClusterKeywords();
			
			// generate cluster vectors (average from document vectors)
			generateClusterVectors();
			
			// calculate dimension behaviors, especially cluster-level dimension behaviors
			initDimensions();
			
			// display the information of article number and cluster number
			var articleRange = data.length - 1;
			clusterRange = cluster_number - 1;
			var displayInfo = "Number of Documents: " + data.length + " (IDs: 0-" + articleRange + ")<br>"
							+ "Number of Clusters: " + cluster_number + " (IDs: 0-" + clusterRange + ")<br>"
							+ "Number of Dimensions: " + 200 + " (IDs: 0-" + 199 + ")";
			document.getElementById("overallInfo").innerHTML = displayInfo;
		}
		
		// extract the multilevel clustering results from a hierarchical tree
		function getClusterResultHC(element, current_level, linkage){
			if(cluster_mode_hc == "original"){
			if(linkage == "ward"){
				if(assignments_raw_ward.length <= current_level + 1){
					assignments_raw_ward.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_ward[current_level + 1][i] = i;
					}
				}
				//console.log("element: " + element["name"]);
				//console.log("size; " + element["size"]);
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_ward[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "complete"){
				if(assignments_raw_complete.length <= current_level + 1){
					assignments_raw_complete.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_complete[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_complete[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "single"){
				if(assignments_raw_single.length <= current_level + 1){
					assignments_raw_single.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_single[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_single[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "average"){
				if(assignments_raw_average.length <= current_level + 1){
					assignments_raw_average.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_average[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_average[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			}
			else if(cluster_mode_hc == "2d"){
			if(linkage == "ward"){
				if(assignments_raw_ward2d.length <= current_level + 1){
					assignments_raw_ward2d.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_ward2d[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_ward2d[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "complete"){
				if(assignments_raw_complete2d.length <= current_level + 1){
					assignments_raw_complete2d.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_complete2d[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_complete2d[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "single"){
				if(assignments_raw_single2d.length <= current_level + 1){
					assignments_raw_single2d.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_single2d[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_single2d[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			else if(linkage == "average"){
				if(assignments_raw_average2d.length <= current_level + 1){
					assignments_raw_average2d.push(new Array(node_count));
					for(var i = 0; i < node_count; i++){
						assignments_raw_average2d[current_level + 1][i] = i;
					}
				}
				if(element["size"] > 1){
					getClusterResultHC(element["children"][0], current_level + 1, linkage);
					getClusterResultHC(element["children"][1], current_level + 1, linkage);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						assignments_raw_average2d[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
			}
		}
		
		// rearrange the cluster id --> cluster index from 0, 1, 2, etc.
		function arrangeClusterResultPC(linkage){
			if(cluster_mode_hc == "original"){
			if(linkage == "ward"){
				for(var i in assignments_raw_ward){
					cluster_map_ward.push({});
					var index = 0;
					for(var j in assignments_raw_ward[i]){
						if(!(assignments_raw_ward[i][j] in cluster_map_ward[i])){
							cluster_map_ward[i][assignments_raw_ward[i][j]] = index;
							index++;
						}
					}
					cluster_size_ward.push(index);
				}
				for(var i in assignments_raw_ward){
					assignments_ward.push(new Array(node_count));
					for(var j in assignments_raw_ward[i]){
						assignments_ward[i][j] = cluster_map_ward[i][assignments_raw_ward[i][j]];
					}
				}
			}
			else if(linkage == "complete"){
				for(var i in assignments_raw_complete){
					cluster_map_complete.push({});
					var index = 0;
					for(var j in assignments_raw_complete[i]){
						if(!(assignments_raw_complete[i][j] in cluster_map_complete[i])){
							cluster_map_complete[i][assignments_raw_complete[i][j]] = index;
							index++;
						}
					}
					cluster_size_complete.push(index);
				}
				for(var i in assignments_raw_complete){
					assignments_complete.push(new Array(node_count));
					for(var j in assignments_raw_complete[i]){
						assignments_complete[i][j] = cluster_map_complete[i][assignments_raw_complete[i][j]];
					}
				}
			}
			else if(linkage == "single"){
				for(var i in assignments_raw_single){
					cluster_map_single.push({});
					var index = 0;
					for(var j in assignments_raw_single[i]){
						if(!(assignments_raw_single[i][j] in cluster_map_single[i])){
							cluster_map_single[i][assignments_raw_single[i][j]] = index;
							index++;
						}
					}
					cluster_size_single.push(index);
				}
				for(var i in assignments_raw_single){
					assignments_single.push(new Array(node_count));
					for(var j in assignments_raw_single[i]){
						assignments_single[i][j] = cluster_map_single[i][assignments_raw_single[i][j]];
					}
				}
			}
			else if(linkage == "average"){
				for(var i in assignments_raw_average){
					cluster_map_average.push({});
					var index = 0;
					for(var j in assignments_raw_average[i]){
						if(!(assignments_raw_average[i][j] in cluster_map_average[i])){
							cluster_map_average[i][assignments_raw_average[i][j]] = index;
							index++;
						}
					}
					cluster_size_average.push(index);
				}
				for(var i in assignments_raw_average){
					assignments_average.push(new Array(node_count));
					for(var j in assignments_raw_average[i]){
						assignments_average[i][j] = cluster_map_average[i][assignments_raw_average[i][j]];
					}
				}
			}
			}
			if(cluster_mode_hc == "2d"){
			if(linkage == "ward"){
				for(var i in assignments_raw_ward2d){
					cluster_map_ward2d.push({});
					var index = 0;
					for(var j in assignments_raw_ward2d[i]){
						if(!(assignments_raw_ward2d[i][j] in cluster_map_ward2d[i])){
							cluster_map_ward2d[i][assignments_raw_ward2d[i][j]] = index;
							index++;
						}
					}
					cluster_size_ward2d.push(index);
				}
				for(var i in assignments_raw_ward2d){
					assignments_ward2d.push(new Array(node_count));
					for(var j in assignments_raw_ward2d[i]){
						assignments_ward2d[i][j] = cluster_map_ward2d[i][assignments_raw_ward2d[i][j]];
					}
				}
			}
			else if(linkage == "complete"){
				for(var i in assignments_raw_complete2d){
					cluster_map_complete2d.push({});
					var index = 0;
					for(var j in assignments_raw_complete2d[i]){
						if(!(assignments_raw_complete2d[i][j] in cluster_map_complete2d[i])){
							cluster_map_complete2d[i][assignments_raw_complete2d[i][j]] = index;
							index++;
						}
					}
					cluster_size_complete2d.push(index);
				}
				for(var i in assignments_raw_complete2d){
					assignments_complete2d.push(new Array(node_count));
					for(var j in assignments_raw_complete2d[i]){
						assignments_complete2d[i][j] = cluster_map_complete2d[i][assignments_raw_complete2d[i][j]];
					}
				}
			}
			else if(linkage == "single"){
				for(var i in assignments_raw_single2d){
					cluster_map_single2d.push({});
					var index = 0;
					for(var j in assignments_raw_single2d[i]){
						if(!(assignments_raw_single2d[i][j] in cluster_map_single2d[i])){
							cluster_map_single2d[i][assignments_raw_single2d[i][j]] = index;
							index++;
						}
					}
					cluster_size_single2d.push(index);
				}
				for(var i in assignments_raw_single2d){
					assignments_single2d.push(new Array(node_count));
					for(var j in assignments_raw_single2d[i]){
						assignments_single2d[i][j] = cluster_map_single2d[i][assignments_raw_single2d[i][j]];
					}
				}
			}
			else if(linkage == "average"){
				for(var i in assignments_raw_average2d){
					cluster_map_average2d.push({});
					var index = 0;
					for(var j in assignments_raw_average2d[i]){
						if(!(assignments_raw_average2d[i][j] in cluster_map_average2d[i])){
							cluster_map_average2d[i][assignments_raw_average2d[i][j]] = index;
							index++;
						}
					}
					cluster_size_average2d.push(index);
				}
				for(var i in assignments_raw_average2d){
					assignments_average2d.push(new Array(node_count));
					for(var j in assignments_raw_average2d[i]){
						assignments_average2d[i][j] = cluster_map_average2d[i][assignments_raw_average2d[i][j]];
					}
				}
			}
			}
		}
		
		// set the circle (article point or dot) size based on the number of citations
		// Call kmeans clustering
		d3.selectAll('#setCitationSize').on('click', setCitationSize);
		function setCitationSize(){
			if(document.getElementById("citation_size").value.length < 1){
				alert("The default value 0 will be taken");
				citationSizePara = 0;
			}
			else{
				var value = parseFloat(document.getElementById("citation_size").value);
				if(value < 0){
					alert("The smallest value 0 will be taken");
					citationSizePara = 0;
				}
				else if(value > 1){
					alert("The largest value 1 will be taken");
					citationSizePara = 1;
				}
				else citationSizePara = value;
			}
			
			objects
			.attr("r", function (d) { 
				basic_size = circle_size_s;
				if(showHighlight == 1 && d.if_highlight == "1") basic_size = circle_size_m; 
				return d.number_of_citations * citationSizePara + basic_size; 
			})
		}
		
		// Update in 2018/08
		// select whether to make the analytic components into a scroll-window
		d3.select("#scroll_no").on("click", setNonScroll);
		function setNonScroll(){
			d3.select("#toolbox")
			.style("height", "auto")
			.style("overflow-y", "visible");
		}
		d3.select("#scroll_yes").on("click", setScroll);
		function setScroll(){
			d3.select("#toolbox")
			.style("height", "300")
			.style("overflow-y", "scroll");
		}
		
		// (Update 2018/09/04)
		// explore the correlation among dimensions
		// can rank dimensions based on hierarchical clustering upon dimension distance/similarity.
		var dimensionCluster_assignment_raw = [];
		var dimensionCluster_assignment = [];
		var dimensionCluster_map = [];
		var dimensionCluster_size = []; // number of clusters on each clustering level
		var dimensionCluster_ordered = []; // make the order of clusters (on each level) to reflect the hierarchy (e.g. siblings)
		var dimensionCluster_level;
		// can also rank dimensions based on kmeans clustering upon dimension correlation.
		var dimensionCluster_assignment_kmeans = [];
		var dimensionCluster_size_kmeans = []; 
		var dimensionCluster_means_kmeans = []; 
		var points_dim;
		var step_dim = 500;
		// store the rank of dimensions
		var dimensionRank = [];
		var last_value_mode = ""; // use dimension value or correlation
		var selectedDimension_cluster = []; // select dimensions by a cluster
		var dimensionCluster_rank_mode = "";
		var cellSize_record;
		
		// check and rank dimension correlation matrix
        d3.select("#checkCorrelation").on("click", checkCorrelation);
		function checkCorrelation(){
			d3.select("#vectorExplore8").select("svg").remove();
			d3.select("#vectorExplore8").select(".selectDimensionCluster").remove();
			d3.select("#vectorExplore8").select(".selectDimensionAll_cor").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore8").style("height", 0);
				return;
			}
			
			var rank_mode = "";
			d3.selectAll(".checkCorrelation_rank").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					rank_mode = radio.property("value");
				}
			});
			dimensionCluster_rank_mode = rank_mode;
			//console.log(rank_mode);
			
			// get the clustering level for hierarchical clustering
			var level = 1;
			if(document.getElementById("dim_hc_level").value.length < 1){
				alert("The default level = 1 will be taken");
			}
			if(document.getElementById("dim_hc_level").value < 1 || document.getElementById("hc_level").value > 20){
				alert("A valid level should be between 1 and 20. The default level = 1 will be taken");
			}
			else{
				level = parseInt(document.getElementById("dim_hc_level").value);
			}
			dimensionCluster_level = level;
			//console.log(level);
			
			// get k for kmeans clustering
			var k = 6;
			if(document.getElementById("dim_kmeans").value.length < 1){
				alert("The default k = 6 will be taken");
			}
			if(document.getElementById("dim_kmeans").value < 1 || document.getElementById("dim_kmeans").value > 50){
				alert("A valid k should be between 1 and 50. The default k = 6 will be taken");
			}
			else{
				k = parseInt(document.getElementById("dim_kmeans").value);
			}
			//console.log(level);
			
			// use dimension value or dimension correlation
			var value_mode = "";
			d3.selectAll(".checkCorrelation_mode").each(function(d){
				var radio = d3.select(this);
				if(radio.property("checked")){
					value_mode = radio.property("value");
				}
			});
			//console.log(value_mode);
			
			var dataToUse = [];
			if(value_mode == "value") dataToUse = dimensionVector;
			else dataToUse = dimensionCorrelation;
			
			// (cluster option 1) if hierarchical clustering is selected for ranking, get the clustering result of dimensions on the selected clustering level
			//console.log("last: " + last_value_mode + ", current: " + value_mode);
			if(rank_mode == "cluster"){
				if(dimensionCluster_assignment.length == 0 || last_value_mode != value_mode){
					last_value_mode = value_mode;
					var hc = jHC().linkage("WARD").distance('EUCLIDEAN').data(dataToUse);
					var hierarchy_tree = hc();
					//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
					var root = hierarchy_tree[hierarchy_tree.length - 1];
			
					dimensionCluster_assignment_raw = [];
					dimensionCluster_assignment_raw.push(new Array(200));
					for(var i = 0; i < 200; i++) dimensionCluster_assignment_raw[0][i] = root["name"];
					getClusterResultHC_dim(root, 0, "ward");
					//console.log(dimensionCluster_assignment_raw);
					arrangeClusterResultHC_dim("ward");
					//console.log(dimensionCluster_assignment);
					//console.log(dimensionCluster_size);
				
					// make the order of clusters (on each level) to reflect the hierarchy (e.g. siblings)
					for(var l = 0; l < dimensionCluster_size.length; l++){
						var currentOrder = [];
						if(l == 0 || l == 1) currentOrder.push(0);
						else{
							for(var i = 0; i < dimensionCluster_ordered[l-1].length; i++){
								var parent = i;
								for(var dim = 0; dim < 200; dim++){
									if(dimensionCluster_assignment[l-1][dim] == parent){
										var now = dimensionCluster_assignment[l][dim];
										if(!currentOrder.includes(now)) currentOrder.push(now);
									}
								}
							}
						}
						dimensionCluster_ordered.push(currentOrder);
					}
				}
				//console.log(dimensionCluster_ordered);
				if(level > dimensionCluster_size.length - 1) level = dimensionCluster_size.length - 1;
				// on the selected level, the clusters' size
				var dimensionCluster_clusterSize = []; 
				var cluster_count = dimensionCluster_size[level];
				dimensionCluster_clusterSize.push(new Array(cluster_count));
				for(var i = 0; i < cluster_count; i++) dimensionCluster_clusterSize[i] = 0;
				for(var i = 0; i < 200; i++){
					dimensionCluster_clusterSize[dimensionCluster_assignment[level][i]]++;
				}
				//console.log(dimensionCluster_clusterSize);
			
				// get the rank/position of dimensions based on the clustering result
				var indexCount = [];
				indexCount.push(new Array(cluster_count)); // a counter for each cluster
				for(var i = 0; i < cluster_count; i++) indexCount[i] = 0;
				dimensionRank = [];
				dimensionRank.push(new Array(200));
				for(var i = 0; i < 200; i++){
					var currentCluster = dimensionCluster_assignment[level][i];
					dimensionRank[i] = indexCount[currentCluster]++;
					for(var c = 0; c < cluster_count; c++){
						if(dimensionCluster_ordered[level].indexOf(c) < dimensionCluster_ordered[level].indexOf(currentCluster)){
							dimensionRank[i] += dimensionCluster_clusterSize[c];
						}
					}
				}
				//console.log(dimensionRank);
			}
			// (cluster option 2) if kmeans clustering is selected for ranking, get the clustering result of dimensions
			if(rank_mode == "kmeans"){
				// call kmeans
				if(k == 6 && data.length == 851 && dataDirectory == "ADHD") { // use fixed kmeans results from a previous run to make a demo for the ADHD dataset
					var fix_kmeans_6 = [2,4,1,2,0,5,1,1,5,5,1,5,1,3,2,3,3,2,0,5,3,2,1,4,3,5,0,5,4,5,4,4,0,1,3,1,1,0,1,2,3,5,5,1,
										5,4,5,1,1,3,5,4,4,5,1,3,2,2,4,1,5,0,4,4,2,1,3,0,4,5,2,1,2,4,5,1,0,3,3,1,5,0,4,0,4,4,5,0,
										0,4,3,0,1,5,4,0,3,3,1,3,3,4,4,3,0,1,3,3,5,0,5,4,5,2,0,3,5,2,2,5,2,1,1,1,4,2,4,2,1,5,5,5,
										5,4,1,5,1,3,1,0,3,1,1,1,4,3,0,4,3,1,3,2,5,1,2,1,2,5,1,5,4,4,3,1,5,1,5,2,1,4,2,1,2,5,1,4,
										0,3,1,0,1,4,0,2,0,0,1,4,1,1,3,1,5,3,0,1,2,5,1,5];
					dimensionCluster_assignment_kmeans = fix_kmeans_6;
					dimensionCluster_size_kmeans = [];
					for(var index = 0; index < k; index++){
						dimensionCluster_size_kmeans.push(0);
					}
					for (var index = 0; index < dimensionCluster_assignment_kmeans.length; index++){
						var assign = dimensionCluster_assignment_kmeans[index];
						dimensionCluster_size_kmeans[assign]++;
					}
				}
				else {
					runKmeans_dim(k, dataToUse);
				}
				// runKmeans_dim(k, dataToUse);
				//console.log(dimensionCluster_assignment_kmeans);
				//console.log(dimensionCluster_size_kmeans);
				
				// get the rank/position of dimensions based on the clustering result
				var indexCount = [];
				var cluster_count = dimensionCluster_size_kmeans.length;
				indexCount.push(new Array(cluster_count)); // a counter for each cluster
				for(var i = 0; i < cluster_count; i++) indexCount[i] = 0;
				dimensionRank = [];
				dimensionRank.push(new Array(200));
				for(var i = 0; i < 200; i++){
					var currentCluster = dimensionCluster_assignment_kmeans[i];
					dimensionRank[i] = indexCount[currentCluster]++;
					for(var c = 0; c < cluster_count; c++){
						if(c < currentCluster){
							dimensionRank[i] += dimensionCluster_size_kmeans[c];
						}
					}
				}
				//console.log(dimensionRank);
			}
			
			// arrange the data to be displayed
			var itemDimension = 200;
      		var margin = {top: 20, right: 0, bottom: 20, left: 10};
      		var width = 1200;
      		var itemSize = width/(itemDimension+3);
      		var height = itemSize * (200 + 5);
      		var cellSize = itemSize - 1;
      		cellSize_record = cellSize;
      		//d3.select("#vectorExplore7").style("height", Math.min(300, height + 60));
      		d3.select("#vectorExplore8").style("height", height + 80);
		
			var displayData = []; // the postion and value of each heatmap-cell
			var displayData_ranked = []; // the postion and value of each heatmap-cell - dimensions are ranked by clustering results
			var max_value = 0;
			var min_value = 0;
			for(var i = 0; i < 200; i++){
				for(var j = 0; j < 200; j++){
					element = {};
					element["x"] = j;
					element["y"] = i;
					element["value"] = dimensionCorrelation[i][j];
					if(rank_mode == "index"){
						element['cluster_x'] = "N/A";
						element['cluster_y'] = "N/A";
						element['pos_x'] =j;
						element['pos_y'] = i;
					}
					else if(rank_mode == "cluster"){
						element['cluster_x'] = dimensionCluster_assignment[level][j];
						element['cluster_y'] = dimensionCluster_assignment[level][i];
						element['pos_x'] = dimensionRank[j];
						element['pos_y'] = dimensionRank[i];
					}
					else if(rank_mode == "kmeans"){
						element['cluster_x'] = dimensionCluster_assignment_kmeans[j];
						element['cluster_y'] = dimensionCluster_assignment_kmeans[i];
						element['pos_x'] = dimensionRank[j];
						element['pos_y'] = dimensionRank[i];
					}
					displayData.push(element);
					if(element["value"] > max_value) max_value = element["value"];
					if(element["value"] < min_value) min_value = element["value"];
				}
			}
			//console.log(displayData);
		
			var x_elements = d3.set(displayData.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(displayData.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (itemSize)]); 
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-0.9, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 0.9])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);			
  			
  			// allow users to select a dimension cluster
  			if(rank_mode == "cluster" || rank_mode == "kmeans"){
  				var new_div = d3.select("#vectorExplore8")
        			.append("div")
        			.attr("class", "selectDimensionCluster");
        		
        		new_div.append("p")
        		.text("Search Dimensions:");
        		
        		new_div.append("input")
        		.attr("type", "text")
        		.attr("id", "searchDimensionCluster_dim")
        		.attr("placeholder", "e.g. 0,1,2")
        		.style("width", 100);

        		var new_button1 = new_div.append("button")
          		.attr("class","searchButton")
          		.attr("id", "searchDimensionCluster_button")
          		.attr("value", "Search")
          		.text("Search")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', searchDimensionCluster);
        		
        		new_div.append("p")
        		.text("   Select Dimensions By Clusters:");
        		
        		new_div.append("input")
        		.attr("type", "text")
        		.attr("id", "selectDimensionCluster_cluster")
        		.attr("placeholder", "e.g. 0,1,2")
        		.style("width", 100);

        		var new_button2 = new_div.append("button")
          		.attr("class","searchButton")
          		.attr("id", "selectDimensionCluster_button")
          		.attr("value", "Select")
          		.text("Select")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', selectDimensionCluster);
          		
          		var new_button3 = new_div.append("button")
          		.attr("class","searchButton")
          		.attr("id", "unselectDimensionCluster_button")
          		.attr("value", "unSelect")
          		.text("unSelect")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', unselectDimensionCluster);
          		
          		//<button id="checkCorrelation_dim" class="searchButton">Check Individual Dimension</button><br>
  			}
  			
  			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "Dimension1 " + d.y + " (Cluster " + d.cluster_y + ")<br>"
   						+ "Dimension2: " + d.x + " (Cluster " + d.cluster_x + ")<br>"
   						+ "Correlation: " + d.value;
  					});
  					
			// append the heatmap svg
			var heatmap_svg = d3.select("#vectorExplore8")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_rect_dimcor")
        		.append("g")
        		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        		
        	heatmap_svg.call(tip_articleVector);	
        
        	var cells = heatmap_svg.selectAll('.heatmap_cell')
       	 		.data(displayData)
        		.enter().append('g').append('rect')
        		.attr('class', 'heatmap_cell')
       			.attr('width', cellSize)
        		//.attr('height', function(d) { 
        		//	return (20 / (max_value - min_value)) * (d.value - min_value); 
        		//})
        		.attr('height', cellSize)
        		.attr('y', function(d) { 
        			if(rank_mode == "index") return yScale(d.y);
        			else if(rank_mode == "cluster" || rank_mode == "kmeans") return yScale(d.pos_y);
        			})
        		.attr('x', function(d) { 
        			if(rank_mode == "index") return xScale(d.x); 
        			else if(rank_mode == "cluster" || rank_mode == "kmeans") return xScale(d.pos_x);
        			})
        		.attr('fill', function(d) { return blue_to_red(d.value); })
        		.on('mouseover', function(d){
        			tip_articleVector.show(d);
        			d3.select(this).moveToFront();
        			d3.select(this)
        				.attr('width', cellSize+1)
        				.attr('height', cellSize+1)
        				.moveToFront();
        		})
      			.on('mouseout', function(d){
      				tip_articleVector.hide(d);
      				d3.select(this)
        				.attr('width', cellSize)
        				.attr('height', cellSize);
        				//.attr("stroke-width", 0);
      			});
      		dimensionCluster_level = level;	
      		last_value_mode = value_mode;
		}
		
		// for dimension hierarchical clustering, extract the multilevel clustering results from a hierarchical tree
		function getClusterResultHC_dim(element, current_level){
			if(true){
				if(dimensionCluster_assignment_raw.length <= current_level + 1){
					dimensionCluster_assignment_raw.push(new Array(200));
					for(var i = 0; i < 200; i++){
						dimensionCluster_assignment_raw[current_level + 1][i] = i;
					}
				}
				//console.log("element: " + element["name"]);
				//console.log("size; " + element["size"]);
				if(element["size"] > 1){
					getClusterResultHC_dim(element["children"][0], current_level + 1);
					getClusterResultHC_dim(element["children"][1], current_level + 1);
				}
				else{
					var parent = element["parent"];
					var level = current_level;
					while(level > 0){
						dimensionCluster_assignment_raw[level][element["name"]] = parent["name"];
						level--;
						if(level == 0) break;
						parent = parent["parent"];
					}
				}
			}
		}
		
		// for dimension hierarchical clustering, rearrange the cluster id --> cluster index from 0, 1, 2, etc.
		function arrangeClusterResultHC_dim(){
			if(true){
				for(var i in dimensionCluster_assignment_raw){
					dimensionCluster_map.push({});
					var index = 0;
					for(var j in dimensionCluster_assignment_raw[i]){
						if(!(dimensionCluster_assignment_raw[i][j] in dimensionCluster_map[i])){
							dimensionCluster_map[i][dimensionCluster_assignment_raw[i][j]] = index;
							index++;
						}
					}
					dimensionCluster_size.push(index);
				}
				for(var i in dimensionCluster_assignment_raw){
					dimensionCluster_assignment.push(new Array(200));
					for(var j in dimensionCluster_assignment_raw[i]){
						dimensionCluster_assignment[i][j] = dimensionCluster_map[i][dimensionCluster_assignment_raw[i][j]];
					}
				}
			}
		}
		
		// for dimension kmeans clustering - applied to dimension correlation vector 200*200 (instead of dimension value vector 200*(data.length))
		function runKmeans_dim(k, data){
			var clusterMethod = "kmeans";
			points_dim =  data;
			dimensionCluster_means_kmeans = [];
			dimensionCluster_assignment_kmeans = kmeans.assignPointsToMeans(points_dim, dimensionCluster_means_kmeans);
			//console.log(dimensionCluster_assignment_kmeans);
			changeK_dim(k, points_dim);
			var index = step;
			while(index > 0){
				kmeans_step_dim();
				index--;
			}
			//console.log(dimensionCluster_assignment_kmeans);
			//console.log(dimensionCluster_means_kmeans);
			
			// calculate 2D cluster means and the global mean
			dimensionCluster_size_kmeans = [];
			for(var index = 0; index < dimensionCluster_means_kmeans.length; index++){
				dimensionCluster_size_kmeans.push(0);
			}
			for (var index = 0; index < dimensionCluster_assignment_kmeans.length; index++){
				var assign = dimensionCluster_assignment_kmeans[index];
				dimensionCluster_size_kmeans[assign]++;
			}
			//console.log(dimensionCluster_size_kmeans);
		}
		
		// call a kmeans step (iteration)
		function kmeans_step_dim() {
    		oldAssignments = dimensionCluster_assignment_kmeans;
    		kmeans.moveMeansToCenters(points_dim, dimensionCluster_assignment_kmeans, dimensionCluster_means_kmeans);
    		dimensionCluster_assignment_kmeans = kmeans.assignPointsToMeans(points_dim, dimensionCluster_means_kmeans);

    		var changeCount = kmeans.countChangedAssignments(dimensionCluster_assignment_kmeans, oldAssignments);
			var aveDistance = kmeans.findAverageDistancePointToMean(points_dim, dimensionCluster_means_kmeans, dimensionCluster_assignment_kmeans);
			var aveMeanSeparation = kmeans.findAverageMeanSeparation(dimensionCluster_means_kmeans);
			var sse = kmeans.sumSquaredError(points_dim, dimensionCluster_means_kmeans, dimensionCluster_assignment_kmeans);
  		}
		
		// adjust the k value for kmeans clustering
  		function changeK_dim(amt) {
    		if (amt > 0) {
      			while (amt--) {
        			var i = Math.floor(Math.random() * points_dim.length);
        			var p = points_dim[i];
        			var newPoint = p.slice(0);
					//console.log("adding new point "+newPoint);
        			dimensionCluster_means_kmeans.push(newPoint);
      			}
    		}
    		else while (amt < 0) {
      			dimensionCluster_means_kmeans.pop();
      			amt++;
    		}
    		dimensionCluster_assignment_kmeans = kmeans.assignPointsToMeans(points_dim, dimensionCluster_means_kmeans);
  		}
		
		// check the correlated dimensions of a selected dimension
		d3.select("#checkCorrelation_dim").on("click", checkCorrelation_dim);
		function checkCorrelation_dim(){
			d3.select("#vectorExplore8").select("svg").remove();
			d3.select("#vectorExplore8").select(".selectDimensionCluster").remove();
			d3.select("#vectorExplore8").select(".selectDimensionAll_cor").remove();
			
			if(type != "layout_tsne_text" && type != "layout_tsnePA_text"){
				d3.select("#vectorExplore8").style("height", 0);
				return;
			}
			
			// determine the type of document vectors
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		else return;
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
			
			// get the dimension ID
			var dimID;
			if(document.getElementById("checkCorrelation_dimID").value.length < 1){
				alert("The default dimension 42 will be taken");
				dimID = 42;
			}
			else{
				dimID = parseInt(document.getElementById("checkCorrelation_dimID").value);
			}
			//console.log(dimID);
			
			// The selection of dimensions range
			var selectionDim_str = document.getElementById("checkCorrelation_range").value.trim().toLowerCase();
			var selectionDim_raw;
			var start = 0;
			var end = 30;
			if(selectionDim_str.includes("-")){
				start = parseInt(selectionDim_str.substr(0, selectionDim_str.indexOf("-")));
				end = parseInt(selectionDim_str.substr(selectionDim_str.indexOf("-") + 1));
				start = Math.max(start, 0);
				end = Math.min(end, 199);
			}
			
			// get the clustering result of dimensions on the selected clustering level
			/*if(dimensionCluster_assignment.length == 0){
				var hc = jHC().linkage("WARD").distance('EUCLIDEAN').data(dimensionVector);
				var hierarchy_tree = hc();
				//console.log('Resulting Hierarchy Tree output', hierarchy_tree);
				var root = hierarchy_tree[hierarchy_tree.length - 1];
			
				dimensionCluster_assignment_raw = [];
				dimensionCluster_assignment_raw.push(new Array(200));
				for(var i = 0; i < 200; i++) dimensionCluster_assignment_raw[0][i] = root["name"];
				getClusterResultHC_dim(root, 0, "ward");
				//console.log(dimensionCluster_assignment_raw);
				arrangeClusterResultHC_dim("ward");
				//console.log(dimensionCluster_assignment);
				//console.log(dimensionCluster_size);
				
				// make the order of clusters (on each level) to reflect the hierarchy (e.g. siblings)
				for(var l = 0; l < dimensionCluster_size.length; l++){
					var currentOrder = [];
					if(l == 0 || l == 1) currentOrder.push(0);
					else{
						for(var i = 0; i < dimensionCluster_ordered[l-1].length; i++){
							var parent = i;
							for(var dim = 0; dim < 200; dim++){
								if(dimensionCluster_assignment[l-1][dim] == i){
									var now = dimensionCluster_assignment[l][dim];
									if(!currentOrder.includes(now)) currentOrder.push(now);
								}
							}
						}
					}
					dimensionCluster_ordered.push(currentOrder);
				}
			}
			//console.log(dimensionCluster_ordered);
			if(level > dimensionCluster_size.length - 1) level = dimensionCluster_size.length - 1;*/
			
			// arrange the data to be displayed
			var displayData = []; // the postion and value of each heatmap-cell
			var displayData_ranked = []; // the postion and value of each heatmap-cell - dimensions are ranked by clustering results
			var max_value = 0;
			var min_value = 0;
			
			var i = dimID;
			for(var j = 0; j < 200; j++){
				var element = {};
				element["x"] = 0;
				element["y"] = 0;
				element["dim"] = j;
				element["value"] = dimensionCorrelation[i][j];
				displayData.push(element);
				if(element["value"] > max_value) max_value = element["value"];
				if(element["value"] < min_value) min_value = element["value"];
			}
			displayData.sort(function(a,b) {return (a.value < b.value) ? 1 : ((b.value < a.value) ? -1 : 0);} );
			displayData_ranked = displayData.slice(start, end+1); // take the top n dimensions in the ranked list
			for(var i in displayData_ranked){
				displayData_ranked[i]["x"] = i;
			}
			//console.log(displayData_ranked);
			
			var labels_data = []; // the dimension labels to display as headers
			for(var i = 0; i < displayData_ranked.length; i++){
				var element = {};
				element["x"] = i;
				element["y"] = 0;
				element["dim"] = displayData_ranked[i]["dim"];
				labels_data.push(element);
			}
			//console.log(labels_data);
			
			var itemDimension = end - start + 1;
      		var margin = {top: 20, right: 0, bottom: 20, left: 10};
      		var width = 1200;
      		var height = 80;
      		var itemSize = width/(itemDimension+3);
      		var cellSize = itemSize - 1;
      		var cellHeight = 30;
      		//d3.select("#vectorExplore7").style("height", Math.min(300, height + 60));
      		d3.select("#vectorExplore8").style("height", height + 90);
		
			var x_elements = d3.set(displayData_ranked.map(function( item ) { return item.x; } )).values();
        	var y_elements = d3.set(displayData_ranked.map(function( item ) { return item.y; } )).values();

    		var xScale = d3.scale.ordinal()
        		.domain(x_elements)
        		.rangeBands([0, x_elements.length * itemSize]);

    		var yScale = d3.scale.ordinal()
        		.domain(y_elements)
        		.rangeBands([0, y_elements.length * (itemSize)]); 
        
       		var colorScale = d3.scale.threshold()
    			.domain([-2, -1, 0, 1, 2])
    			//.range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);
    			.range(["#2980b9", "#439bd6", "#82bce3", "#f0ae75", "#eb9447", "#e67e22"]);
    			
    		var blue_to_red = d3.scale.threshold()
    			.domain([-0.9, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 0.9])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);			
			
			var tip_articleVector = d3.tip()
  					.attr('class', 'd3-tip')
  					.offset([-10, 0])
  					.html(function(d) {
   						return "D" + dimID + " vs. " + "D" + d.dim
   						+ "</br>Correlation: " + d.value;
  					});
  					
			// allow users to select/unselect all dimensions being displayed
			if(true){
				var selectionDim = []; // the dimension labels to display as headers
				for(var i = 0; i < displayData_ranked.length; i++){
					selectionDim.push(displayData_ranked[i]["dim"]);
				}
				
  				var new_div = d3.select("#vectorExplore8")
        			.append("div")
        			.attr("class", "selectDimensionAll_cor")
        			.style("margin-top", 10);
        			          		
          		var new_button2 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_cor_button2")
          		.attr("value", "unSelectAll")
          		.style("float", "right")
          		.text("  unSelectAll")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			var filtered = selectedDimensions.filter(function(value, index, arr){
          				return !selectionDim.includes(value);
          			});
          			selectedDimensions = filtered;
          			//console.log(selectedDimensions);
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          		
          		var new_button1 = new_div.append("button")
          		.attr("class","searchButton_plain")
          		.attr("id", "selectDimensionAll_cor_button1")
          		.attr("value", "SelectAll")
          		.style("float", "right")
          		.text("SelectAll")
          		//.attr("width", 50)
          		//.attr("height", 20)
          		.on('click', function(){
          			for(var dim in selectionDim){
          				if(!selectedDimensions.includes(selectionDim[dim])) selectedDimensions.push(selectionDim[dim]);
          			}
          			var str = "";
					for(var dim in selectedDimensions){
						str += selectedDimensions[dim];
						if(dim != selectedDimensions.length - 1) str += ",";
					}
					document.getElementById('dimensions').value = str;
          		});
          	}
			
			// create the svg
			var heatmap_svg = d3.select("#vectorExplore8")
				.append("svg")
        		.attr("width", width)
        		.attr("height", height)
        		.attr("class", "heatmap_rect_dimcor")
        		.append("g")
        		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        		
        	heatmap_svg.call(tip_articleVector);
        	heatmap_svg.call(tip_dim2);
        	
        	var labels = heatmap_svg.selectAll('.heatmap_label')
        		.data(labels_data)
        		.enter().append('g').append('text')
        		.attr('class', 'heatmap_label')
        		.attr('width', cellSize)
        		.attr('height', 20)
        		.attr('y', function(d) { return yScale(d.y) + 10; })
        		.attr('x', function(d) { return xScale(d.x) + cellSize/4; })
        		.text(function(d){return "D" + d.dim;})
        		.attr("font-family", "sans-serif")
            	.attr("font-size", "11px")
            	.style("line-height", "1.5")
            	.style("cursor", "pointer")
            	.attr("fill", "black")
            	.on('click', function(d){
      				tip_articleVector.hide(d);
      				currentDimension = d.dim;
      				tip_dim2.show(d.dim);
      				var index = [];  // record highly responsive articles
      				var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    				var value_threshold = Quartile(dimensionVector[d.dim], 0.9);
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						var article_value = n[vector_mark][d.dim];
							if(article_value >= value_threshold){
								//console.log(article_value);
								index.push(n.index);
								keywords_list.push(n.keyword_rake);
							}
    						return blue_to_red(n[vector_mark][d.dim]);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);	
    					
    				// generate keywords for the selected dimension (highlighted articles)
    				keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
					updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    				})
    			.selectAll(".label")
    			.style("cursor", "pointer");		
        
        	var cells = heatmap_svg.selectAll('.heatmap_cell')
       	 		.data(displayData_ranked)
        		.enter().append('g').append('rect')
        		.attr('class', 'heatmap_cell')
       			.attr('width', cellSize)
        		//.attr('height', function(d) { 
        		//	return (20 / (max_value - min_value)) * (d.value - min_value); 
        		//})
        		.attr('height', cellHeight)
        		.attr('y', function(d) { 
        			return yScale(d.y) + 20;
        			})
        		.attr('x', function(d) { 
        			return xScale(d.x); 
        			})
        		.attr('fill', function(d) { return blue_to_red(d.value); })
        		.on('mouseover', function(d){
        			tip_articleVector.show(d);
        			d3.select(this).moveToFront();
        			d3.select(this)
        				.attr('width', cellSize)
        				.attr('height', cellHeight*2)
        				.moveToFront();
        		})
      			.on('mouseout', function(d){
      				tip_articleVector.hide(d);
      				d3.select(this)
        				.attr('width', cellSize)
        				.attr('height', cellHeight);
        				//.attr("stroke-width", 0);
      			})
      			.on('click', function(d){
      				tip_articleVector.hide(d);
      				var index = [];  // record highly responsive articles
      				var keywords_list = []; // record the keywords (rake extraction from title and abstract) for each of the highly responsive articles
    				var value_threshold = Quartile(dimensionVector[d.dim], 0.9);
    				objects.selectAll(".dot")
    					.style("fill", function(n){
    						var article_value = n[vector_mark][d.dim];
							if(article_value >= value_threshold){
								//console.log(article_value);
								index.push(n.index);
								keywords_list.push(n.keyword_rake);
							}
    						return blue_to_red(n[vector_mark][d.dim]);
    					})
    					.attr("stroke-width", 0.1)
    					.attr("r", 5);	
    					
    				// generate keywords for the selected dimension (highlighted articles)
    				keywords_display_str = keywordForDimensions(index, keywords_list, 50, "termFrequency");
					updateClusterKeywords("<b>Keywords</b>" + " (from " + index.length + " articles)<br>" + keywords_display_str, "white");
    			});
		}
		
		// select a cluster of dimensions into the feature/dimension selection pool
		function selectDimensionCluster(){
			/*var clusterID;
			if(document.getElementById("selectDimensionCluster_cluster").value.length < 1){
				clusterID = 0;
			}
			else{
				clusterID = parseInt(document.getElementById("selectDimensionCluster_cluster").value);
			}
			//console.log(clusterID);*/
			
			var clusterIDs = []; // a list of article ids, or use cluster id to include all articles in the cluster
			// process the list of IDs
			var selection_str = document.getElementById("selectDimensionCluster_cluster").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& clusterIDs.indexOf(parseInt(element.trim())) == -1){
					clusterIDs.push(parseInt(element.trim()));
				}
			}
			if(clusterIDs.length == 0){
				//alert("You didn't specify any cluster");
				//return;
			}
			//console.log(clusterIDs);
				
			selectedDimension_cluster = [];
			if(dimensionCluster_rank_mode == "cluster"){
				for(var i in dimensionCluster_assignment[dimensionCluster_level]){
					if(clusterIDs.includes(dimensionCluster_assignment[dimensionCluster_level][i]) && !selectedDimensions.includes(parseInt(i))){
						selectedDimension_cluster.push(parseInt(i));
						selectedDimensions.push(parseInt(i));
					}
				}
			}
			else if(dimensionCluster_rank_mode == "kmeans"){
				for(var i in dimensionCluster_assignment_kmeans){
					if(clusterIDs.includes(dimensionCluster_assignment_kmeans[i]) && !selectedDimensions.includes(parseInt(i))){
						selectedDimension_cluster.push(parseInt(i));
						selectedDimensions.push(parseInt(i));
					}
				}
			}
			//console.log(selectedDimensions);
			//selectedDimensions = selectedDimension_cluster;
			var str = "";
			for(var dim in selectedDimensions){
				str += selectedDimensions[dim];
				if(dim != selectedDimensions.length - 1) str += ",";
			}
			document.getElementById('dimensions').value = str;
		}
		
		// unselect a cluster of dimensions from the feature/dimension selection pool
		function unselectDimensionCluster(){
			/*var clusterID;
			if(document.getElementById("selectDimensionCluster_cluster").value.length < 1){
				clusterID = 0;
			}
			else{
				clusterID = parseInt(document.getElementById("selectDimensionCluster_cluster").value);
			}
			//console.log(clusterID);*/
			
			var clusterIDs = []; // a list of article ids, or use cluster id to include all articles in the cluster
			// process the list of IDs
			var selection_str = document.getElementById("selectDimensionCluster_cluster").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& clusterIDs.indexOf(parseInt(element.trim())) == -1){
					clusterIDs.push(parseInt(element.trim()));
				}
			}
			if(clusterIDs.length == 0){
				//alert("You didn't specify any cluster");
				//return;
			}
				
			selectedDimension_cluster = [];
			if(dimensionCluster_rank_mode == "cluster"){
				for(var i in dimensionCluster_assignment[dimensionCluster_level]){
					if(clusterIDs.includes(dimensionCluster_assignment[dimensionCluster_level][i])){
						selectedDimension_cluster.push(i);
						selectedDimensions = selectedDimensions.filter(function(value, index, arr){
							return parseInt(value) != parseInt(i);
						});
					}
				}
			}
			else if(dimensionCluster_rank_mode == "kmeans"){
				for(var i in dimensionCluster_assignment_kmeans){
					if(clusterIDs.includes(dimensionCluster_assignment_kmeans[i])){
						selectedDimension_cluster.push(i);
						selectedDimensions = selectedDimensions.filter(function(value, index, arr){
							return parseInt(value) != parseInt(i);
						});
					}
				}
			}
			//console.log(selectedDimension_cluster);
			//selectedDimensions = selectedDimension_cluster;
			var str = "";
			for(var dim in selectedDimensions){
				str += selectedDimensions[dim];
				if(dim != selectedDimensions.length - 1) str += ",";
			}
			document.getElementById('dimensions').value = str;
		}
		
		// search and highlight a dimension in the dimension correlation matrix
		function searchDimensionCluster(){
			/*var dimID;
			if(document.getElementById("searchDimensionCluster_dim").value.length < 1){
				dimID = 0;
			}
			else{
				dimID = parseInt(document.getElementById("searchDimensionCluster_dim").value);
			}
			console.log(dimID);*/
			
			var dimIDs = []; // a list of article ids, or use cluster id to include all articles in the cluster
			// process the list of IDs
			var selection_str = document.getElementById("searchDimensionCluster_dim").value;
			var selection_raw;
			if (selection_str.includes(",")){ // use "," as the delimiter
				selection_raw = selection_str.split(",");
			}
			else{
				selection_raw = selection_str.split(" "); // use " " as the delimite
			}
			for (var i = 0; i < selection_raw.length; i++){
				var element = selection_raw[i];
				if(element.trim().match(/^[0-9]+$/) != null
					&& parseInt(element.trim()) >= 0 && parseInt(element.trim()) < data.length 
					&& dimIDs.indexOf(parseInt(element.trim())) == -1){
					dimIDs.push(parseInt(element.trim()));
				}
			}
			if(dimIDs.length == 0){
				//alert("You didn't specify any dimension to search");
				//return;
			}
			
			var blue_to_red = d3.scale.threshold()
    			.domain([-0.9, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 0.9])	
    			.range(["#000080", "#0000cc", "#0000ff", "#4d4dff", "#8080ff", "#ccccff", "#ffd7cc", "#ff9b80", "#ff5f33", "#ff3700" ,"#b32700", "#801c00"]);			
			d3.selectAll('.heatmap_cell')
       			.attr('width', function(d){
       				if(d.x == d.y && dimIDs.includes(d.x)) return cellSize_record*2;
       				else return cellSize_record;
       			})
        		.attr('height', function(d){
       				if(d.x == d.y && dimIDs.includes(d.x)) return cellSize_record*2;
       				else return cellSize_record;
       			})
        		.attr("stroke-width", function(d){
       				if(d.x == d.y && dimIDs.includes(d.x)) return 3;
       				else return 0;
       			})
        		.attr("stroke", function(d){
       				if(d.x == d.y && dimIDs.includes(d.x)) return "yellow";
       			})
       			.attr('fill', function(d) { 
       				if(d.x == d.y && dimIDs.includes(d.x)) return "yellow"; 
       				else return blue_to_red(d.value);
       			});
		}
		
		// (Updated 2018/09) prepare the article list of benchmark articles; and the article list of cluster representative articles
		var articlesBenchmark = []; // benchmark articles
		var articlesRepresent = []; // cluster representative articles
		prepareArticles();
		function prepareArticles(){
			var vector_type = ""; // "_PV" or "_PA"
      		if(type == "layout_tsne_text") vector_type = "_PV";
      		else if (type == "layout_tsnePA_text") vector_type = "_PA";
      		var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      		var vector_mark = "vector" + vector_type + vector_mode;
		
			data.forEach(function(d){
				if(d.if_highlight == "1") articlesBenchmark.push(d.index);
			});
			//console.log(articlesBenchmark);
			
			minClusterDistance = [];
			articlesRepresent = [];
			for(var i = 0; i < cluster_vectors.length; i++){
				minClusterDistance.push(0);
				articlesRepresent.push(-1);
			}
			data.forEach(function(d){
				var cluster_id = assignments[d.index];
				var simi = cosineSimi(d[vector_mark], cluster_vectors[cluster_id]);
				if(simi > minClusterDistance[cluster_id]){
					minClusterDistance[cluster_id] = simi;
					articlesRepresent[cluster_id] = d.index;
				}
			});
			//console.log(articlesRepresent);
		}
		
		// click to use the cluster representative articles
		d3.select("#compareMultiple_representative").on("click", compareMultiple_representative);
		function compareMultiple_representative(){
			var str = "";
			for(var i in articlesRepresent){
				str += articlesRepresent[i];
				if(i != articlesRepresent.length - 1) str += ",";
			}
			document.getElementById('compareItems_hm').value = str;
		}
		
		// click to use the user selected reference articles
		d3.select("#compareMultiple_reference").on("click", compareMultiple_reference);
		function compareMultiple_reference(){
			var str = "";
			for(var i in articlesReference){
				str += articlesReference[i];
				if(i != articlesReference.length - 1) str += ",";
			}
			document.getElementById('compareItems_hm').value = str;
		}
		
		// (Updated 2018/09)
		// Call PCA, and rank dimensions based on their contributions to the first x PCs
		// Global ranks
		// n*200 matrix, arrange the data feature/dimensions vectors
		var dataFeatureVector = [];
		var vector_type = ""; // "_PV" or "_PA"
      	if(type == "layout_tsne_text") vector_type = "_PV";
      	else if (type == "layout_tsnePA_text") vector_type = "_PA";
      	var vector_mode = ""; // all dimensions ("") or only the most active cells ("_active")
      	var vector_mark = "vector" + vector_type + vector_mode;
		data.forEach(function(d){
			dataFeatureVector.push(d[vector_mark]);
		});
		var dimContribution_globalDoc = [];
		
		// m*200 matrix, arrange the averaged cluster feature/dimensions vectors for m clusters
		var clusterFeatureVector = cluster_vectors; 
		var dimContribution_globalCluster = [];
		
		// Within cluster ranks
		// c*200 matrix, arrange the data feature/dimensions vectors for c documents within a selected cluster x, value will be assigned in the parallel coordinate function (comparePair_pc2)
		var dataFeatureVector_inCluster = []; 
		var dimContribution_inCluster = []; // Within a selected cluster x
			
		// PCA calculation
		// http://bl.ocks.org/ktaneishi/9499896#pca.js
		var PCA = function(){
    		this.scale = scale;
    		this.pca = pca;
    		//this.dimRank = dimRank;

    		function mean(X){
        		// mean by col
        		var T = transpose(X);
        		return T.map(function(row){ return d3.sum(row) / X.length; });
    		}

    		function transpose(X){
        		return d3.range(X[0].length).map(function(i){
            		return X.map(function(row){ return row[i]; });
        		});
    		}

    		function dot(X,Y){
        		return X.map(function(row){
        			return transpose(Y).map(function(col){
                		return d3.sum(d3.zip(row,col).map(function(v){
                    		return v[0]*v[1];
                		}));
            		});
        		});
    		}

    		function diag(X){
       	 		return d3.range(X.length).map(function(i){
            		return d3.range(X.length).map(function(j){ return (i == j) ? X[i] : 0; });
        		});
    		}

    		function zeros(i,j){
        		return d3.range(i).map(function(row){
            		return d3.range(j).map(function(){ return 0; });
        		});
    		}

    		function trunc(X,d){
        		return X.map(function(row){
            		return row.map(function(x){ return (x < d) ? 0 : x; });
        		});
    		}

    		function same(X,Y){
        		return d3.zip(X,Y).map(function(v){
            		return d3.zip(v[0],v[1]).map(function(w){ return w[0] == w[1]; });
        		}).map(function(row){
           	 	return row.reduce(function(x,y){ return x*y; });
        		}).reduce(function(x,y){ return x*y; });     
    		}

    		function std(X){
        		var m = mean(X);
        		return sqrt(mean(mul(X,X)), mul(m,m));
    		}

    		function sqrt(V){
        		return V.map(function(x){ return Math.sqrt(x); });
   	 		}

    		function mul(X,Y){
        		return d3.zip(X,Y).map(function(v){
            		if (typeof(v[0]) == 'number') return v[0]*v[1];
            		return d3.zip(v[0],v[1]).map(function(w){ return w[0]*w[1]; });
        		});
    		}

    		function sub(x,y){
        		console.assert(x.length == y.length, 'dim(x) == dim(y)');
        		return d3.zip(x,y).map(function(v){
           			if (typeof(v[0]) == 'number') return v[0]-v[1];
            		else return d3.zip(v[0],v[1]).map(function(w){ return w[0]-w[1]; });
        		});
    		}

    		function div(x,y){
        		console.assert(x.length == y.length, 'dim(x) == dim(y)');
        		return d3.zip(x,y).map(function(v){ return v[0]/v[1]; });
    		}

    		function scale(X, center, scale){
        		// compatible with R scale()
        		if (center){
            		var m = mean(X);
            		X = X.map(function(row){ return sub(row, m); });
        		}

        		if (scale){
            		var s = std(X);
            		X = X.map(function(row){ return div(row, s); });
        		}
        		return X;
    		}
    		
    		function transpose(a) {
    			return Object.keys(a[0]).map(function(c) {
        			return a.map(function(r) { return r[c]; });
    			});
			}

    		// translated from http://stitchpanorama.sourceforge.net/Python/svd.py
    		function svd(A){
        		var temp;
        		// Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
        		var prec = Math.pow(2,-52) // assumes double prec
        		var tolerance = 1.e-64/prec;
        		var itmax = 50;
        		var c = 0;
        		var i = 0;
        		var j = 0;
        		var k = 0;
        		var l = 0;
        
        		var u = A.map(function(row){ return row.slice(0); });
        		var m = u.length; // number of items
        		var n = u[0].length; // number of dimensions
        		
        		// make u a m*m matrix
        		for(var i = 0; i < m; i++){
        			for(var j = n; j < m; j++) u[i].push(0);
        		}
        		n = m;
        
        		//console.assert(m >= n, 'Need more rows than columns');
        		//console.log("n is " + n);
        		//console.log("m is " + m);
        
        		var e = d3.range(n).map(function(){ return 0; });
        		var q = d3.range(n).map(function(){ return 0; });
        		var v = zeros(n,n);
        
        		function pythag(a,b){
           			a = Math.abs(a)
            		b = Math.abs(b)
            		if (a > b)
                		return a*Math.sqrt(1.0+(b*b/a/a))
            		else if (b == 0) 
                		return a
            		return b*Math.sqrt(1.0+(a*a/b/b))
        		}

        		// Householder's reduction to bidiagonal form
        		var f = 0;
        		var g = 0;
        		var h = 0;
        		var x = 0;
        		var y = 0;
        		var z = 0;
        		var s = 0;
        
        		for (i=0; i < n; i++)
        		{
            		e[i]= g;
            		s= 0.0;
            		l= i+1;
            		for (j=i; j < m; j++) 
                		s += (u[j][i]*u[j][i]);
            		if (s <= tolerance)
                	g= 0.0;
            		else
            		{
                		f= u[i][i];
                		g= Math.sqrt(s);
                		if (f >= 0.0) g= -g;
                		h= f*g-s
                		u[i][i]=f-g;
                		for (j=l; j < n; j++)
                		{
                    		s= 0.0
                    		for (k=i; k < m; k++) 
                        		s += u[k][i]*u[k][j]
                    		f= s/h
                    		for (k=i; k < m; k++) 
                        		u[k][j]+=f*u[k][i]
                		}
            		}
            		q[i]= g
            		s= 0.0
            		for (j=l; j < n; j++) {
            			//if(j >= m) break;
                		s= s + u[i][j]*u[i][j];}
            		if (s <= tolerance)
                		g= 0.0
            		else
            		{
                		f= u[i][i+1]
                		g= Math.sqrt(s)
                		if (f >= 0.0) g= -g
                		h= f*g - s
                		u[i][i+1] = f-g;
                		for (j=l; j < n; j++) e[j]= u[i][j]/h
                		for (j=l; j < m; j++)
                		{
                    		s=0.0
                    		for (k=l; k < n; k++) {
                    			//if(k >= m) break;
                        		s += (u[j][k]*u[i][k]);}
                    		for (k=l; k < n; k++) {
                    			//if(k >= m) break;
                        		u[j][k]+=s*e[k];}
                		}
            		}
            		y= Math.abs(q[i])+Math.abs(e[i])
            		if (y>x) 
                		x=y
        		}
        
        		// accumulation of right hand gtransformations
        		for (i=n-1; i != -1; i+= -1)
        		{
            		if (g != 0.0)
            		{
                		h= g*u[i][i+1]
                		for (j=l; j < n; j++) 
                    		v[j][i]=u[i][j]/h
                		for (j=l; j < n; j++)
                		{
                    		s=0.0
                    		for (k=l; k < n; k++) 
                        		s += u[i][k]*v[k][j]
                    		for (k=l; k < n; k++) 
                        		v[k][j]+=(s*v[k][i])
                		}
            		}
            		for (j=l; j < n; j++)
            		{
                		v[i][j] = 0;
                		v[j][i] = 0;
            		}
            		v[i][i] = 1;
            		g= e[i]
            		l= i
        		}
        
        		// accumulation of left hand transformations
        		for (i=n-1; i != -1; i+= -1)
        		{
            		l= i+1
            		g= q[i]
            		for (j=l; j < n; j++) 
                		u[i][j] = 0;
            		if (g != 0.0)
            		{
                		h= u[i][i]*g
                		for (j=l; j < n; j++)
                		{
                    		s=0.0
                    		for (k=l; k < m; k++) s += u[k][i]*u[k][j];
                    		f= s/h
                    		for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
                		}
                		for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
            		}
            		else
                		for (j=i; j < m; j++) u[j][i] = 0;
            		u[i][i] += 1;
        		}
        
        		// diagonalization of the bidiagonal form
        		prec= prec*x
        		for (k=n-1; k != -1; k+= -1)
        		{
            		for (var iteration=0; iteration < itmax; iteration++)
            		{// test f splitting
                		var test_convergence = false
                		for (l=k; l != -1; l+= -1)
                		{
                    		if (Math.abs(e[l]) <= prec){
                        		test_convergence= true
                        		break 
                    		}
                    		if (Math.abs(q[l-1]) <= prec)
                        		break 
                		}
                		if (!test_convergence){
                    		// cancellation of e[l] if l>0
                    		c= 0.0
                    		s= 1.0
                    		var l1= l-1
                    		for (i =l; i<k+1; i++)
                    		{
                        		f= s*e[i]
                        		e[i]= c*e[i]
                        		if (Math.abs(f) <= prec)
                            		break
                        		g= q[i]
                        		h= pythag(f,g)
                        		q[i]= h
                        		c= g/h
                        		s= -f/h
                        		for (j=0; j < m; j++)
                        		{
                            		y= u[j][l1]
                            		z= u[j][i]
                            		u[j][l1] =  y*c+(z*s)
                            		u[j][i] = -y*s+(z*c)
                        		} 
                    		}
                		}
                		// test f convergence
                		z= q[k]
                		if (l== k){
                    		//convergence
                    		if (z<0.0)
                    		{ //q[k] is made non-negative
                        		q[k]= -z
                        		for (j=0; j < n; j++)
                            		v[j][k] = -v[j][k]
                    		}
                    		break  //break out of iteration loop and move on to next k value
                		}

                		console.assert(iteration < itmax-1, 'Error: no convergence.');

                		// shift from bottom 2x2 minor
                		x= q[l]
                		y= q[k-1]
                		g= e[k-1]
                		h= e[k]
                		f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
                		g= pythag(f,1.0)
                		if (f < 0.0)
                    		f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
                		else
                    		f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
                		// next QR transformation
                		c= 1.0
                		s= 1.0
                		for (i=l+1; i< k+1; i++)
                		{
                    		g = e[i]
                    		y = q[i]
                    		h = s*g
                    		g = c*g
                    		z = pythag(f,h)
                    		e[i-1] = z
                    		c = f/z
                    		s = h/z
                    		f = x*c+g*s
                    		g = -x*s+g*c
                    		h = y*s
                    		y = y*c
                    		for (j =0; j < n; j++)
                    		{
                        		x = v[j][i-1]
                        		z = v[j][i]
                        		v[j][i-1]  = x*c+z*s
                        		v[j][i]  = -x*s+z*c
                    		}
                    		z = pythag(f,h)
                    		q[i-1] = z
                    		c = f/z
                    		s = h/z
                    		f = c*g+s*y
                    		x = -s*g+c*y
                    		for (j =0; j < m; j++)
                    		{
                        		y = u[j][i-1]
                        		z = u[j][i]
                        		u[j][i-1]  = y*c+z*s
                        		u[j][i]  = -y*s+z*c
                    		}
                		}
               	 		e[l] = 0.0
                		e[k] = f
                		q[k] = x
            		} 
        		}
            
        		// vt = transpose(v)
        		// return (u,q,vt)
        		for (i=0;i<q.length; i++) 
            		if (q[i] < prec) q[i] = 0
          
        		// sort eigenvalues
        		for (i=0; i< n; i++){ 
            		// writeln(q)
            		for (j=i-1; j >= 0; j--){
                		if (q[j] < q[i]){
                    		// writeln(i,'-',j)
                    		c = q[j]
                    		q[j] = q[i]
                    		q[i] = c
                    		for (k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
                    		for (k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
                    		i = j   
                		}
            		}
        		}
        		//console.log(u);
        		return { U:u, S:q, V:v }
    		}

    		function pca(X, npc, transpose){
        		var USV = svd(X);
        		var U = USV.U;
        		var S = diag(USV.S);
        		var V = USV.V;
        	
        		//console.log(U);
        		// the diagonal elements of S are eigenvalues
        		//console.log(S);
        		// the columns of V are eigenvectors
        		//console.log(V);

        		// T = X*V = U*S
        		var pcXV = dot(X,V)
        		var pcUdS = dot(U,S);
	
        		var prod = trunc(sub(pcXV,pcUdS), 1e-12);
        		var zero = zeros(prod.length, prod[0].length);
        		console.assert(same(prod,zero), 'svd and eig ways must be the same.');
        	
        		// get the contribution of each of the 200 dimensions
        		var dimContribution = [];
        		if(transpose == 0){
        			for(var i  = 0; i < 200; i++){ // original dims
        				var current = 0;
        				for(var j = 0; j < npc; j++){ // pca dims
        					current += Math.abs(S[j][j] * V[i][j]);
        				}
        				dimContribution.push(current);
        			}
        			//console.log(dimContribution);
        		}
        		if(transpose == 1){
        			for(var i  = 0; i < 200; i++){ // original dims
        				var current = 0;
        				for(var j = 0; j < npc; j++){ // pca dims
        					current += Math.abs(S[j][j] * U[j][i]);
        				}
        				dimContribution.push(current);
        			}
        			//console.log(dimContribution);
        		}
        	
        		//return pcUdS; // return the PCA components
        		return dimContribution; // return the contribution of original dimensions (to the #npc PCA components)
    		}
    	
    		// Apply PCA 
    		var input;
    		var result;
    		var npc;
    	
    		// PCA for all documents - only need to call it at initialization
    		//console.log(dataFeatureVector);
    		if(dimContribution_globalDoc.length == 0){
    			input = dataFeatureVector;
    			npc = Math.min(Math.min(20, 200), dataFeatureVector.length - 1);
    			if(input.length > input[0].length){
    				dimContribution_globalDoc = pca(input, npc, 0);
    			}
    			else{
    				input = transpose(input);
    				dimContribution_globalDoc = pca(input, npc, 1);
    			}
    			//console.log(dimContribution_globalDoc);
    		}
    	
    		// PCA for all clusters - only when clusters are assigned
    		//console.log(clusterFeatureVector);
    		/*if(clusterFeatureVector.length != 0){
    			input = clusterFeatureVector;
    			npc = Math.min(Math.min(20, 200), clusterFeatureVector.length - 1);
    			if(input.length > input[0].length){
    				dimContribution_globalCluster = pca(input, npc, 0);
    			}
    			else{
    				input = transpose(input);
    				dimContribution_globalCluster = pca(input, npc, 1);
    			}
    		}
    		console.log(dimContribution_globalCluster);*/
    		
    		// PCA for all documents within a selected cluster - only when a cluster is selected
    		//console.log(dataFeatureVector_inCluster);
    		if(dataFeatureVector_inCluster.length != 0){
    			input = dataFeatureVector_inCluster;
    			console.log(input);
    			npc = Math.min(Math.min(20, 200), dataFeatureVector_inCluster.length - 1);
    			if(input.length > input[0].length){
    				dimContribution_inCluster = pca(input, npc, 0);
    			}
    			else{
    				input = transpose(input);
    				dimContribution_inCluster = pca(input, npc, 1);
    			}
    			//console.log(dimContribution_inCluster);
    		}
		};
		PCA();
	});
	}
	
	// Move object to the front layer
	d3.selection.prototype.moveToFront = function() {
		return this.each(function(){
			this.parentNode.appendChild(this);
		});
	};
	
	// Move object to the back layer
	d3.selection.prototype.moveToBack = function() {  
        return this.each(function() { 
            var firstChild = this.parentNode.firstChild; 
            if (firstChild) { 
                this.parentNode.insertBefore(this, firstChild); 
            } 
        });
    };
	
	// Calculate ligher or darker colors
	function ColorLuminance(hex, lum) {
		// validate hex string
		hex = String(hex).replace(/[^0-9a-f]/gi, '');
		if (hex.length < 6) {
			hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
		}
		lum = lum || 0;

		// convert to decimal and change luminosity
		var rgb = "#", c, i;
		for (i = 0; i < 3; i++) {
			c = parseInt(hex.substr(i*2,2), 16);
			c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
			rgb += ("00"+c).substr(c.length);
		}
		return rgb;
	}
	
	// Compare two cluster option object {id and name} with the name variable, serving for object sorting
	function compare(a, b) {
		if (a.name < b.name) return -1;
		if (a.name > b.name) return 1;
		return 0;
	}
	
	// Jquery to toggle the dropdown list of cluster selection
	$(".dropdown dt a").on('click', function() {
	$(".dropdown dd ul").slideToggle('fast');
	});

	$(document).bind('click', function(e) {
		var $clicked = $(e.target);
		if (!$clicked.parents().hasClass("dropdown")) $(".dropdown dd ul").hide();
	});
	
	// function to trim(strip) a string
	if(typeof(String.prototype.trim) === "undefined"){
    	String.prototype.trim = function(){
        	return String(this).replace(/^\s+|\s+$/g, '');
    	};
	}
	// function to calculate array mean
	function calculateMean(array) {
		return arr.sum(array) / array.length;
	}
	
	// function to calculate array variance
	function calculateVariance(array){
		var mean = arr.mean(array);
		return arr.mean(array.map(function(num) {
			return Math.pow(num - mean, 2);
		}));
	}
	
	// increase or decrease the clustering level
	function increaseValue() {
  		var value = parseInt(document.getElementById('hc_level').value, 10);
  		value = isNaN(value) ? 0 : value;
  		value++;
  		document.getElementById('hc_level').value = value;
	}

	function decreaseValue() {
 		var value = parseInt(document.getElementById('hc_level').value, 10);
 		value = isNaN(value) ? 0 : value;
  		value < 1 ? value = 1 : '';
  		value--;
  		document.getElementById('hc_level').value = value;
	}
	
	// increase or decrease the clustering level - for the hierarchical clustering of dimensions
	function dim_increaseValue() {
  		var value = parseInt(document.getElementById('dim_hc_level').value, 10);
  		value = isNaN(value) ? 0 : value;
  		value++;
  		document.getElementById('dim_hc_level').value = value;
	}

	function dim_decreaseValue() {
 		var value = parseInt(document.getElementById('dim_hc_level').value, 10);
 		value = isNaN(value) ? 0 : value;
  		value < 1 ? value = 1 : '';
  		value--;
  		document.getElementById('dim_hc_level').value = value;
	}
	
	// increase or decrease the clustering level - for the kmeans clustering of dimensions
	function dim_increaseValue_kmeans() {
  		var value = parseInt(document.getElementById('dim_kmeans').value, 10);
  		value = isNaN(value) ? 0 : value;
  		value++;
  		document.getElementById('dim_kmeans').value = value;
	}

	function dim_decreaseValue_kmeans() {
 		var value = parseInt(document.getElementById('dim_kmeans').value, 10);
 		value = isNaN(value) ? 0 : value;
  		value < 1 ? value = 1 : '';
  		value--;
  		document.getElementById('dim_kmeans').value = value;
	}

	// Calculates the correlation coefficient for two variables.
 	// @param {[number]} x Array of numbers.
 	// @param {[number]} y Array of numbers.
	// @param {boolean} [standardize] If false, x and y will not be standardized.
	function pearson(x, y, standardize) {
        var n, d, i;
        standardize = typeof standardize === "boolean" ? standardize : true;
        if (standardize === true) {
            x = standardizeit(x);
            y = standardizeit(y);
        }
        n = x.length;
        d = new Array(n);
        for (i = 0; i < n; i++) {
            d[i] = x[i] * y[i];
        }
        return sum(d) / (n - 1);
    }
     
    // @param {boolean} [rank] If false, x and y will not be ranked.
	function spearman(x, y, rank) {
        var xDeviation, yDeviation;
        rank = typeof rank === "boolean" ? rank : true;
        if (rank === true) {
            x = rank(x);
            y = rank(y);
        }
        xDeviation = deviation(x);
        yDeviation = deviation(y);
        return sum(xDeviation.map(function (xi, i) {
            return xi * yDeviation[i];
        })) / Math.sqrt(sum(xDeviation.map(function (xi) {
            return Math.pow(xi, 2);
        })) * sum(yDeviation.map(function (yi) {
            return Math.pow(yi, 2);
        })));
    }
    
    // @param {[number]} x Array of numbers.
    function sort (x) {
        var copy;
     	// Copy array.
        copy = x.slice();
        return copy.sort(function (a, b) {
            return a - b;
        });
    }

 	// @param {number} x Number to round.
 	// @param {number} [n] Number of decimal places.
    function round(x, n) {
        n = typeof n === "number" ? n : 0;
        return Math.round(x * Math.pow(10, n)) / Math.pow(10, n);
    }

 	// @param {[number]} x Array of numbers.
    function min(x) {
        var min, i, n;
        min = Infinity;
        for (i = 0, n = x.length; i < n; i++) {
            if (x[i] < min) {
                min = x[i];
            }
        }
        return min;
    }

 	// @param {[number]} x Array of numbers.
    function max(x) {
        var max, i, n;
        max = -Infinity;
        for (i = 0, n = x.length; i < n; i++) {
            if (x[i] > max) {
                max = x[i];
            }
        }
        return max;
    }

 	// @param {number} start Start value.
 	// @param {number} stop Stop value.
    function range(start, stop) {
        var len, range, idx;
        len = stop - start;
        range = new Array(len);
        for (idx = 0; idx < len; idx++) {
            range[idx] = start++;
        }
        return range;
    }

 	// @param {[number]} x Array of numbers.
   	function sum(x) {
        var sum, i, n;
        sum = 0;
        for (i = 0, n = x.length; i < n; i++) {
            sum += x[i];
        }
        return sum;
    }

 	// @param {[number]} x Array of numbers.
    function median(x) {
        var sorted;
        if (x.length === 1) {
            return x[0];
        } else {
            sorted = sort(x);
            if (sorted.length % 2 === 0) {
                return mean([x[(sorted.length / 2) - 1], x[sorted.length / 2]]);
            } else {
                return x[Math.floor(sorted.length / 2)];
            }
        }
    }

 	// @param {[number]} x Array of numbers.
    function mean (x) {
        return sum(x) / x.length;
    }

 	// @param {[number]} x Array of numbers.
    function deviation (x) {
        var xBar, n, d, i;
        xBar = mean(x);
        n = x.length;
        d = new Array(n);
        for (i = 0; i < n; i++) {
            d[i] = x[i] - xBar;
        }
        return d;
    }

 	// Calculates the variance.
 	// @param {[number]} x Array of numbers.
 	// @param {boolean} [bias] If true, the biased sample variance is used.
    function variance(x, bias) {
        var d, i, n;
        bias = typeof bias === "boolean" ? bias : false;
        d = deviation(x);
        n = d.length;
        for (i = 0; i < n; i++) {
            d[i] = Math.pow(d[i], 2);
        }
        return sum(d) / (n - (bias === false ? 1 : 0));
    }

 	// Calculates the sample standard deviation.
 	// @param {[number]} x Array of numbers.
 	// @param {boolean} [bias] If true, the biased sample variance is used.
    function standardDeviation(x, bias) {
        bias = typeof bias === "boolean" ? bias : false;
        return Math.sqrt(variance(x, bias));
    }

 	// @param {[number]} x Array of numbers.
    function standardize(x) {
        var sd, d, i, n;
        sd = standardDeviation(x);
        d = deviation(x);
        for (i = 0, n = d.length; i < n; i++) {
            d[i] = d[i] / sd;
        }
        return d;
    }
    function standardizeit(x) {
        var sd, d, i, n;
        sd = standardDeviation(x);
        d = deviation(x);
        for (i = 0, n = d.length; i < n; i++) {
            d[i] = d[i] / sd;
        }
        return d;
    }

 	// @param {[number]} x Array of numbers.
    function rank(x) {
        var sorted, d, i, n;
        n = x.length;
        sorted = sort(x);
        d = new Array(n);
        for (i = 0; i < n; i++) {
            var rank, first, last;
         // Handle tied ranks.
            first = sorted.indexOf(x[i]);
            last = sorted.lastIndexOf(x[i]);
            if (first === last) {
                rank = first;
            } else {
                rank = (first + last) / 2;
            }
         // Add 1 because ranks start with 1.
            d[i] = rank + 1;
        }
        return d;
    }
    
    // @param {[number]} x Array of numbers.
 	// @param {[number]} y Array of numbers.
    function euclidean(x, y) {
        return Math.sqrt(sum(x.map(function (xi, i) {
            return Math.pow(xi - y[i], 2);
        })));
    }
    function manhattan(x, y) {
        return sum(x.map(function (xi, i) {
            return Math.abs(xi - y[i]);
        }));
    }
    function cosineSimi(x, y){
    	var numerator = sum(x.map(function(xi, i){
    		return xi * y[i];
    	}))
    	var denominator = Math.sqrt(sum(x.map(function(xi, i){ return xi*xi;}))) * Math.sqrt(sum(y.map(function(yi, i){ return yi*yi;})))
    	return numerator / denominator;
    }

 	// @param {[[number]]} x Array of array of numbers.
 	// @param {(x, y)} distanceMetric Distance metric.
 	// TODO: Save memory by throwing away upper or lower triangle and diagonal.
    function pairwiseDistance(x) {
        var pairwiseDistances, distance, i, j;
        pairwiseDistances = [];
        for (i = 0; i < x.length; i++) {
            pairwiseDistances[i] = [];
            for (j = 0; j <= i; j++) {
                if (i === j) {
                    pairwiseDistances[i][j] = 0;
                } else {
                    distance = euclidean(x[i], x[j]);
                    pairwiseDistances[i][j] = distance;
                    pairwiseDistances[j][i] = distance;
                }
            }
        }
        return pairwiseDistances;
    }
    
    // @param {[[number]]} pairwiseDistances Pairwise distance matrix.
 	// @param {string} linkage Linkage criterion.
 	// Inspired by Heather Arthur's clusterfck: https://github.com/harthur/clusterfck
    function hierarchicalClustering(pairwiseDistances, linkage) {
        var clusters, minDistance, clusterA, clusterB, distance, distanceA,
            distanceB, candidates, mergedCluster, i, j;
        if (["single", "complete", "upgma"].indexOf(linkage) === -1) {
            throw new Error("The second argument (linkage) has to be either one of \"single\", \"complete\", or \"upgma\".");
        }
        clusters = [];
     	// Initialize one cluster per observation.
        for (i = 0; i < pairwiseDistances.length; i++) {
            clusters.push({
                label: i,
                key: i,
                index: i,
                size: 1
            });
        }
        while (true) {
         // Stop if all clusters have been merged into a single cluster.
            if (clusters.length === 1) {
                delete clusters[0].index;
                delete clusters[0].key;
                break;
            }
         // Find closest clusters.
            minDistance = Infinity;
            for (i = 0; i < clusters.length; i++) {
                clusterA = clusters[i];
                for (j = 0; j < clusters.length; j++) {
                    if (i !== j) {
                        clusterB = clusters[j];
                        distance = pairwiseDistances[clusterA.key][clusterB.key];
                        if (distance < minDistance) {
                            minDistance = distance;
                            candidates = [clusterA, clusterB];
                        }
                    }
                }
            }
         // Merge clusters.
            mergedCluster = {
                children: candidates,
                key: candidates[0].key,
                distance: minDistance,
                size: candidates[0].size + candidates[1].size
            };
         // Replace first cluster with merged cluster in list of clusters.
            clusters[candidates[0].index] = mergedCluster;
         // Remove second cluster from list of clusters.
            clusters.splice(candidates[1].index, 1);
         // Recompute distances from merged cluster to all other clusters.
            for (i = 0; i < clusters.length; i++) {
                if (clusters[i].key === candidates[0].key) {
                    distance = 0;
                } else {
                    distanceA = pairwiseDistances[candidates[0].key][clusters[i].key];
                    distanceB = pairwiseDistances[candidates[1].key][clusters[i].key];
                    switch (linkage) {
                        case "single":
                            if (distanceA < distanceB) {
                                distance = distanceA;
                            } else {
                                distance = distanceB;
                            }
                            break;
                        case "complete":
                            if (distanceA > distanceB) {
                                distance = distanceA;
                            } else {
                                distance = distanceB;
                            }
                            break;
                        case "upgma":
                            distance = ((distanceA * candidates[0].size) + (distanceB * candidates[1].size)) / (candidates[0].size + candidates[1].size);
                            break;
                    }
                }
                pairwiseDistances[candidates[0].key][clusters[i].key] = distance;
                pairwiseDistances[clusters[i].key][candidates[0].key] = distance;
            }
         // Remove column of second cluster from pairwise distance matrix.
            for (i = 0; i < pairwiseDistances.length; i++) {
                pairwiseDistances[i].splice(candidates[1].key, 1);
            }
         // Remove row of second cluster from pairwise distance matrix.
            pairwiseDistances.splice(candidates[1].key, 1);
         // Update keys of clusters to reflect removal of the column.
            for (i = candidates[1].key; i < clusters.length; i++) {
                clusters[i].key--;
            }
         // Remove obsolete key and index of merged clusters.
            delete candidates[0].key;
            delete candidates[0].index;
            delete candidates[1].key;
            delete candidates[1].index;
         // Reindex clusters.
            for (i = 0; i < clusters.length; i++) {
                clusters[i].index = i;
            }
        }
        return clusters;
    }
    
    // For a specified dimension on PC, check its value distribution on the document map (not in use)
    function checkDimension_pc(){
		console.log("check " + currentDimension);
	}
	// For a specified dimension on PC, select into the feature/dimension pool
	function selectDimension_pc(){
		//console.log("select " + currentDimension);
		selectedDimensions.push(currentDimension);
		var str = "";
		for(var dim in selectedDimensions){
			str += selectedDimensions[dim];
			if(dim != selectedDimensions.length - 1) str += ",";
		}
		document.getElementById('dimensions').value = str;
		//console.log(selectedDimensions);
	}
	// For a specified dimension on PC, unselect from the feature/dimension pool
	function unselectDimension_pc(){
		//console.log("unselect " + currentDimension);
		selectedDimensions.splice(selectedDimensions.indexOf(currentDimension), 1);
		var str = "";
		for(var dim in selectedDimensions){
			str += selectedDimensions[dim];
			if(dim != selectedDimensions.length - 1) str += ",";
		}
		document.getElementById('dimensions').value = str;
		//console.log(selectedDimensions);
	}
	
	// clear the heatmap of a selected article
	function clearArticleHeatmap(){
        d3.select("#articleProfile").selectAll("*").remove();
        d3.select("#articleProfile").style("height", 0);
    }
    
    // click from one article's profile to select/unselect an article as an reference article
	var articlesReference = []; // user selected reference articles
	function selectReference(){
		var id = current_dot;
		if(!articlesReference.includes(id)){
			articlesReference.push(id);
			d3.select("#selectReference").text("unSelect from Reference Articles");
		}
		else{
			articlesReference.splice(articlesReference.indexOf(id), 1);
			d3.select("#selectReference").text("Select as Reference Article");
		}
	}
	// click from one article's profile to unselect (reset)) all reference articles
	function selectReference_reset(){
		articlesReference = [];
		d3.select("#selectReference").text("Select as a Reference Article");
	}
    
	// switch among tabs for different levels of dimension exploration
	function openTab(evt, tabName) {
    	var i, tabcontent, tablinks;
    	tabcontent = document.getElementsByClassName("tabcontent");
    	for (i = 0; i < tabcontent.length; i++) {
        	tabcontent[i].style.display = "none";
    	}
    	tablinks = document.getElementsByClassName("tablinks");
    	for (i = 0; i < tablinks.length; i++) {
        	tablinks[i].className = tablinks[i].className.replace(" active", "");
    	}
    	document.getElementById(tabName).style.display = "block";
    	evt.currentTarget.className += " active";
	}
	
	// get the quartile
	function Quartile(data, q) {
  		data=Array_Sort_Numbers(data);
  		var pos = ((data.length) - 1) * q;
  		var base = Math.floor(pos);
  		var rest = pos - base;
  		if( (data[base+1]!==undefined) ) {
    		return data[base] + rest * (data[base+1] - data[base]);
  		} else {
    		return data[base];
  		}
	}
	function Array_Sort_Numbers(inputarray){
  		return inputarray.sort(function(a, b) {
    		return a - b;
  		});
	}
    
	</script>
  </body>
</html>